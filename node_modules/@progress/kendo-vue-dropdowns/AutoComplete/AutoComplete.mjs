/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { defineComponent as E, createVNode as u, ref as M, h as R } from "vue";
import { SearchBar as _ } from "../common/SearchBar.mjs";
import { ListContainer as q } from "../common/ListContainer.mjs";
import { List as z } from "../common/List.mjs";
import W from "../common/DropDownBase.mjs";
import { GroupStickyHeader as U } from "../common/GroupStickyHeader.mjs";
import { ClearButton as J } from "../common/ClearButton.mjs";
import { areSame as D, getFocusedItem as T, itemIndexStartsWith as Q, getItemValue as O } from "../common/utils.mjs";
import { setRef as X, classNames as B, kendoThemeMaps as Y, Keys as c, getRef as H, guid as L, templateRendering as S, getListeners as v, getTemplate as A } from "@progress/kendo-vue-common";
const {
  sizeMap: N,
  roundedMap: Z
} = Y, ee = "Please enter a valid value!", ue = /* @__PURE__ */ E({
  name: "KendoAutoComplete",
  model: {
    event: "changemodel"
  },
  props: {
    id: String,
    defaultValue: {
      type: [String],
      default: void 0
    },
    name: String,
    modelValue: {
      type: [String],
      default: void 0
    },
    value: {
      type: [String],
      default: void 0
    },
    label: {
      type: String
    },
    placeholder: String,
    required: {
      type: Boolean,
      default: !1
    },
    valid: {
      type: Boolean,
      default: void 0
    },
    validationMessage: {
      type: String,
      default: void 0
    },
    validityStyles: {
      type: Boolean,
      default: !0
    },
    opened: {
      type: Boolean,
      default: void 0
    },
    disabled: Boolean,
    dir: {
      type: String,
      default: void 0
    },
    tabIndex: {
      type: Number,
      default: void 0
    },
    readonly: Boolean,
    accessKey: String,
    dataItems: Array,
    textField: String,
    loading: Boolean,
    popupSettings: {
      type: Object,
      default: function() {
        return {
          animate: !0,
          height: "200px",
          anchor: ""
        };
      }
    },
    itemRender: [String, Function, Object],
    groupHeaderItemRender: [String, Function, Object],
    groupStickyHeaderItemRender: [String, Function, Object],
    listNoDataRender: [String, Function, Object],
    focusedItemIndex: Function,
    header: [String, Function, Object],
    footer: [String, Function, Object],
    suggest: {
      type: [Boolean, String],
      default: !1
    },
    ariaLabel: {
      type: String,
      default: void 0
    },
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    rounded: {
      type: String,
      default: "medium",
      validator: function(e) {
        return ["small", "medium", "large", "full"].includes(e);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function(e) {
        return ["solid", "flat", "outline"].includes(e);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function(e) {
        return ["small", "medium", "large"].includes(e);
      }
    },
    groupField: {
      type: String
    },
    inputAttributes: Object
  },
  data() {
    return {
      hasMounted: !1,
      currentText: "",
      currentValue: "",
      currentFocused: !1,
      currentOpened: !1,
      focusedItem: void 0,
      searchState: {
        word: "",
        last: ""
      },
      valueDuringOnChange: {},
      suggested: "",
      group: void 0,
      isScrolling: !1,
      popupWidth: void 0,
      itemHeight: 0
    };
  },
  created() {
    this.valueDuringOnChange = void 0, this.currentText = void 0, this.currentValue = void 0, this.currentFocused = void 0, this.currentOpened = void 0, this.base = new W(this), this.anchor = L(), this.inputId = L();
  },
  setup() {
    const e = M(null), t = M(null);
    return {
      inputRef: e,
      kendoAnchorRef: t
    };
  },
  mounted() {
    this.hasMounted = !0, this.input = this.inputRef.input, this.base.wrapper = H(this, "kendoAnchor"), this.element = H(this, "kendoAnchor"), this.base.didMount(), this.setValidity();
  },
  watch: {
    currentOpened: function(e, t) {
      this.prevCurrentOpened = t;
    },
    opened: function(e, t) {
      this.prevOpened = t;
    },
    dataItems: function(e, t) {
      this.prevData = t;
    },
    focusedItem: function(e, t) {
      this.prevFocusedItem = t;
    }
  },
  updated() {
    var m;
    const {
      groupField: e = "",
      dataItems: t = []
    } = this.$props, i = this.focusedIndex(), s = t[i], n = this.prevData !== t, o = s !== void 0 && this.prevFocusedItem !== s, d = this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened, a = this.prevOpened !== void 0 ? this.prevOpened : this.prevCurrentOpened, r = !a && d, l = this.$refs.list;
    if (l && (this.base.vs.list = l.list, this.base.list = l.list), e === "")
      (d && (o || n) || r) && this.base.scrollToItem(i);
    else if (!this.isScrolling) {
      let p = (m = this.base.getGroupedDataModernMode(t, e)) == null ? void 0 : m.indexOf(s);
      r && (t && t.length !== 0 && this.base.resetGroupStickyHeader(t[0][e], this), this.base.scrollToItem(p)), d && a && o && this.base.scrollToItem(p);
    }
    this.setValidity();
  },
  computed: {
    spanClassNames() {
      const e = !this.hasMounted || !this.$props.validityStyles || this.validity().valid;
      return {
        "k-floating-label-container": !0,
        "k-focus": this.currentFocused,
        "k-empty": !this.computedValue(),
        "k-invalid": !e && e !== void 0,
        "k-rtl": this.$props.dir === "rtl"
      };
    }
  },
  methods: {
    focus() {
      this.input && this.input.focus();
    },
    computedValue() {
      let e;
      return this.valueDuringOnChange !== void 0 ? e = this.valueDuringOnChange : this.$props.value !== void 0 ? e = this.$props.value : this.$props.modelValue !== void 0 ? e = this.$props.modelValue : this.currentValue !== void 0 ? e = this.currentValue : this.$props.defaultValue !== void 0 && (e = this.$props.defaultValue), e;
    },
    primitiveValue() {
      const e = this.computedValue();
      return this.valuePrimitive ? O(e, this.valueField) : e;
    },
    validity() {
      const e = this.$props.validationMessage !== void 0, t = !this.$props.required || this.computedValue() !== null && this.computedValue() !== "" && this.computedValue() !== void 0, i = this.$props.valid !== void 0 ? this.$props.valid : t;
      return {
        customError: e,
        valid: i,
        valueMissing: this.computedValue() === null
      };
    },
    handleItemSelect(e, t) {
      const {
        dataItems: i = []
      } = this.$props, s = i[e], n = O(s, this.$props.textField);
      this.triggerOnChange(n, t, {
        item: s
      }), this.triggerOnSelect(t, {
        item: s
      });
    },
    itemFocus(e, t) {
      const {
        dataItems: i = [],
        textField: s
      } = this.$props, n = i[e];
      D(this.$data.focusedItem, n, s) || (t.data.focusedItem = n);
    },
    togglePopup(e) {
      this.base.togglePopup(e);
    },
    onNavigate(e, t) {
      const i = this.computedValue(), {
        dataItems: s = [],
        textField: n,
        focusedItemIndex: o
      } = this.$props, d = this.$data.focusedItem !== void 0 ? s.findIndex((r) => D(r, this.$data.focusedItem, n)) : o ? o(s, i, n) : s.indexOf(T(s, i, n)), a = this.base.navigation.navigate({
        keyCode: t,
        current: d,
        max: s.length - 1,
        min: 0
      });
      a !== void 0 && this.itemFocus(a, e), this.applyState(e);
    },
    /**
     * @hidden
     */
    applyInputValue(e, t, i) {
      const s = this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened, {
        dataItems: n = [],
        textField: o
      } = this.$props;
      if (this.suggested = "", s && i === c.enter) {
        const d = n[this.focusedIndex(e)], a = O(d, o);
        this.triggerOnChange(a, t, {
          item: d
        }), this.triggerOnSelect(t, {
          item: d
        });
      }
      s && this.togglePopup(t), this.applyState(t);
    },
    setValidity() {
      this.input && this.input.setCustomValidity && this.input.setCustomValidity(this.validity().valid ? "" : this.$props.validationMessage || ee);
    },
    handleItemClick(e, t) {
      this.base.handleItemClick(e, t), this.valueDuringOnChange = void 0;
    },
    onChangeHandler(e) {
      const i = this.base.initState(), s = e.target, n = s.value, o = s.selectionEnd === n.length;
      i.event = e;
      const d = this.suggested, a = this.computedValue(), r = a && d && a.substring(0, a.length - d.length), l = r && r === n, m = r && r.length > n.length, {
        suggest: p
      } = this.$props, h = this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened;
      if (p !== void 0 && p !== !1) {
        l || m || !o ? this.suggested = "" : this.suggestValue(n);
        const k = n + this.suggested, V = {
          userInput: n,
          value: this.suggested
        };
        this.triggerOnChange(k, i, {
          suggestion: V
        });
      } else
        this.suggested = "", this.triggerOnChange(n, i);
      (!h && n || h && !n) && this.togglePopup(i), i.data.focusedItem = void 0, this.prevData && this.prevData.length !== this.$props.dataItems && (i.data.group = void 0), this.applyState(i);
    },
    clearButtonClick(e) {
      const i = this.base.initState(), s = this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened;
      i.event = e;
      const n = "";
      this.suggested = "", this.triggerOnChange(n, i), this.$data.focusedItem !== void 0 && (i.data.focusedItem = void 0), s && this.togglePopup(i), this.applyState(i);
    },
    onInputKeyDown(e) {
      this.isScrolling && (this.isScrolling = !1);
      const t = e.keyCode, i = this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened, s = this.base.initState(), n = this.computedValue();
      s.event = e;
      const o = () => {
        i && e.preventDefault();
      };
      t === c.enter || i && t === c.esc || e.altKey && t === c.up ? (o(), this.applyInputValue(e.currentTarget.value, s, e.keyCode)) : !e.altKey && (t === c.up || t === c.down) ? (o(), this.onNavigate(s, t)) : !i && t === c.esc ? this.clearButtonClick(e) : !i && n && e.altKey && t === c.down && (this.togglePopup(s), this.applyState(s));
    },
    handleBlur(e) {
      if (this.currentFocused) {
        const t = this.base.initState();
        t.data.focused = !1, t.events.push({
          type: "blur"
        }), t.event = e, this.applyInputValue(e.currentTarget.value, t), this.currentFocused = !1;
      }
    },
    triggerOnChange(e, t, i) {
      this.computedValue() === e && !i || (t.data.currentValue = e, this.valueDuringOnChange = e, t.events.push({
        type: "change",
        ...i || {}
      }));
    },
    triggerOnSelect(e, t) {
      e.events.push({
        type: "select",
        ...t || {}
      });
    },
    applyState(e) {
      this.base.applyState(e), this.valueDuringOnChange = void 0;
    },
    suggestValue(e) {
      if (this.suggested = "", e) {
        const {
          dataItems: t = [],
          textField: i
        } = this.$props, s = t[Q(t, e, i)];
        if (s) {
          const n = O(s, i);
          e.toLowerCase() !== n.toLowerCase() && (this.suggested = n.substring(e.length));
        }
      }
    },
    focusedIndex(e) {
      const {
        dataItems: t = [],
        textField: i,
        focusedItemIndex: s
      } = this.$props, n = e !== void 0 ? e : this.computedValue();
      return this.$data.focusedItem !== void 0 ? t.findIndex((o) => D(o, this.$data.focusedItem, i)) : s ? s(t, n, i) : Math.max(0, t.indexOf(T(t, n, i)));
    },
    repositionPopup() {
      this.base.repositionPopup();
    },
    onScroll(e) {
      this.isScrolling = !0;
      const t = this.base.initState(), {
        list: i
      } = this.base, {
        groupField: s
      } = this.$props;
      let {
        dataItems: n = []
      } = this.$props;
      if (!s || !n.length)
        return;
      let o = this.itemHeight || (i.children ? i.children[0].offsetHeight : 0);
      const a = e.target.scrollTop;
      s && (n = this.base.getGroupedDataModernMode(n, s));
      let r = n[0][s];
      o === 0 && (o = 28);
      for (let l = 1; l < n.length && !(o * l > a); l++)
        n[l] && n[l][s] && (r = n[l][s]);
      r !== this.group && (t.data.group = r, this.applyState(t));
    }
  },
  render() {
    const {
      dir: e,
      disabled: t,
      label: i,
      size: s,
      rounded: n,
      fillMode: o,
      style: d,
      loading: a,
      suggest: r,
      inputAttributes: l
    } = this.$props, m = !this.$props.validityStyles || this.validity().valid, p = this.currentFocused, h = this.base, k = this.computedValue(), V = !a && !!k, F = this.$props.id || this.inputId, x = Object.assign({}, {
      animate: !0,
      height: "200px"
    }, this.$props.popupSettings);
    typeof r == "string" && (this.suggested = r);
    const K = function(I, g) {
      const {
        placeholder: f,
        tabIndex: y,
        readonly: $
      } = this.$props, C = this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened;
      return u(_, {
        id: g,
        placeholder: f,
        tabIndex: y,
        accessKey: this.$props.accessKey,
        value: I,
        suggestedText: this.suggested,
        focused: p,
        name: this.$props.name,
        ref: (b) => {
          this.inputRef = b;
        },
        onKeydown: this.onInputKeyDown,
        onChange: this.onChangeHandler,
        onFocus: h.handleFocus,
        onBlur: this.handleBlur,
        disabled: t,
        readOnly: $,
        expanded: C,
        owns: h.listBoxId,
        activedescendant: "option-" + h.guid + "-" + this.focusedIndex(),
        onClearbuttonclick: this.clearButtonClick,
        ariaLabelledBy: this.$props.ariaLabelledBy,
        ariaDescribedBy: this.$props.ariaDescribedBy,
        ariaLabel: this.$props.ariaLabel,
        inputAttributes: l
      }, null);
    }, P = function() {
      const {
        textField: I,
        groupField: g
      } = this.$props;
      let f = this.$props.dataItems || [];
      const y = S.call(this, this.$props.itemRender, v.call(this)), $ = S.call(this, this.$props.groupHeaderItemRender, v.call(this)), C = S.call(this, this.$props.listNoDataRender, v.call(this)), b = this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened;
      return g && (f = this.base.getGroupedDataModernMode(f, g)), u(z, {
        id: h.listBoxId,
        show: b,
        dataItems: f.slice(),
        focusedIndex: this.focusedIndex(),
        value: k,
        textField: I,
        valueField: I,
        highlightSelected: !1,
        optionsGuid: h.guid,
        ref: "list",
        wrapperStyle: {
          maxHeight: x.height
        },
        wrapperCssClass: "k-list-content",
        onListclick: this.handleItemClick,
        itemRender: y,
        groupHeaderItemRender: $,
        noDataRender: C,
        groupField: g,
        onScroll: this.onScroll
      }, null);
    }, j = function() {
      const I = S.call(this, this.$props.header, v.call(this)), g = S.call(this, this.$props.footer, v.call(this)), f = S.call(this, this.$props.groupStickyHeaderItemRender, v.call(this)), y = A.call(this, {
        h: R,
        template: I
      }), $ = A.call(this, {
        h: R,
        template: g
      }), C = this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened, b = this.$props.dataItems || [];
      return this.group === void 0 && this.$props.groupField !== void 0 && (this.group = O(b[0], this.$props.groupField)), u(q, {
        onMousedown: (G) => G.preventDefault(),
        width: this.popupWidth,
        ref: "container",
        popupSettings: {
          ...x,
          anchor: this.anchor,
          show: C,
          popupClass: B(x.popupClass, "k-list", {
            [`k-list-${N[s] || s}`]: s
          }),
          className: B("k-list-container", x.className)
        },
        dir: e !== void 0 ? e : this.base.dirCalculated
      }, {
        default: () => [y && u("div", {
          class: "k-list-header"
        }, [y]), this.group && b.length !== 0 && u(U, {
          group: this.group,
          render: f
        }, null), P.call(this), $ && u("div", {
          class: "k-list-footer"
        }, [$])]
      });
    }, w = u("span", {
      class: B("k-autocomplete k-input", {
        [`k-input-${N[s] || s}`]: s,
        [`k-rounded-${Z[n] || n}`]: n,
        [`k-input-${o}`]: o,
        "k-invalid": !m,
        "k-focus": p && !t,
        "k-loading": a,
        "k-required": this.required,
        "k-disabled": t
      }),
      ref: X(this, "kendoAnchor"),
      style: i ? {
        ...d,
        width: void 0
      } : d,
      dir: e
    }, [K.call(this, k || "", F), V && !a && u(J, {
      onClearclick: this.clearButtonClick
    }, null), u("span", {
      class: a ? "k-input-loading-icon k-icon k-i-loading" : void 0
    }, null), j.call(this)]);
    return i ? u("span", {
      class: this.spanClassNames,
      dir: this.$props.dir
    }, [w, this.$props.label ? F ? u("label", {
      for: F,
      class: "k-floating-label"
    }, [this.$props.label]) : u("span", {
      class: "k-label"
    }, [this.$props.label]) : null]) : w;
  }
});
export {
  ue as AutoComplete
};
