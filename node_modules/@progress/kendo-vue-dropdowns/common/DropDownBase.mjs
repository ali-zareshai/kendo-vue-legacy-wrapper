/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
var h = Object.defineProperty;
var d = (a, e, t) => e in a ? h(a, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[e] = t;
var p = (a, e, t) => d(a, typeof e != "symbol" ? e + "" : e, t);
import u from "./VirtualScroll.mjs";
import { Navigation as g } from "./Navigation.mjs";
import { scrollToItem as m, areSame as r } from "./utils.mjs";
import { validatePackage as f, guid as l, templateRendering as S, getListeners as v, getTemplate as y } from "@progress/kendo-vue-common";
import { packageMetadata as k } from "../package-metadata.mjs";
class C {
  constructor(e) {
    p(this, "vs", new u());
    p(this, "navigation", new g());
    p(this, "handleItemClick", (e, t) => {
      const n = this.initState();
      n.event = t, this.component.handleItemSelect(e, n), this.togglePopup(n), this.applyState(n);
    });
    p(this, "handleFocus", (e) => {
      if (!this.component.currentFocused) {
        const t = this.initState();
        t.data.currentFocused = !0, t.events.push({
          type: "focus"
        }), t.event = e, this.applyState(t);
      }
    });
    p(this, "filterChanged", (e, t) => {
      const n = this.component, {
        textField: i,
        filterable: o
      } = n.$props;
      o && (t.events.push({
        type: "filterchange",
        filter: {
          field: i,
          operator: "contains",
          ignoreCase: !0,
          value: e
        }
      }), this.repositionPopup());
    });
    p(this, "togglePopup", (e) => {
      const t = this.component.$props, n = t.opened !== void 0 ? t.opened : this.component.currentOpened;
      t.opened === void 0 && (e.data.currentOpened = !n), n ? e.events.push({
        type: "close"
      }) : (e.events.push({
        type: "open"
      }), this.calculatePopupWidth());
    });
    p(this, "pageChange", (e, t) => {
      const n = this.initState();
      n.event = t, this.triggerOnPageChange(n, e.skip, e.take), this.applyState(n);
    });
    p(this, "scrollChange", (e) => {
      this.component.$emit("scroll", e);
    });
    p(this, "scrollToVirtualItem", (e, t) => {
      const n = this.vs;
      if (n.enabled = !1, e.skip === 0)
        n.reset();
      else if (e.skip + e.pageSize === e.total)
        n.scrollToEnd();
      else {
        let i = n.translate;
        i === 0 && (n.calcScrollElementHeight(), i = n.itemHeight * e.skip, n.translateTo(i - n.itemHeight)), n.container && (n.container.scrollTop = i), this.scrollToItem(t, !0);
      }
      setTimeout(() => n.enabled = !0, 10);
    });
    p(this, "getGroupedDataModernMode", (e, t) => {
      const n = [];
      return e.forEach((i, o) => {
        e[o - 1] && i[t] !== e[o - 1][t] && n.push({
          [t]: i[t]
        }), n.push(e[o]);
      }), n;
    });
    p(this, "resetGroupStickyHeader", (e, t) => {
      const n = this.initState();
      e !== t.group && t.state && (t.state.data.group = e, this.applyState(n));
    });
    f(k), this.listBoxId = l(), this.guid = l(), this.component = e, this.vs.PageChange = this.pageChange, this.vs.ScrollChange = this.scrollChange;
  }
  didMount() {
    const e = this.component.$props, t = e.popupSettings, n = e.style, i = t && t.width;
    let o = e.opened === !0;
    i === void 0 && this.calculatePopupWidth(), e.dir === void 0 && n && n.direction === void 0 && (this.calculateDir(), o = !0), o && this.component.$forceUpdate();
  }
  calculateDir() {
    this.component.element && (this.dirCalculated = window.getComputedStyle(this.component.element).direction || void 0);
  }
  calculatePopupWidth() {
    const e = this.component.$props, t = e.popupSettings, n = t && t.width;
    this.wrapper && !n && (this.component.popupWidth = e.popupSettings.width !== void 0 ? e.popupSettings.width : this.wrapper.offsetWidth + "px");
  }
  scrollToItem(e, t) {
    const n = this.list || this.vs.list, i = n ? n.children[0] : void 0;
    if (i && e >= 0) {
      const o = this.vs, s = o.container || n.parentNode;
      if (s) {
        const c = t !== void 0 ? t : o.enabled;
        m(s, i.offsetHeight, e, o.translate, c);
      }
    }
  }
  repositionPopup() {
    const e = this.component;
    setTimeout(function() {
      const t = e.$refs.container;
      if (t) {
        const n = t.$refs.popup;
        n && n.show && n.reposition();
      }
    }, 5);
  }
  initState() {
    return {
      data: {},
      events: [],
      event: void 0
    };
  }
  applyState(e) {
    Object.keys(e.data).length > 0 && Object.keys(e.data).forEach((i) => {
      this.component[i] = e.data[i];
    });
    const t = this.component.primitiveValue(), n = {
      event: e.event,
      component: this.component,
      target: {
        name: this.component.$props.name,
        value: t
      },
      value: t
    };
    e.events.forEach((i) => {
      const {
        type: o
      } = i;
      delete i.type, o && (o === "change" && (this.component.$emit("changemodel", t), this.component.$emit("update:modelValue", t)), this.component.$emit(o, {
        ...n,
        ...i
      }));
    });
  }
  triggerOnPageChange(e, t, n) {
    const i = this.component.$props.virtual;
    if (i) {
      const o = Math.min(Math.max(0, t), Math.max(0, i.total - n));
      o !== i.skip && e.events.push({
        type: "pagechange",
        page: {
          skip: o,
          take: n
        }
      });
    }
  }
  triggerPageChangeCornerItems(e, t) {
    const n = this.component.$props, {
      dataItems: i = [],
      dataItemKey: o,
      virtual: s
    } = n, c = n.opened !== void 0 ? n.opened : this.component.currentOpened;
    e && s && this.vs.enabled && (s.skip > 0 && r(e, i[0], o) ? this.triggerOnPageChange(t, s.skip - 1, s.pageSize) : s.skip + s.pageSize < s.total && r(e, i[i.length - 1], o) ? this.triggerOnPageChange(t, s.skip + 1, s.pageSize) : !c && s.skip + s.pageSize < s.total && r(e, i[i.length - 1], o) && this.triggerOnPageChange(t, s.skip + 1, s.pageSize));
  }
  getTemplateDef(e, t) {
    const n = S.call(this, e, v.call(this));
    return y.call(this, {
      h: t,
      template: n
    });
  }
  getListItemHeight(e) {
    const t = e && window.getComputedStyle(e);
    return t ? t.height.slice(0, t.height.length - 2) : 0;
  }
}
p(C, "defaultProps", {
  popupSettings: {
    animate: !0,
    height: "200px"
  },
  required: !1,
  validityStyles: !0
});
export {
  C as default
};
