/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const u = (e) => e != null, h = (e, t) => {
  for (let r = 0; r < e.length; r++)
    if (e.charAt(r) !== t)
      return !1;
  return !0;
}, a = (e, t, r) => {
  let n = e;
  return r && (n = [r].concat(n)), n.slice(t).concat(n.slice(0, t));
}, I = (e, t, r) => {
  if (!u(e))
    return !1;
  let n = String(e);
  return r && (n = n.toLowerCase()), n.indexOf(t) === 0;
}, w = (e, t, r, n, o) => {
  const s = e.offsetHeight, f = t * r + (o ? n - e.scrollTop : 0);
  if (o) {
    let i = 0;
    f + t > s ? i = f + t - s : f < 0 && (i = f), i !== 0 ? e.scrollTop += i : e.scrollTop === 0 && n !== 0 && (e.scrollTop = n);
  } else
    f + t > s + e.scrollTop ? e.scrollTop = f + t - s : f < e.scrollTop && (e.scrollTop -= e.scrollTop - f);
}, p = (e, t, r) => {
  let n = -1;
  if (t) {
    t = t.toLowerCase();
    for (let o = 0; o < e.length; o++) {
      const s = (c(e[o], r) || "") + "";
      if (s && s.toLowerCase().startsWith(t)) {
        n = o;
        break;
      }
    }
  }
  return n;
}, l = (e, t, r, n = !1) => {
  const o = (s) => n ? s : s.toLowerCase();
  return e.findIndex((s) => r ? o(c(s, r)) === o(t) : o(t) === o(s.toString()));
}, c = (e, t) => {
  if (t && u(e)) {
    const r = t.split(".");
    let n = e;
    return r.forEach((o) => {
      n = n ? n[o] : void 0;
    }), n;
  }
  return e;
}, T = (e = [], t = [], r) => {
  if (e === t)
    return !0;
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!g(e[n], t[n], r))
      return !1;
  return !0;
}, x = (e, t, r) => {
  t.forEach((n) => {
    const o = e.findIndex((s) => g(s, n, r));
    o !== -1 && e.splice(o, 1);
  });
}, g = (e, t, r) => e === t || u(e) === u(t) && c(e, r) === c(t, r), d = (e, t, r) => {
  if (t) {
    const n = l(e, t, r, !0);
    return n !== -1 ? e[n] : e[p(e, t, r)];
  }
  return e[0];
}, C = (e, t = [], r) => {
  let n = "";
  if (e) {
    const o = t[p(t, e, r)];
    if (o) {
      const s = c(o, r);
      e.toLowerCase() !== s.toLowerCase() && (n = s.substring(e.length));
    }
  }
  return n;
}, L = (e) => {
  e.target.nodeName !== "INPUT" && e.preventDefault();
}, D = (e, t, r) => !!e != !!t || e.text !== t.text ? !1 : e === t || T(e.data, t.data, r), N = typeof window != "undefined" && /Firefox/.test(window.navigator.userAgent), O = 17895697;
export {
  g as areSame,
  N as firefox,
  O as firefoxMaxHeight,
  d as getFocusedItem,
  l as getItemIndexByText,
  c as getItemValue,
  u as isPresent,
  p as itemIndexStartsWith,
  T as matchDataCollections,
  D as matchTags,
  I as matchText,
  L as preventDefaultNonInputs,
  x as removeDataItems,
  h as sameCharsOnly,
  w as scrollToItem,
  a as shuffleData,
  C as suggestValue
};
