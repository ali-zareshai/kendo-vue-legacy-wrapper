/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { defineComponent as he, h as u, createVNode as i, isVNode as ce } from "vue";
import { noop as T, Keys as a, getTabIndex as fe, templateRendering as h, getListeners as c, getTemplate as w, getRef as f, canUseDOM as me, kendoThemeMaps as ve, validatePackage as ge, guid as P, setRef as m, Icon as W, classNames as A } from "@progress/kendo-vue-common";
import { Popup as be } from "@progress/kendo-vue-popup";
import { provideLocalizationService as ye } from "@progress/kendo-vue-intl";
import { TreeView as K } from "@progress/kendo-vue-treeview";
import { packageMetadata as we } from "../package-metadata.mjs";
import { areSame as ke, getItemValue as Se, isPresent as $e } from "../common/utils.mjs";
import { ListNoData as Fe } from "./ListNoData.mjs";
import { nodata as L, messages as N, clear as z } from "../messages/main.mjs";
import { FloatingLabel as Ve } from "@progress/kendo-vue-labels";
import { ListFilter as j } from "../common/ListFilter.mjs";
import { Button as q } from "@progress/kendo-vue-buttons";
import { xIcon as _, caretAltDownIcon as xe } from "@progress/kendo-svg-icons";
import { MOBILE_MEDIUM_DEVICE as Re, MOBILE_SMALL_DEVICE as Ie } from "../common/constants.mjs";
import { ActionSheet as De } from "@progress/kendo-vue-layout";
import Ce from "../common/DropDownBase.mjs";
function G(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !ce(e);
}
const {
  sizeMap: Me,
  roundedMap: Oe
} = ve, Be = "Please select a value from the list!", H = (e) => e.split("_").map((t) => parseInt(t, 10)), V = (e, t) => {
  const {
    validationMessage: s,
    valid: n,
    required: o
  } = e;
  return {
    customError: s !== void 0,
    valid: !!(n !== void 0 ? n : !o || t),
    valueMissing: !t
  };
}, Xe = /* @__PURE__ */ he({
  name: "KendoDropDownTree",
  model: {
    event: "changemodel"
  },
  emits: {
    open: (e) => !0,
    close: (e) => !0,
    focus: (e) => !0,
    blur: (e) => !0,
    change: (e) => !0,
    filterchange: (e) => !0,
    expandchange: (e) => !0,
    changemodel: (e) => !0,
    "update:modelValue": (e) => !0
  },
  props: {
    opened: {
      type: Boolean,
      default: void 0
    },
    disabled: Boolean,
    dir: String,
    tabIndex: Number,
    accessKey: String,
    dataItems: {
      type: Array,
      default: function() {
        return [];
      }
    },
    value: {
      type: [Object, String, Number, Boolean],
      default: function() {
      }
    },
    modelValue: {
      type: [Object, String, Number, Boolean],
      default: function() {
      }
    },
    valueMap: Function,
    placeholder: String,
    dataItemKey: {
      type: String,
      required: !0
    },
    textField: {
      type: String,
      required: !0
    },
    selectField: {
      type: String,
      default: "selected"
    },
    expandField: String,
    subItemsField: {
      type: String,
      default: "items"
    },
    className: String,
    label: String,
    validationMessage: String,
    validityStyles: {
      type: Boolean,
      default: !0
    },
    valid: {
      type: Boolean,
      default: void 0
    },
    required: Boolean,
    name: String,
    id: String,
    ariaLabel: {
      type: String,
      default: void 0
    },
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    filterable: Boolean,
    filter: String,
    loading: Boolean,
    popupSettings: {
      type: Object,
      default: function() {
        return {
          animate: !0,
          height: "200px",
          anchor: ""
        };
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function(e) {
        return [null, "small", "medium", "large"].includes(e);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function(e) {
        return [null, "small", "medium", "large", "full"].includes(e);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function(e) {
        return [null, "flat", "outline", "solid"].includes(e);
      }
    },
    item: [String, Function, Object],
    header: [String, Function, Object],
    footer: [String, Function, Object],
    valueRender: [String, Function, Object],
    listNoData: [String, Function, Object],
    adaptive: {
      type: Boolean,
      default: void 0
    },
    adaptiveTitle: {
      type: String,
      default: void 0
    }
  },
  inject: {
    kendoLocalizationService: {
      default: null
    },
    adaptiveModeBreakpoints: {
      default: {
        small: Ie,
        medium: Re
      }
    }
  },
  created() {
    this.observer = null, ge(we), this.base = new Ce(this), this.componentGuid = P(), this.anchor = P();
  },
  data() {
    return {
      currentOpened: !1,
      focused: !1,
      filterState: "",
      currentValue: void 0,
      popupWidth: "200px",
      windowWidth: 0,
      initialAdaptiveRenderingValues: void 0
    };
  },
  computed: {
    wrapperClass() {
      const {
        validationMessage: e,
        valid: t,
        required: s,
        validityStyles: n
      } = this.$props, o = V({
        validationMessage: e,
        valid: t,
        required: s
      }, this.hasValue), d = !n || o.valid, {
        size: r,
        rounded: l,
        fillMode: p
      } = this.$props;
      return {
        "k-dropdowntree": !0,
        "k-picker": !0,
        [this.$props.className]: this.$props.className,
        [`k-picker-${Me[r] || r}`]: r,
        [`k-rounded-${Oe[l] || l}`]: l,
        [`k-picker-${p}`]: p,
        "k-focus": this.focused,
        "k-invalid": !d,
        "k-loading": this.$props.loading,
        "k-required": s,
        "k-disabled": this.$props.disabled
      };
    },
    animationStyles() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.small ? {
        top: 0,
        width: "100%",
        height: "100%"
      } : void 0;
    },
    classNameAdaptive() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.small ? "k-adaptive-actionsheet k-actionsheet-fullscreen" : "k-adaptive-actionsheet k-actionsheet-bottom";
    },
    adaptiveState() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.medium && this.$props.adaptive;
    },
    isOpen() {
      return this.opened !== void 0 ? this.opened : this.currentOpened;
    },
    computedValue() {
      return this.value !== void 0 ? this.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.currentValue;
    },
    hasValue() {
      return $e(this.computedValue);
    },
    currentValueText() {
      return this.hasValue ? Se(this.computedValue, this.$props.textField) : "";
    }
  },
  watch: {
    // This watch gets the state of the data when the adaptive mode is activated
    isOpen: function(e) {
      e && this.value ? this.initialAdaptiveRenderingValues = [this.value] : this.initialAdaptiveRenderingValues = void 0;
    }
  },
  mounted() {
    this.observer = me && window.ResizeObserver && new ResizeObserver(this.calculateMedia), document != null && document.body && this.observer && this.observer.observe(document.body), this.elementRef = f(this, "kendoAnchor"), this.inputRef = f(this, "input"), this.selectRef = f(this, "select"), this.treeViewRef = f(this, "treeView"), this.skipFocusRef = !1, this.popupRef = f(this, "popup"), this.calculatePopupWidth();
  },
  updated() {
    this.inputRef = f(this, "input"), this.treeViewRef = f(this, "treeView"), this.popupRef && this.isOpen && this.hasValue && this.popupRef.reposition(), this.setValidity(), this.calculatePopupWidth();
  },
  render() {
    let e;
    const t = this.$props.id || this.componentGuid, {
      dataItems: s,
      dataItemKey: n,
      popupSettings: o,
      disabled: d,
      placeholder: r,
      label: l,
      name: p,
      selectField: x,
      subItemsField: R,
      validationMessage: U,
      valid: J,
      required: I,
      validityStyles: Q,
      adaptiveTitle: X
    } = this.$props, k = fe(this.$props.tabIndex, d), D = ye(this), Y = V({
      validationMessage: U,
      valid: J,
      required: I
    }, this.hasValue), C = this.adaptiveState, v = this.$props.dir, M = h.call(this, this.item, c.call(this)), Z = h.call(this, this.valueRender, c.call(this)), ee = h.call(this, this.$props.header, c.call(this)), te = h.call(this, this.$props.footer, c.call(this)), S = w.call(this, {
      h: u,
      template: ee
    }), $ = w.call(this, {
      h: u,
      template: te
    }), ie = h.call(this, this.$props.listNoData, c.call(this)), se = i(Fe, null, G(e = D.toLanguageString(L, N[L])) ? e : {
      default: () => [e]
    }), O = w.call(this, {
      h: u,
      defaultRendering: se,
      template: ie
    }), ne = i("span", {
      class: "k-input-value-text"
    }, [this.currentValueText || r]), oe = w.call(this, {
      h: u,
      defaultRendering: ne,
      template: Z,
      additionalProps: {
        value: this.computedValue
      }
    }), ae = () => [i("div", {
      class: "k-actionsheet-titlebar-group k-hbox"
    }, [i("div", {
      class: "k-actionsheet-title"
    }, [i("div", {
      class: "k-text-center"
    }, [X]), i("div", {
      class: "k-actionsheet-subtitle k-text-center"
    }, [r])]), i("div", {
      class: "k-actionsheet-actions"
    }, [i(q, {
      tabIndex: 1,
      "aria-label": "Cancel",
      "aria-disabled": "false",
      type: "button",
      fillMode: "flat",
      onClick: this.onWrapperClick,
      icon: "x",
      svgIcon: _
    }, null)])]), i("div", {
      class: "k-actionsheet-titlebar-group k-actionsheet-filter"
    }, [this.$props.filterable && i(j, {
      tabIndex: 0,
      value: this.$props.filter === void 0 ? this.filterState : this.$props.filter,
      ref: m(this, "input"),
      onChange: this.onFilterChange,
      onKeydown: this.onInputKeyDown,
      size: g,
      rounded: B,
      fillMode: F,
      onFocus: this.onFocus,
      onBlur: this.onBlur
    }, null)])], le = h.call(this, ae, c.call(this)), re = () => {
      const y = this.base.getTemplateDef.call(this, S, u), E = this.base.getTemplateDef.call(this, $, u);
      return [y && i("div", {
        class: "k-list-header"
      }, [y]), s.length > 0 ? i(K, {
        ref: m(this, "treeView"),
        tabIndex: k,
        dataItems: s,
        focusIdField: n,
        textField: this.$props.textField,
        selectField: x,
        expandField: this.$props.expandField,
        childrenField: R,
        expandIcons: !0,
        onItemclick: this.onChange,
        onExpandchange: this.onExpand,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeydown: this.onWrapperKeyDown,
        size: "large",
        item: M
      }, null) : O, E && i("div", {
        class: "k-list-footer"
      }, [E])];
    }, de = h.call(this, re, c.call(this)), pe = function() {
      return i(De, {
        expand: this.isOpen,
        animation: !0,
        animationStyles: this.animationStyles,
        className: this.classNameAdaptive,
        header: le,
        content: de,
        contentClassName: "!k-overflow-hidden",
        onClose: this.onWrapperClick,
        navigatableElements: ["input.k-input-inner", ".k-actionsheet-actions > button"]
      }, null);
    }, ue = !Q || Y.valid, {
      size: g,
      rounded: B,
      fillMode: F
    } = this.$props, b = [u(function() {
      return i("span", {
        class: this.wrapperClass,
        tabindex: k,
        accesskey: this.$props.accessKey,
        id: t,
        dir: v,
        ref: m(this, "kendoAnchor"),
        onKeydown: this.onWrapperKeyDown,
        onClick: this.onWrapperClick,
        onMousedown: this.onWrapperMouseDown,
        onFocusin: this.onFocus,
        onFocusout: this.onBlur,
        role: "combobox",
        "aria-haspopup": "tree",
        "aria-expanded": this.isOpen,
        "aria-disabled": d,
        "aria-label": l || this.$props.ariaLabel,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        "aria-required": I
      }, [
        i("span", {
          class: "k-input-inner"
        }, [oe]),
        this.$props.loading && i(W, {
          class: "k-input-loading-icon",
          name: "loading"
        }, null),
        this.hasValue && !d && i("span", {
          onClick: this.onClear,
          class: "k-clear-value",
          title: D.toLanguageString(z, N[z]),
          role: "button",
          tabindex: -1,
          onMousedown: (y) => y.preventDefault()
        }, [i(W, {
          name: "x",
          icon: _
        }, null)]),
        i(q, {
          tabIndex: -1,
          type: "button",
          "aria-label": "select",
          class: "k-input-button",
          size: g,
          fillMode: F,
          themeColor: "base",
          rounded: null,
          icon: "caret-alt-down",
          svgIcon: xe
        }, null),
        /* Dummy component to support forms */
        i("select", {
          name: p,
          ref: m(this, "select"),
          tabindex: -1,
          "aria-hidden": !0,
          title: l,
          style: {
            opacity: 0,
            width: 1,
            border: 0,
            zIndex: -1,
            position: "absolute",
            left: "50%"
          }
        }, [i("option", {
          value: this.$props.valueMap ? this.$props.valueMap.call(void 0, this.computedValue) : this.computedValue
        }, null)]),
        !C && i(be, {
          style: {
            width: this.popupWidth,
            direction: v
          },
          ref: m(this, "popup"),
          class: A(o.className, {
            "k-rtl": v === "rtl"
          }),
          popupClass: A(o.popupClass, "k-dropdowntree-popup", "popup-" + this.componentGuid),
          animate: o.animate,
          anchor: this.anchor,
          show: this.isOpen,
          onOpen: this.onPopupOpened,
          onClose: this.onPopupClosed,
          appendTo: o.appendTo
        }, {
          default: () => [this.$props.filterable && i(j, {
            value: this.$props.filter === void 0 ? this.filterState : this.$props.filter,
            ref: m(this, "input"),
            onChange: this.onFilterChange,
            onKeydown: this.onInputKeyDown,
            onBlur: this.onBlur,
            size: g,
            rounded: B,
            fillMode: F
          }, null), S && i("div", {
            class: "k-list-header"
          }, [S]), s.length > 0 ? i(K, {
            ref: m(this, "treeView"),
            tabIndex: k,
            dataItems: s,
            focusIdField: n,
            textField: this.$props.textField,
            selectField: x,
            expandField: this.$props.expandField,
            childrenField: R,
            expandIcons: !0,
            onItemclick: this.onChange,
            onExpandchange: this.onExpand,
            onFocus: this.onFocus,
            onBlur: this.onBlur,
            onKeydown: this.onWrapperKeyDown,
            size: g,
            item: M
          }, null) : O, $ && i("div", {
            class: "k-list-footer"
          }, [$])]
        })
      ]);
    }.call(this), {
      ...this.$attrs
    }), C && pe.call(this)];
    return l ? i(Ve, {
      label: l,
      editorValue: this.currentValueText,
      editorPlaceholder: r,
      editorValid: ue,
      editorDisabled: d,
      editorId: t,
      focused: this.focused,
      dir: v
    }, G(b) ? b : {
      default: () => [b]
    }) : b;
  },
  methods: {
    calculateMedia(e) {
      for (let t of e)
        this.windowWidth = t.target.clientWidth;
    },
    calculatePopupWidth() {
      this.elementRef && (this.popupWidth = this.popupSettings.width !== void 0 ? this.popupSettings.width : this.elementRef.offsetWidth + "px");
    },
    focus() {
      this.$el && this.$el.focus();
    },
    setValidity() {
      if (this.selectRef && this.selectRef.setCustomValidity) {
        const {
          validationMessage: e,
          valid: t,
          required: s
        } = this.$props, n = V({
          validationMessage: e,
          valid: t,
          required: s
        }, this.hasValue);
        this.selectRef.setCustomValidity(n.valid ? "" : this.validationMessage === void 0 ? Be : this.validationMessage);
      }
    },
    openPopup(e) {
      if (!this.isOpen) {
        const t = {
          ...e
        };
        this.$emit("open", t), this.currentOpened = !0;
      }
    },
    closePopup(e) {
      if (this.isOpen) {
        const t = {
          ...e
        };
        this.$emit("close", t), this.currentOpened = !1;
      }
    },
    onWrapperClick(e) {
      if (this.onFilterChange({
        ...e,
        target: {
          value: ""
        }
      }), !e.defaultPrevented && this.$el) {
        this.focused = !0;
        const t = {
          event: e,
          target: this
        };
        (this.isOpen ? this.closePopup : this.openPopup)(t);
      }
    },
    switchFocus(e) {
      this.skipFocusRef = !0, e(), window.setTimeout(() => this.skipFocusRef = !1, 0);
    },
    onWrapperKeyDown(e) {
      const {
        keyCode: t,
        altKey: s
      } = e, n = this.treeViewRef && this.treeViewRef.$el, o = this.inputRef && this.inputRef.input;
      if (this.$props.disabled || e.defaultPrevented && o === e.target)
        return;
      const d = {
        event: e,
        target: this
      };
      if (this.isOpen)
        if (t === a.esc || s && t === a.up)
          e.preventDefault(), this.closePopup(d);
        else if (n && n.querySelector(".k-focus") && (t === a.up || t === a.down || t === a.left || t === a.right || t === a.home || t === a.end)) {
          if (t === a.up && o) {
            const r = Array.from(n.querySelectorAll(".k-treeview-item")), l = [...r].reverse().find((p) => !!(p && p.querySelector(".k-focus")));
            if (l && r.indexOf(l) === 0)
              return this.switchFocus(() => {
                this.focusElement(o);
              });
          }
          this.switchFocus(T);
        } else t === a.down && this.switchFocus(() => {
          this.focusElement(o || n);
        });
      else
        s && t === a.down && (e.preventDefault(), this.openPopup(d));
    },
    onInputKeyDown(e) {
      const {
        keyCode: t,
        altKey: s
      } = e;
      if (t === a.esc)
        this.onWrapperClick(e);
      else if (s || t !== a.up && t !== a.down)
        return;
      e.preventDefault(), this.switchFocus(t === a.up ? () => {
        this.focusElement(this.elementRef);
      } : () => {
        this.focusElement(this.treeViewRef && this.treeViewRef.$el);
      });
    },
    focusElement(e) {
      e && this.switchFocus(() => e.focus());
    },
    onPopupOpened() {
      if (!this.focused && this.isOpen && !this.currentOpened)
        this.closePopup({
          target: this
        });
      else if (this.$props.filterable) {
        const e = this.inputRef && this.inputRef.input;
        this.focusElement(e);
      } else
        this.focusElement(this.treeViewRef && this.treeViewRef.$el);
    },
    onPopupClosed() {
      this.focused && this.focusElement(this.elementRef);
    },
    onFocus(e) {
      if (!this.focused && !this.skipFocusRef) {
        this.focused = !0;
        const t = {
          event: e,
          target: this
        };
        this.$emit("focus", t);
      }
    },
    onBlur(e) {
      if (this.focused && !this.skipFocusRef) {
        this.focused = !1;
        const t = {
          event: e,
          target: this
        }, s = {
          ...t
        };
        (!e.relatedTarget || !e.relatedTarget.closest(".popup-" + this.componentGuid)) && !this.adaptiveState && (this.$emit("blur", s), this.closePopup(t));
      }
    },
    onWrapperMouseDown() {
      this.focused && this.switchFocus(T);
    },
    changeValue(e, t, s) {
      const n = {
        value: t,
        level: s ? H(s) : [],
        ...e
      };
      this.$emit("changemodel", t), this.$emit("update:modelValue", t), this.$emit("change", n), this.currentValue = t;
    },
    onChange(e) {
      if (ke(e.item, this.computedValue, this.dataItemKey) || !this.$el)
        return;
      const {
        item: t,
        itemHierarchicalIndex: s,
        event: n
      } = e, o = {
        event: n,
        target: this
      };
      this.changeValue(o, t, s), this.closePopup(o);
    },
    onClear(e) {
      const t = {
        event: e,
        target: this
      };
      this.changeValue(t, null), this.closePopup(t), e.preventDefault();
    },
    onExpand(e) {
      const {
        item: t,
        itemHierarchicalIndex: s,
        event: n
      } = e, o = {
        level: H(s),
        item: t,
        event: n,
        target: this
      };
      this.$emit("expandchange", o);
    },
    onFilterChange(e) {
      const s = {
        filter: {
          field: this.$props.textField,
          operator: "contains",
          value: e.target.value
        },
        event: e,
        target: this
      };
      this.$emit("filterchange", s), this.$props.filter === void 0 && (this.filterState = e.target.value);
    }
  }
});
export {
  Xe as DropDownTree
};
