/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { defineComponent as me, h as S, createVNode as s, isVNode as ge } from "vue";
import { Keys as a, noop as N, getTabIndex as ve, templateRendering as u, getListeners as f, getTemplate as D, getRef as g, canUseDOM as be, validatePackage as ke, guid as z, setRef as v, classNames as V, kendoThemeMaps as Se, Icon as ye } from "@progress/kendo-vue-common";
import { Popup as Fe } from "@progress/kendo-vue-popup";
import { provideLocalizationService as we } from "@progress/kendo-vue-intl";
import { TreeView as q } from "@progress/kendo-vue-treeview";
import { packageMetadata as Re } from "../package-metadata.mjs";
import { matchTags as j, areSame as xe, getItemValue as _ } from "../common/utils.mjs";
import { ListNoData as Ve } from "../DropDownTree/ListNoData.mjs";
import { nodata as G, messages as E, adaptiveModeFooterCancel as H, adaptiveModeFooterApply as U } from "../messages/main.mjs";
import { FloatingLabel as $e } from "@progress/kendo-vue-labels";
import { Button as B } from "@progress/kendo-vue-buttons";
import { TagList as Ie } from "../MultiSelect/TagList.mjs";
import { ClearButton as Te } from "../common/ClearButton.mjs";
import { ListFilter as J } from "../common/ListFilter.mjs";
import { getMultiSelectTreeValue as Ce } from "./utils.mjs";
import { MOBILE_MEDIUM_DEVICE as Me, MOBILE_SMALL_DEVICE as De } from "../common/constants.mjs";
import { ActionSheet as Ee } from "@progress/kendo-vue-layout";
import { xIcon as Be } from "@progress/kendo-svg-icons";
import Ae from "../common/DropDownBase.mjs";
function $(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !ge(e);
}
const Oe = "Please select a value from the list!", {
  sizeMap: Q,
  roundedMap: Pe
} = Se, Ke = (e) => e.split("_").map((t) => parseInt(t, 10)), X = (e, t) => {
  const {
    validationMessage: i,
    valid: n,
    required: o
  } = e;
  return {
    customError: i !== void 0,
    valid: !!(n !== void 0 ? n : !o || t),
    valueMissing: !t
  };
}, nt = /* @__PURE__ */ me({
  name: "KendoMultiSelectTree",
  model: {
    event: "changemodel"
  },
  emits: {
    open: (e) => !0,
    close: (e) => !0,
    focus: (e) => !0,
    blur: (e) => !0,
    change: (e) => !0,
    filterchange: (e) => !0,
    expandchange: (e) => !0,
    changemodel: (e) => !0,
    "update:modelValue": (e) => !0
  },
  props: {
    opened: {
      type: Boolean,
      default: void 0
    },
    disabled: Boolean,
    dir: String,
    tabIndex: Number,
    accessKey: String,
    dataItems: {
      type: Array,
      default: function() {
        return [];
      }
    },
    value: Array,
    modelValue: Array,
    valueMap: Function,
    placeholder: String,
    dataItemKey: {
      type: String,
      required: !0
    },
    textField: {
      type: String,
      required: !0
    },
    checkField: {
      type: String,
      default: "checkField"
    },
    checkIndeterminateField: {
      type: String,
      default: "checkIndeterminateField"
    },
    expandField: String,
    subItemsField: {
      type: String,
      default: "items"
    },
    className: String,
    label: String,
    validationMessage: String,
    validityStyles: {
      type: Boolean,
      default: !0
    },
    valid: {
      type: Boolean,
      default: void 0
    },
    required: Boolean,
    name: String,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    filterable: Boolean,
    filter: String,
    loading: Boolean,
    tags: Array,
    popupSettings: {
      type: Object,
      default: function() {
        return {
          animate: !0,
          height: "200px",
          anchor: ""
        };
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function(e) {
        return [null, "small", "medium", "large"].includes(e);
      }
    },
    rounded: {
      type: String,
      default: "medium",
      validator: function(e) {
        return [null, "small", "medium", "large", "full"].includes(e);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function(e) {
        return [null, "flat", "outline", "solid"].includes(e);
      }
    },
    item: [String, Function, Object],
    tag: [String, Function, Object],
    header: [String, Function, Object],
    footer: [String, Function, Object],
    listNoData: [String, Function, Object],
    adaptive: {
      type: Boolean,
      default: void 0
    },
    adaptiveTitle: {
      type: String,
      default: void 0
    }
  },
  inject: {
    kendoLocalizationService: {
      default: null
    },
    adaptiveModeBreakpoints: {
      default: {
        small: De,
        medium: Me
      }
    }
  },
  created() {
    this.observer = null, ke(Re), this.base = new Ae(this), this.componentGuid = z(), this.anchor = z();
  },
  data() {
    return {
      focusedTagState: void 0,
      openState: !1,
      focusedState: !1,
      filterState: "",
      currentValue: [],
      popupWidth: "200px",
      windowWidth: 0,
      initialAdaptiveRenderingValues: void 0
    };
  },
  computed: {
    animationStyles() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.small ? {
        top: 0,
        width: "100%",
        height: "100%"
      } : void 0;
    },
    classNameAdaptive() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.small ? "k-adaptive-actionsheet k-actionsheet-fullscreen" : "k-adaptive-actionsheet k-actionsheet-bottom";
    },
    adaptiveState() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.medium && this.$props.adaptive;
    },
    isOpen() {
      return this.opened !== void 0 ? this.opened : this.openState;
    },
    computedValue() {
      return this.value !== void 0 ? this.value : this.$props.modelValue !== void 0 ? this.$props.modelValue : this.currentValue;
    },
    hasValue() {
      return !!this.computedValue.length;
    },
    tagsToRenderRef() {
      if (this.initialAdaptiveRenderingValues === void 0)
        return this.tags === void 0 ? this.computedValue.map((e) => ({
          text: _(e, this.$props.textField),
          data: [e]
        })) : [...this.tags];
      {
        const e = this.initialAdaptiveRenderingValues;
        return e.length > 0 && e.map((t) => ({
          text: _(t, this.$props.textField),
          data: [t]
        }));
      }
    }
  },
  watch: {
    // This watch gets the state of the data when the adaptive mode is activated
    isOpen: function(e) {
      e && this.value ? this.initialAdaptiveRenderingValues = [...this.value] : this.initialAdaptiveRenderingValues = void 0;
    }
  },
  mounted() {
    this.observer = be && window.ResizeObserver && new ResizeObserver(this.calculateMedia), document != null && document.body && this.observer && this.observer.observe(document.body), this.elementRef = g(this, "kendoAnchor"), this.inputRef = g(this, "input"), this.selectRef = g(this, "select"), this.treeViewRef = g(this, "treeView"), this.skipFocusRef = !1, this.popupRef = g(this, "popup"), this.calculatePopupWidth();
  },
  updated() {
    this.inputRef = g(this, "input"), this.treeViewRef = g(this, "treeView"), this.popupRef && this.isOpen && this.hasValue && this.popupRef.reposition(), this.setValidity(), this.calculatePopupWidth();
  },
  render() {
    let e;
    const t = this.$props.id || this.componentGuid, {
      dataItems: i,
      dataItemKey: n,
      popupSettings: o = {},
      disabled: d,
      placeholder: l,
      label: r,
      name: h,
      checkField: b,
      checkIndeterminateField: F,
      subItemsField: A,
      validationMessage: Y,
      valid: Z,
      value: O,
      required: I,
      validityStyles: ee,
      adaptiveTitle: te
    } = this.$props, w = ve(this.$props.tabIndex, d), T = we(this), ie = X({
      validationMessage: Y,
      valid: Z,
      required: I
    }, this.hasValue), R = this.$props.dir, P = this.adaptiveState, K = u.call(this, this.item, f.call(this)), se = u.call(this, this.tag, f.call(this)), ae = u.call(this, this.$props.header, f.call(this)), ne = u.call(this, this.$props.footer, f.call(this)), C = D.call(this, {
      h: S,
      template: ae
    }), M = D.call(this, {
      h: S,
      template: ne
    }), oe = u.call(this, this.$props.listNoData, f.call(this)), le = s(Ve, null, $(e = T.toLanguageString(G, E[G])) ? e : {
      default: () => [e]
    }), L = D.call(this, {
      h: S,
      defaultRendering: le,
      template: oe
    }), W = !ee || ie.valid, {
      size: c,
      rounded: k,
      fillMode: y
    } = this.$props, re = () => [s("div", {
      class: "k-actionsheet-titlebar-group k-hbox"
    }, [s("div", {
      class: "k-actionsheet-title"
    }, [s("div", {
      class: "k-text-center"
    }, [te]), s("div", {
      class: "k-actionsheet-subtitle k-text-center"
    }, [l])]), s("div", {
      class: "k-actionsheet-actions"
    }, [s(B, {
      tabIndex: 5,
      "aria-label": "Cancel",
      "aria-disabled": "false",
      type: "button",
      fillMode: "flat",
      onClick: this.onCancel,
      icon: "x",
      svgIcon: Be
    }, null)])]), s("div", {
      class: "k-actionsheet-titlebar-group k-actionsheet-filter"
    }, [this.$props.filterable && s(J, {
      value: this.$props.filter === void 0 ? this.filterState : this.$props.filter,
      ref: v(this, "input"),
      onChange: this.onFilterChange,
      onKeydown: this.onInputKeyDown,
      size: c,
      rounded: k,
      fillMode: y,
      onFocus: this.onFocus,
      onBlur: this.onBlur
    }, null)])], de = u.call(this, re, f.call(this)), he = () => {
      const p = T.toLanguageString(H, E[H]), m = T.toLanguageString(U, E[U]);
      return [s(B, {
        size: "large",
        "aria-label": p,
        "aria-disabled": "false",
        type: "button",
        onClick: this.onCancel
      }, $(p) ? p : {
        default: () => [p]
      }), s(B, {
        themeColor: "primary",
        size: "large",
        "aria-label": m,
        "aria-disabled": "false",
        type: "button",
        onClick: this.closePopup
      }, $(m) ? m : {
        default: () => [m]
      })];
    }, ce = u.call(this, he, f.call(this)), pe = () => {
      const p = this.base.getTemplateDef.call(this, C, S), m = this.base.getTemplateDef.call(this, M, S);
      return [p && s("div", {
        class: "k-list-header"
      }, [p]), i.length > 0 ? s(q, {
        ref: v(this, "treeView"),
        tabIndex: w,
        dataItems: i,
        focusIdField: n,
        textField: this.$props.textField,
        checkField: b,
        checkIndeterminateField: F,
        expandField: this.$props.expandField,
        childrenField: A,
        expandIcons: !0,
        onItemclick: this.onChange,
        onCheckchange: this.onChange,
        onExpandchange: this.onExpand,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeydown: this.onWrapperKeyDown,
        checkboxes: !0,
        size: "large",
        item: K
      }, null) : L, m && s("div", {
        class: "k-list-footer"
      }, [m])];
    }, ue = u.call(this, pe, f.call(this)), fe = function() {
      return s(Ee, {
        expand: this.isOpen,
        animation: !0,
        animationStyles: this.animationStyles,
        className: this.classNameAdaptive,
        footerClassName: "k-actions k-actions-stretched",
        contentClassName: "!k-overflow-hidden",
        header: de,
        content: ue,
        footer: ce,
        onClose: this.onCancel,
        navigatableElements: ["input.k-input-inner", ".k-actionsheet-actions > button"]
      }, null);
    }, x = [S(function() {
      return s("span", {
        ref: v(this, "kendoAnchor"),
        class: V("k-multiselecttree k-input", this.$props.className, {
          [`k-input-${Q[c] || c}`]: c,
          [`k-rounded-${Pe[k] || k}`]: k,
          [`k-input-${y}`]: y,
          "k-focus": this.focusedState && !d,
          "k-invalid": !W,
          "k-disabled": d,
          "k-loading": this.$props.loading,
          "k-required": I
        }),
        tabindex: w,
        accesskey: this.$props.accessKey,
        id: t,
        dir: R,
        onKeydown: this.onWrapperKeyDown,
        onMousedown: this.onWrapperMouseDown,
        onFocusin: this.onFocus,
        onFocusout: this.onBlur,
        role: "combobox",
        "aria-haspopup": "tree",
        "aria-expanded": this.isOpen,
        "aria-disabled": d,
        "aria-label": r,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaLabelledBy ? this.$props.ariaLabelledBy : "tagslist-" + t,
        "aria-required": this.$props.required,
        onClick: this.onWrapperClick
      }, [
        this.tagsToRenderRef.length > 0 && s(Ie, {
          id: "tagslist-" + t,
          class: V("k-input-values k-chip-list k-selection-multiple", {
            [`k-chip-list-${Q[c] || c}`]: c,
            "k-readonly": this.hasValue
          }),
          tagRender: se,
          onTagdelete: this.onTagDelete,
          dataItems: this.tagsToRenderRef,
          guid: t,
          focused: this.focusedTagState ? this.tagsToRenderRef.find((p) => this.focusedTagState && j(p, this.focusedTagState, n)) : void 0,
          tagsRounded: k,
          size: c,
          fillMode: y
        }, null),
        s("span", {
          class: "k-input-inner",
          role: "combobox",
          tabindex: w,
          "aria-expanded": this.isOpen,
          "aria-describedby": "tagslist-" + t,
          "aria-label": this.$props.ariaLabelledBy
        }, [this.tagsToRenderRef.length === 0 && s("span", {
          class: "k-input-value-text"
        }, [l])]),
        this.$props.loading && s(ye, {
          class: "k-input-loading-icon",
          name: "loading"
        }, null),
        this.hasValue && !d && s(Te, {
          onClearclick: this.onClear
        }, null),
        /* Dummy component to support forms */
        s("select", {
          name: h,
          ref: v(this, "select"),
          tabindex: -1,
          "aria-hidden": !0,
          required: I,
          title: r,
          style: {
            opacity: 0,
            width: 1,
            border: 0,
            zIndex: -1,
            position: "absolute",
            left: "50%"
          }
        }, [s("option", {
          value: this.$props.valueMap ? this.$props.valueMap.call(void 0, O) : O
        }, null)]),
        !P && s(Fe, {
          style: {
            width: this.popupWidth,
            direction: R
          },
          popupClass: V(o.popupClass, "k-multiselecttree-popup", "popup-" + this.componentGuid),
          class: V(o.className, {
            "k-rtl": R === "rtl"
          }),
          animate: o.animate,
          anchor: this.anchor,
          show: this.isOpen,
          onOpen: this.onPopupOpened,
          onClose: this.onPopupClosed,
          appendTo: o.appendTo,
          ref: v(this, "popup")
        }, {
          default: () => [this.$props.filterable && s(J, {
            value: this.$props.filter === void 0 ? this.filterState : this.$props.filter,
            ref: v(this, "input"),
            onChange: this.onFilterChange,
            onKeydown: this.onInputKeyDown,
            size: c,
            rounded: k,
            fillMode: y,
            onFocus: this.onFocus,
            onBlur: this.onBlur
          }, null), C && s("div", {
            class: "k-list-header"
          }, [C]), i.length > 0 ? s(q, {
            ref: v(this, "treeView"),
            tabIndex: w,
            dataItems: i,
            focusIdField: n,
            textField: this.$props.textField,
            checkField: b,
            checkIndeterminateField: F,
            expandField: this.$props.expandField,
            childrenField: A,
            expandIcons: !0,
            onItemclick: this.onChange,
            onCheckchange: this.onChange,
            onExpandchange: this.onExpand,
            onFocus: this.onFocus,
            onBlur: this.onBlur,
            onKeydown: this.onWrapperKeyDown,
            checkboxes: !0,
            size: c,
            item: K
          }, null) : L, M && s("div", {
            class: "k-list-footer"
          }, [M])]
        })
      ]);
    }.call(this), {
      ...this.$attrs
    }), P && fe.call(this)];
    return r ? s($e, {
      label: r,
      editorValue: this.hasValue,
      editorPlaceholder: l,
      editorValid: W,
      editorDisabled: d,
      editorId: t,
      dir: R
    }, $(x) ? x : {
      default: () => [x]
    }) : x;
  },
  methods: {
    clearFilter(e) {
      this.onFilterChange(e, "");
    },
    onCancel(e) {
      const t = {
        event: e,
        target: this
      }, i = {
        items: [],
        operation: "toggle",
        value: this.initialAdaptiveRenderingValues,
        ...t
      };
      this.$emit("change", i), this.closePopup(e);
    },
    calculateMedia(e) {
      for (let t of e)
        this.windowWidth = t.target.clientWidth;
    },
    calculatePopupWidth() {
      this.elementRef && (this.popupWidth = this.popupSettings.width !== void 0 ? this.popupSettings.width : this.elementRef.offsetWidth + "px");
    },
    focus() {
      this.$el && this.$el.focus();
    },
    setValidity() {
      if (this.selectRef && this.selectRef.setCustomValidity) {
        const {
          validationMessage: e,
          valid: t,
          required: i
        } = this.$props, n = X({
          validationMessage: e,
          valid: t,
          required: i
        }, this.hasValue);
        this.selectRef.setCustomValidity(n.valid ? "" : this.validationMessage === void 0 ? Oe : this.validationMessage);
      }
    },
    changeValue(e, t, i) {
      const n = {
        dataItemKey: this.dataItemKey,
        checkField: this.checkField,
        checkIndeterminateField: this.checkIndeterminateField,
        expandField: this.expandField,
        subItemsField: this.subItemsField
      }, o = Ce(this.dataItems, {
        ...n,
        items: t,
        operation: i,
        value: this.computedValue
      }), d = {
        items: t,
        operation: i,
        value: o,
        ...e
      };
      this.$emit("changemodel", o), this.$emit("update:modelValue", o), this.$emit("change", d);
    },
    onChange(e) {
      if (xe(e.item, this.computedValue, this.dataItemKey))
        return;
      const {
        item: t,
        event: i
      } = e, n = {
        event: i,
        target: this
      };
      this.changeValue(n, [t], "toggle");
    },
    openPopup(e) {
      if (!this.isOpen) {
        const t = {
          ...e
        };
        this.$emit("open", t), this.opened === void 0 && (this.openState = !0);
      }
    },
    closePopup(e) {
      if (this.$props.filterable && this.clearFilter({
        ...e,
        target: {
          ...e.target,
          value: ""
        }
      }), this.isOpen) {
        const t = {
          ...e
        };
        this.$emit("close", t), this.opened === void 0 && (this.openState = !1);
      }
    },
    switchFocus(e) {
      this.skipFocusRef = !0, e(), window.setTimeout(() => this.skipFocusRef = !1, 0);
    },
    focusElement(e) {
      e && this.switchFocus(() => e.focus());
    },
    onPopupOpened() {
      if (!this.focusedState && this.isOpen)
        this.closePopup({
          target: this
        });
      else if (this.$props.filterable) {
        const e = this.inputRef && this.inputRef.input;
        this.focusElement(e);
      } else
        this.focusElement(this.treeViewRef && this.treeViewRef.input);
    },
    onPopupClosed() {
      this.focusedState && this.focusElement(this.elementRef);
    },
    onFocus(e) {
      if (!this.focusedState && !this.skipFocusRef) {
        this.focusedState = !0;
        const t = {
          event: e,
          target: this
        };
        this.$emit("focus", t);
      }
    },
    onBlur(e) {
      if (this.focusedState && !this.skipFocusRef && !this.adaptiveState) {
        this.focusedTagState = void 0, this.focusedState = !1;
        const t = {
          event: e,
          target: this
        }, i = {
          ...t
        };
        (!e.relatedTarget || !e.relatedTarget.closest(".popup-" + this.componentGuid)) && (this.$emit("blur", i), this.closePopup(t));
      }
    },
    onWrapperMouseDown() {
      this.focusedState && this.switchFocus(N);
    },
    onWrapperClick(e) {
      if (!this.$props.disabled && !e.defaultPrevented) {
        this.focusedState = !0;
        const t = {
          event: e,
          target: this
        };
        this.isOpen || this.openPopup(t);
      }
    },
    onWrapperKeyDown(e) {
      const {
        keyCode: t,
        altKey: i
      } = e, n = this.treeViewRef && this.treeViewRef.$el, o = this.inputRef && this.inputRef.input;
      if (this.$props.disabled || e.defaultPrevented && o === e.target)
        return;
      const d = {
        event: e,
        target: this
      };
      if (this.computedValue && this.computedValue.length > 0 && (t === a.left || t === a.right || t === a.home || t === a.end || t === a.delete || t === a.backspace)) {
        const l = this.tagsToRenderRef;
        let r = this.focusedTagState ? l.findIndex((F) => j(F, this.focusedTagState, this.dataItemKey)) : -1, h;
        const b = r !== -1;
        t === a.left ? (b ? r = Math.max(0, r - 1) : r = l.length - 1, h = l[r]) : t === a.right ? b ? (r = Math.min(l.length - 1, r + 1), h = l[r]) : h = l[0] : t === a.home ? h = l[0] : t === a.end ? h = l[l.length - 1] : (t === a.delete || t === a.backspace) && b && this.changeValue(d, l[r].data, "delete"), h !== this.focusedTagState && (this.focusedTagState = h);
      }
      if (this.isOpen)
        if (t === a.esc || i && t === a.up)
          e.preventDefault(), this.switchFocus(() => {
            this.focusElement(this.elementRef);
          }), this.closePopup(d);
        else if (n && n.querySelector(".k-focus") && (t === a.up || t === a.down || t === a.left || t === a.right || t === a.home || t === a.end)) {
          if (t === a.up) {
            const l = Array.from(n.querySelectorAll(".k-treeview-item")), r = [...l].reverse().find((h) => !!(h && h.querySelector(".k-focus")));
            if (r && l.indexOf(r) === 0)
              return this.switchFocus(() => {
                this.focusElement(o || this.elementRef);
              });
          }
          this.switchFocus(N);
        } else t === a.down && this.switchFocus(() => {
          this.focusElement(o || n);
        });
      else
        i && t === a.down && (e.preventDefault(), this.openPopup(d));
    },
    onInputKeyDown(e) {
      const {
        keyCode: t,
        altKey: i
      } = e;
      (t === a.esc || i && t === a.up) && (e.preventDefault(), this.switchFocus(() => {
        this.focusElement(this.elementRef);
      }), t === a.esc && this.adaptiveState ? this.onCancel(e) : this.closePopup(e)), !(i || t !== a.up && t !== a.down) && (e.preventDefault(), this.switchFocus(t === a.up ? () => {
        this.focusElement(this.elementRef);
      } : () => {
        this.focusElement(this.treeViewRef && this.treeViewRef.$el);
      }));
    },
    onClear(e) {
      const t = {
        event: e,
        target: this
      };
      this.changeValue(t, [], "clear"), this.closePopup(t), this.filterState = "", e.preventDefault();
    },
    onTagDelete(e, t) {
      if (this.closePopup({
        target: this
      }), !this.focusedState) {
        const i = this.inputRef && this.inputRef.input;
        this.focusElement(i);
      }
      this.changeValue({
        event: t,
        target: this
      }, e, "delete");
    },
    onExpand(e) {
      const {
        item: t,
        itemHierarchicalIndex: i,
        event: n
      } = e, o = {
        level: Ke(i),
        item: t,
        event: n,
        target: this
      };
      this.$emit("expandchange", o);
    },
    onFilterChange(e, t) {
      const i = t ? "" : e.target.value, o = {
        filter: {
          field: this.$props.textField,
          operator: "contains",
          value: i
        },
        event: e,
        target: this
      };
      this.$emit("filterchange", o), this.$props.filter === void 0 && (this.filterState = i);
    }
  }
});
export {
  nt as MultiSelectTree
};
