/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { defineComponent as xe, h as _, createVNode as o, ref as G, inject as $e, isVNode as Ce } from "vue";
import Oe from "../common/DropDownBase.mjs";
import { GroupStickyHeader as Q } from "../common/GroupStickyHeader.mjs";
import { templateRendering as $, getListeners as C, Keys as O, canUseDOM as Ve, getRef as X, guid as Z, classNames as L, kendoThemeMaps as Fe, setRef as Te, Icon as Be } from "@progress/kendo-vue-common";
import { Button as ee } from "@progress/kendo-vue-buttons";
import { isPresent as v, getItemValue as V, areSame as I, suggestValue as De, itemIndexStartsWith as te, getItemIndexByText as ie } from "../common/utils.mjs";
import { SearchBar as we } from "../common/SearchBar.mjs";
import { ListContainer as Me } from "../common/ListContainer.mjs";
import { List as Re } from "../common/List.mjs";
import { ClearButton as He } from "../common/ClearButton.mjs";
import { provideLocalizationService as Le } from "@progress/kendo-vue-intl";
import { expandButton as se, messages as je } from "../messages/main.mjs";
import { xIcon as Ee, caretAltDownIcon as Ne } from "@progress/kendo-svg-icons";
import { MOBILE_MEDIUM_DEVICE as Ae, MOBILE_SMALL_DEVICE as Pe } from "../common/constants.mjs";
import { ActionSheet as Ke } from "@progress/kendo-vue-layout";
import { ListFilter as ze } from "../common/ListFilter.mjs";
const {
  sizeMap: W,
  roundedMap: _e
} = Fe;
function Ge(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Ce(e);
}
const We = "Please enter a valid value!", ut = /* @__PURE__ */ xe({
  name: "KendoComboBox",
  model: {
    event: "changemodel"
  },
  emits: {
    changemodel: (e) => !0,
    "update:modelValue": (e) => !0,
    filterchange: (e) => !0,
    pagechange: (e) => !0,
    change: (e) => !0,
    focus: (e) => !0,
    blur: (e) => !0,
    open: (e) => !0,
    close: (e) => !0,
    scroll: (e) => !0
  },
  props: {
    id: String,
    dataItemKey: {
      type: [Object, String]
    },
    defaultValue: {
      type: [String, Object, Number, Boolean],
      default: void 0
    },
    name: String,
    modelValue: {
      type: [String, Object, Number, Boolean],
      default: void 0
    },
    value: {
      type: [String, Object, Number, Boolean],
      default: void 0
    },
    label: {
      type: String
    },
    placeholder: String,
    required: {
      type: Boolean,
      default: !1
    },
    valid: {
      type: Boolean,
      default: void 0
    },
    validationMessage: {
      type: String,
      default: void 0
    },
    validityStyles: {
      type: Boolean,
      default: !0
    },
    iconClassName: String,
    opened: {
      type: Boolean,
      default: void 0
    },
    disabled: Boolean,
    dir: {
      type: String,
      default: void 0
    },
    tabIndex: {
      type: Number,
      default: 0
    },
    accessKey: String,
    dataItems: Array,
    textField: String,
    className: String,
    loading: Boolean,
    popupSettings: {
      type: Object,
      default: function() {
        return {
          animate: !0,
          height: "200px",
          anchor: ""
        };
      }
    },
    itemRender: [String, Function, Object],
    groupHeaderItemRender: [String, Function, Object],
    groupStickyHeaderItemRender: [String, Function, Object],
    listNoDataRender: [String, Function, Object],
    focusedItemIndex: Function,
    header: [String, Function, Object],
    footer: [String, Function, Object],
    filterable: Boolean,
    filter: {
      type: String,
      default: void 0
    },
    virtual: {
      type: Object,
      default: void 0
    },
    suggest: {
      type: Boolean,
      default: !1
    },
    allowCustom: {
      type: Boolean,
      default: !1
    },
    clearButton: {
      type: Boolean,
      default: !0
    },
    ariaLabel: {
      type: String,
      default: void 0
    },
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    valueField: String,
    valuePrimitive: Boolean,
    rounded: {
      type: String,
      default: "medium",
      validator: function(e) {
        return ["small", "medium", "large", "full"].includes(e);
      }
    },
    fillMode: {
      type: String,
      default: "solid",
      validator: function(e) {
        return ["solid", "flat", "outline"].includes(e);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function(e) {
        return ["small", "medium", "large"].includes(e);
      }
    },
    groupField: {
      type: String
    },
    adaptive: {
      type: Boolean,
      default: void 0
    },
    adaptiveTitle: {
      type: String,
      default: void 0
    },
    onFilterchange: Function,
    inputAttributes: Object
  },
  inject: {
    kendoLocalizationService: {
      default: null
    },
    adaptiveModeBreakpoints: {
      default: {
        small: Pe,
        medium: Ae
      }
    }
  },
  data() {
    return {
      hasMounted: !1,
      currentText: "",
      currentValue: "",
      currentFocused: !1,
      currentOpened: !1,
      searchState: {
        word: "",
        last: ""
      },
      _skipFocusEvent: !1,
      valueDuringOnChange: {},
      _navigated: !1,
      suggested: "",
      group: void 0,
      isScrolling: !1,
      itemHeight: 0,
      state: void 0,
      popupWidth: void 0,
      windowWidth: 0
    };
  },
  created() {
    this.observer = null, this.valueDuringOnChange = void 0, this.currentText = void 0, this.currentValue = void 0, this.currentFocused = void 0, this.currentOpened = void 0, this.prevCurrentValue = this.computedValue(), this.base = new Oe(this), this.anchor = Z(), this.inputId = Z();
  },
  setup() {
    const e = G(null), t = G(null), i = G(null), s = $e("kendoLocalizationService", {});
    return {
      inputRef: e,
      elementRef: t,
      kendoAnchorRef: i,
      kendoLocalizationService: s
    };
  },
  mounted() {
    this.observer = Ve && window.ResizeObserver && new ResizeObserver(this.calculateMedia), document != null && document.body && this.observer && this.observer.observe(document.body), this.hasMounted = !0, this.input = this.inputRef.input, this.base.wrapper = X(this, "kendoAnchor"), this.element = X(this, "kendoAnchor"), this.base.didMount(), this.setValidity();
  },
  updated() {
    var f;
    const {
      dataItems: e = [],
      dataItemKey: t,
      virtual: i,
      groupField: s,
      textField: a
    } = this.$props, l = this.isOpen, n = this.prevOpened !== void 0 ? this.prevOpened : this.prevCurrentOpened, r = !n && l, u = this.$refs.list, g = this.$refs.scrollElement, d = this.computedValue();
    if (this.valueOnDidUpdate = d, u && (this.base.vs.list = u.list, this.base.list = u.list), g && (this.base.vs.scrollElement = g), u && e.length && this.base.vs.scrollerRef(u.$el), i && this.virtualTotalHasChanged)
      this.base.vs.calcScrollElementHeight(), this.base.vs.reset(), this.virtualTotalHasChanged = !1;
    else {
      const m = this.prevCurrentValue;
      let y = e.findIndex((F) => I(F, d, t));
      s && (y = (f = this.base.getGroupedDataModernMode(e, s)) == null ? void 0 : f.indexOf(d));
      const D = !I(m, d, t);
      if (r && i)
        this.base.scrollToVirtualItem(i, y), this.prevCurrentOpened = !0;
      else if (r && !i)
        e && e.length !== 0 && this.base.resetGroupStickyHeader(e[0][s], this), this.base.scrollToItem(y), this.prevCurrentOpened = !0;
      else if (l && n && d && D)
        this.base.scrollToItem(y);
      else if (l && !d && !this.isScrolling) {
        let F = 0;
        if (s && this.getFocusedIndex() !== -1 && e.length > 0) {
          const T = e[this.getFocusedIndex()][a], w = this.base.getGroupedDataModernMode(e, s), A = w.findIndex((k) => k[a] === T);
          F = w.slice(0, A).filter((k) => Object.keys(k).length === 1).length;
        }
        this.base.scrollToItem(this.getFocusedIndex() + F);
      }
    }
    r && this.input && this.input.focus(), this.prevCurrentValue = this.computedValue(), this.setValidity();
  },
  watch: {
    currentOpened: function(e, t) {
      this.prevCurrentOpened = t;
    },
    opened: function(e, t) {
      this.prevOpened = t;
    },
    virtual: function(e, t) {
      e && t && e.total !== t.total && (this.virtualTotalHasChanged = !0), this.virtualHasChanged = !0;
    },
    isOpen: function() {
      setTimeout(() => {
        const e = document.querySelector(".k-list-item");
        this.itemHeight = this.base.getListItemHeight(e);
      }, 100);
    }
  },
  computed: {
    index() {
      const {
        dataItems: e = [],
        dataItemKey: t
      } = this.$props, i = this.computedValue();
      return e.findIndex((s) => I(s, i, t));
    },
    spanClassNames() {
      const e = !this.hasMounted || !this.$props.validityStyles || this.validity().valid;
      return {
        "k-floating-label-container": !0,
        "k-focus": this.currentFocused,
        "k-empty": !this.computedValue(),
        "k-invalid": !e && e !== void 0,
        "k-rtl": this.$props.dir === "rtl"
      };
    },
    isOpen() {
      return this.$props.opened !== void 0 ? this.$props.opened : this.currentOpened;
    },
    animationStyles() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.small ? {
        top: 0,
        width: "100%",
        height: "100%"
      } : void 0;
    },
    classNameAdaptive() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.small ? "k-adaptive-actionsheet k-actionsheet-fullscreen" : "k-adaptive-actionsheet k-actionsheet-bottom";
    },
    adaptiveState() {
      return this.windowWidth <= this.adaptiveModeBreakpoints.medium && this.$props.adaptive;
    }
  },
  methods: {
    focus() {
      this.input && this.input.focus();
    },
    computedValue() {
      let e;
      return this.valueDuringOnChange !== void 0 ? e = this.valueDuringOnChange : this.$props.value !== void 0 ? e = this.$props.value : this.$props.modelValue !== void 0 ? e = this.$props.modelValue : this.currentValue !== void 0 ? e = this.currentValue : this.$props.defaultValue !== void 0 && (e = this.$props.defaultValue), this.valuePrimitive && this.findByFieldValue(this.valueField, e) || e;
    },
    findByFieldValue(e, t) {
      const i = this.dataItems.findIndex((s) => V(s, e) === t);
      return this.dataItems[i];
    },
    primitiveValue() {
      const e = this.computedValue();
      return this.valuePrimitive && e && typeof e == "object" ? V(e, this.valueField) : e;
    },
    validity() {
      const e = this.$props.validationMessage !== void 0, t = !this.$props.required || this.computedValue() !== null && this.computedValue() !== "" && this.computedValue() !== void 0, i = this.$props.valid !== void 0 ? this.$props.valid : t;
      return {
        customError: e,
        valid: i,
        valueMissing: this.computedValue() === null
      };
    },
    handleItemSelect(e, t) {
      const {
        dataItems: i = [],
        virtual: s,
        dataItemKey: a
      } = this.$props, l = s ? s.skip : 0, n = i[e - l], r = !I(n, this.computedValue(), a);
      this.triggerOnChange(n, t), this.currentText !== void 0 && (t.data.currentText = void 0), r && this.base.triggerPageChangeCornerItems(n, t);
    },
    onNavigate(e, t) {
      const {
        dataItems: i = [],
        virtual: s = {
          skip: 0
        }
      } = this.$props, a = this.$props.filter ? this.$props.filter : this.currentText, l = this.getFocusedIndex(), n = this.base.vs, r = this.computedValue();
      if (this.suggested = "", l !== -1 && !v(r))
        this.handleItemSelect(l, e);
      else if (a === "")
        this.handleItemSelect(0, e);
      else {
        let u = s.skip + l;
        const g = this.base.navigation.navigate({
          keyCode: t,
          current: u,
          max: (n.enabled ? n.total : i.length) - 1,
          min: 0
        });
        g !== void 0 && this.handleItemSelect(g, e);
      }
    },
    toggleBtnClick(e) {
      const t = this.base.initState(), i = this.isOpen, s = this.adaptiveState;
      t.event = e, this.base.togglePopup(t), !i && s && this.base.filterChanged("", t), this.applyState(t);
    },
    applyValueOnEnter(e, t) {
      const {
        dataItems: i = [],
        textField: s,
        allowCustom: a,
        valuePrimitive: l
      } = this.$props, n = this.isOpen, u = this.getSelectedItemText() === e ? this.index : ie(i, e, s), g = u !== -1;
      let d;
      if (this.suggested = "", g)
        d = i[u];
      else if (a)
        d = s !== void 0 && !l ? {
          [s]: e
        } : e;
      else
        return this.selectFocusedItem(e, t);
      this.triggerOnChange(d, t), n && this.base.togglePopup(t), this.$props.filter === void 0 && this.currentText !== void 0 && (t.data.currentText = void 0), this.applyState(t);
    },
    applyValueOnRejectSuggestions(e, t) {
      const {
        dataItems: i = [],
        textField: s,
        allowCustom: a,
        valuePrimitive: l
      } = this.$props, n = this.isOpen, r = this.getSelectedItemText();
      if (this.suggested = "", e === r || e === "" && !v(r))
        return n && !this.adaptiveState && this.base.togglePopup(t), this.applyState(t);
      const u = ie(i, e, s, !0), g = u !== -1;
      let d = null;
      g ? d = i[u] : a && e && (s && !l ? d = {
        [s]: e
      } : d = e), this.triggerOnChange(d, t), this.currentText !== void 0 && (t.data.currentText = void 0, this.base.filterChanged("", t)), n && !this.adaptiveState && this.base.togglePopup(t), this.applyState(t);
    },
    selectFocusedItem(e, t) {
      const i = this.isOpen, {
        dataItems: s = [],
        textField: a,
        virtual: l = {
          skip: 0
        },
        focusedItemIndex: n = te
      } = this.$props, r = l.skip, u = e === "" && r === 0 ? 0 : n(s, e, a);
      return u !== -1 ? this.handleItemSelect(u + r, t) : (this.triggerOnChange(null, t), this.currentText !== void 0 && (t.data.currentText = void 0)), i && this.base.togglePopup(t), this.applyState(t);
    },
    handleItemClick(e, t) {
      this.base.handleItemClick(e, t), this.valueDuringOnChange = void 0;
    },
    handleFocus(e) {
      this.$emit("focus", e);
    },
    handleBlur(e) {
      if (this.currentFocused) {
        const t = this.base.initState();
        t.data.currentFocused = !1, t.events.push({
          type: "blur"
        }), t.event = e, this.applyValueOnRejectSuggestions(e.currentTarget.value, t);
      }
    },
    onInputKeyDown(e) {
      this.isScrolling && (this.isScrolling = !1);
      const t = e.keyCode, i = this.isOpen, s = this.base.initState();
      if (s.event = e, !e.altKey && (t === O.up || t === O.down)) {
        e.preventDefault(), this.onNavigate(s, t), this.applyState(s);
        return;
      }
      const a = () => {
        e.preventDefault(), this.base.togglePopup(s), this.applyState(s);
      };
      i ? e.altKey && t === O.up ? a() : t === O.enter ? (e.preventDefault(), this.applyValueOnEnter(e.currentTarget.value, s)) : t === O.esc && (this.adaptiveState && this.toggleBtnClick(e), a()) : e.altKey && t === O.down ? a() : t === O.esc && this.applyValueOnRejectSuggestions(e.currentTarget.value, s);
    },
    inputOnChange(e) {
      const t = this.base.initState();
      t.event = e;
      const i = this.isOpen, s = e.currentTarget, a = s.value;
      if (this.$props.suggest) {
        const l = s.selectionEnd === a.length;
        let n = this.$props.filter !== void 0 ? this.$props.filter : this.currentText;
        v(n) || (n = V(this.computedValue(), this.$props.textField) || "");
        const r = n && n === a, u = n && n.length > a.length;
        r || u || !l ? this.suggested = "" : this.suggestValue(a);
      }
      this.$props.filter === void 0 && (t.data.currentText = a), this.currentFocusedItem !== void 0 && (t.data.focusedItem = void 0), i || this.base.togglePopup(t), this.base.filterChanged(a, t), this.$props.filterable && (t.data.group = void 0), this.applyState(t);
    },
    clearButtonClick(e) {
      const t = this.base.initState();
      t.event = e, e.stopPropagation(), this.suggested = "", this.base.filterChanged("", t), this.$props.filter === void 0 && this.currentText !== void 0 && (t.data.currentText = void 0), this.triggerOnChange(null, t), this.isOpen && this.base.togglePopup(t), this.applyState(t);
    },
    getFocusedIndex() {
      const e = this.computedValue(), {
        dataItems: t = [],
        textField: i,
        dataItemKey: s,
        virtual: a = {
          skip: 0
        },
        focusedItemIndex: l = te
      } = this.$props, n = this.$props.filter ? this.$props.filter : this.currentText;
      return v(e) && n === void 0 ? t.findIndex((r) => I(r, e, s)) : n ? l(t, n, i) : a.skip === 0 ? 0 : -1;
    },
    suggestValue(e) {
      const {
        dataItems: t,
        textField: i
      } = this.$props;
      this.suggested = De(e, t, i);
    },
    setValidity() {
      this.input && this.input.setCustomValidity && this.input.setCustomValidity(this.validity().valid ? "" : this.$props.validationMessage || We);
    },
    compareValues(e, t) {
      return this.$props.valuePrimitive && (typeof e != "object" || e === null) && (typeof t != "object" || t === null) ? e === t : I(e, t, this.$props.dataItemKey);
    },
    triggerOnChange(e, t) {
      const i = this.computedValue();
      !v(i) && !v(e) || this.compareValues(i, e) || (this.$props.value === void 0 && (this.currentValue = e), this.valueDuringOnChange = e, t.events.push({
        type: "change"
      }));
    },
    applyState(e) {
      this.base.applyState(e), this.valueDuringOnChange = void 0;
    },
    calculateMedia(e) {
      for (let t of e)
        this.windowWidth = t.target.clientWidth;
    },
    repositionPopup() {
      this.base.repositionPopup();
    },
    onScroll(e) {
      this.isScrolling = !0;
      const {
        vs: t,
        list: i
      } = this.base;
      t.scrollHandler(e);
      const s = this.base.initState(), {
        groupField: a
      } = this.$props;
      let {
        dataItems: l = []
      } = this.$props, n;
      if (!a || !l.length)
        return;
      const r = this.itemHeight = this.itemHeight || (t.enabled ? t.itemHeight : i ? i.children[0].offsetHeight : 0), g = e.target.scrollTop - t.skip * r;
      a && (l = this.base.getGroupedDataModernMode(l, a), n = l[0][a]);
      for (let d = 1; d < l.length && !(r * d > g); d++)
        l[d] && l[d][a] && (n = l[d][a]);
      n !== this.group && (s.data.group = n, this.applyState(s));
    },
    getInputText(e, t) {
      return v(e) && e !== "" ? String(e) : v(t) ? String(t) : "";
    },
    getSelectedItemText() {
      const {
        textField: e,
        valuePrimitive: t
      } = this.$props, i = this.computedValue();
      if (v(i))
        return t ? i && typeof i == "object" ? V(i, e) : typeof i == "string" ? i !== "" ? i : void 0 : typeof i == "number" || typeof i == "boolean" ? String(i) : void 0 : V(i, e);
    }
  },
  render() {
    let {
      dir: e,
      disabled: t,
      clearButton: i,
      label: s,
      textField: a,
      className: l,
      style: n,
      loading: r,
      icon: u,
      svgIcon: g,
      iconClassName: d,
      virtual: f,
      size: m,
      fillMode: y,
      rounded: D,
      adaptiveTitle: F,
      header: T,
      footer: w,
      groupStickyHeaderItemRender: A,
      placeholder: k,
      inputAttributes: ne
    } = this.$props;
    const ae = this.currentFocused, le = !this.$props.validityStyles || this.validity().valid, P = this.$props.filter !== void 0 ? this.$props.filter : this.currentText, q = this.getSelectedItemText(), U = this.getInputText(P, q), j = this.computedValue(), oe = this.$props.valuePrimitive ? !!this.findByFieldValue(this.valueField, j) || this.$props.allowCustom && v(j) && j !== "" : v(j), re = i && (!!U || oe), x = this.base, S = x.vs, K = this.$props.id || this.inputId, E = Object.assign({}, {
      animate: !0,
      height: "200px"
    }, this.$props.popupSettings), de = Le(this).toLanguageString(se, je[se]), M = this.isOpen, R = this.adaptiveState;
    S.enabled = f !== void 0, f !== void 0 && (S.skip = f.skip, S.total = f.total, S.pageSize = f.pageSize), this.group === void 0 && this.$props.groupField !== void 0 && (this.group = V(this.$props.dataItems[0], this.$props.groupField));
    const ue = (p) => {
      const c = this.base.initState();
      c.event = p;
      const h = p.event.target.value;
      c.data.text = h, this.base.filterChanged(h, c), this.applyState(c);
    }, pe = () => [o("div", {
      class: "k-actionsheet-titlebar-group k-hbox"
    }, [o("div", {
      class: "k-actionsheet-title"
    }, [o("div", {
      class: "k-text-center"
    }, [F]), k && o("div", {
      class: "k-actionsheet-subtitle k-text-center"
    }, [k])]), o("div", {
      class: "k-actionsheet-actions"
    }, [o(ee, {
      tabIndex: 5,
      "aria-label": "Cancel",
      "aria-disabled": "false",
      type: "button",
      fillMode: "flat",
      onClick: this.toggleBtnClick,
      icon: "x",
      svgIcon: Ee
    }, null)])]), o("div", {
      class: "k-actionsheet-titlebar-group k-actionsheet-filter"
    }, [me.call(this)])], ce = $.call(this, pe, C.call(this)), he = () => {
      const p = x.getTemplateDef.call(this, T, _), c = x.getTemplateDef.call(this, w, _), h = $.call(this, A, C.call(this)), b = this.$props.dataItems || [];
      return o("div", {
        class: "k-list-container"
      }, [p && o("div", {
        class: "k-list-header"
      }, [p]), o("div", {
        class: L("k-list", {
          [`k-list-${W[m] || m}`]: R ? !1 : m,
          "k-list-lg": !!R,
          "k-virtual-list": S.enabled
        })
      }, [T && o("div", {
        class: "k-list-header"
      }, [T]), this.group && b.length !== 0 && o(Q, {
        group: this.group,
        render: h
      }, null), Y.call(this), c && o("div", {
        class: "k-list-footer"
      }, [c])])]);
    }, fe = $.call(this, he, C.call(this)), ge = function() {
      return o(Ke, {
        expand: M,
        animation: !0,
        animationStyles: this.animationStyles,
        className: this.classNameAdaptive,
        contentClassName: "!k-overflow-hidden",
        header: ce,
        content: fe,
        onClose: this.toggleBtnClick,
        navigatableElements: ["input.k-input-inner", ".k-actionsheet-actions > button"]
      }, null);
    }, me = function() {
      const c = this.base.initState().data.text;
      return o(ze, {
        adaptiveMode: !0,
        value: c,
        ref: "filterInput",
        onChange: (h) => ue(h),
        onKeydown: this.onInputKeyDown,
        size: this.$props.size,
        rounded: this.$props.rounded,
        fillMode: this.$props.fillMode
      }, null);
    }, Y = function() {
      let p;
      const {
        dataItemKey: c,
        groupField: h
      } = this.$props;
      let b = this.$props.dataItems || [];
      const B = $.call(this, this.$props.itemRender, C.call(this)), N = $.call(this, this.$props.groupHeaderItemRender, C.call(this)), z = $.call(this, this.$props.listNoDataRender, C.call(this));
      f || (f = {
        skip: 0
      });
      const H = f.skip, Se = `translateY(${S.translate}px)`, Ie = M ? this.getFocusedIndex() : void 0, ke = v(P) && P !== q ? null : this.computedValue();
      return h && (b = this.base.getGroupedDataModernMode(b, h)), o(Re, {
        id: x.listBoxId,
        show: M,
        dataItems: b,
        focusedIndex: Ie,
        value: ke,
        textField: a,
        valueField: c,
        optionsGuid: x.guid,
        ref: "list",
        wrapperStyle: {
          maxHeight: R ? void 0 : E.height
        },
        wrapperCssClass: L("k-list-content", {
          "k-list-scroller": !this.$props.virtual
        }),
        listStyle: S.enabled ? {
          transform: Se
        } : void 0,
        key: "listkey",
        skip: H,
        onListclick: this.handleItemClick,
        itemRender: B,
        groupHeaderItemRender: N,
        noDataRender: z,
        groupField: h,
        onScroll: this.onScroll
      }, Ge(p = ve.call(this)) ? p : {
        default: () => [p]
      });
    }, ve = function() {
      return S.enabled && o("div", {
        ref: "scrollElement",
        key: "scrollElementKey"
      }, null);
    }, be = function() {
      const p = $.call(this, this.$props.groupStickyHeaderItemRender, C.call(this)), c = x.getTemplateDef.call(this, T), h = x.getTemplateDef.call(this, w), b = this.$props.dataItems || [];
      return this.group === void 0 && this.$props.groupField !== void 0 && (this.group = V(b[0], this.$props.groupField)), o(Me, {
        ref: "container",
        onMousedown: (B) => B.preventDefault(),
        width: this.popupWidth,
        popupSettings: {
          ...E,
          anchor: this.anchor,
          show: M,
          popupClass: L(E.popupClass, "k-list", {
            [`k-list-${W[m] || m}`]: m,
            "k-virtual-list": this.base.vs.enabled
          }),
          className: L("k-list-container", E.className)
        },
        dir: e !== void 0 ? e : this.base.dirCalculated
      }, {
        default: () => [c && o("div", {
          class: "k-list-header"
        }, [c]), this.group && b.length !== 0 && o(Q, {
          group: this.group,
          render: p
        }, null), Y.call(this), h && o("div", {
          class: "k-list-footer"
        }, [h])]
      });
    }, ye = function(p, c) {
      const {
        tabIndex: h,
        dataItems: b = [],
        dataItemKey: B
      } = this.$props;
      f || (f = {
        skip: 0
      });
      const N = this.computedValue(), z = Math.max(0, b.findIndex((H) => I(H, N, B)));
      return this.suggested && !I(this.valueOnDidUpdate, N, B) && (this.suggested = ""), o(we, {
        id: c,
        placeholder: k,
        tabIndex: h || void 0,
        accessKey: this.$props.accessKey,
        value: p + this.suggested,
        suggestedText: this.suggested,
        ref: (H) => {
          this.inputRef = H;
        },
        onKeydown: this.onInputKeyDown,
        onChange: this.inputOnChange,
        onFocus: this.base.handleFocus,
        onBlur: this.handleBlur,
        disabled: t,
        expanded: M,
        owns: this.base.listBoxId,
        activedescendant: this.base.guid + "-" + (z + f.skip),
        ariaLabelledBy: this.$props.ariaLabelledBy,
        ariaDescribedBy: this.$props.ariaDescribedBy,
        ariaLabel: this.$props.ariaLabel,
        inputAttributes: ne
      }, null);
    }, J = [_(function() {
      return o("span", {
        class: L("k-combobox k-input", {
          [`k-input-${W[m] || m}`]: m,
          [`k-rounded-${_e[D] || D}`]: D,
          [`k-input-${y}`]: y,
          "k-invalid": !le,
          "k-loading": r,
          "k-required": this.required,
          "k-disabled": t,
          "k-focus": ae && !t
        }, l),
        ref: Te(this, "kendoAnchor"),
        style: s ? {
          ...n,
          width: void 0
        } : n,
        dir: e
      }, [ye.call(this, U || "", K), re && !r && o(He, {
        onClearclick: this.clearButtonClick,
        key: "clearbutton"
      }, null), r && o(Be, {
        name: "loading",
        class: "k-input-loading-icon",
        key: "loading"
      }, null), o(ee, {
        type: "button",
        tabIndex: -1,
        "aria-label": de,
        size: m,
        fillMode: y,
        rounded: null,
        class: "k-input-button",
        icon: u || "caret-alt-down",
        svgIcon: g || Ne,
        iconClass: d,
        onClick: this.toggleBtnClick,
        onMousedown: (p) => p.preventDefault()
      }, null), !R && be.call(this)]);
    }.call(this), {
      ...this.$attrs
    }), R && ge.call(this)];
    return s ? o("span", {
      class: this.spanClassNames,
      onFocusin: this.handleFocus,
      dir: this.$props.dir
    }, [J, this.$props.label ? K ? o("label", {
      for: K,
      class: "k-floating-label"
    }, [this.$props.label]) : o("span", {
      class: "k-label"
    }, [this.$props.label]) : null]) : J;
  }
});
export {
  ut as ComboBox
};
