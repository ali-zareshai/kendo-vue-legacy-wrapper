/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright © 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const Q = 11111111111111e-7, ae = 0.31111111111111117, de = 1, Y = 1, w = 0, m = /\d/, ee = 15, Ne = (t, n) => t !== void 0 ? t : n, p = (t, n, r) => t === null && t === void 0 ? "" : typeof t == "string" ? t : r.formatNumber(t, n), H = (t) => (String(t).split(".")[1] || "").length, ne = (t, n) => Math.max(H(t), H(n)), ge = (t) => Math.min(t, ee), te = (t, n) => {
  const r = ge(n);
  return parseFloat(t.toFixed(r));
}, Ie = (t, n, r, e, u, o, a) => {
  const s = ne(t || 0, r || 0), i = re(te((t || 0) + (r || 0), s), e, u);
  n.eventValue = i, n.currentLooseValue = p(i, o, a), n.selectionStart = n.selectionEnd = R(n.currentLooseValue, m);
}, Ce = (t, n, r, e, u, o, a) => {
  const s = ne(t || 0, r || 0), i = re(te((t || 0) - (r || 0), s), e, u);
  n.eventValue = i, n.currentLooseValue = p(i, o, a), n.selectionStart = n.selectionEnd = R(n.currentLooseValue, m);
}, re = (t, n, r) => t == null ? t : !(t > 1 || t < 1 || t === 1) || r !== void 0 && n !== void 0 && r < n ? null : (r !== void 0 && t > r && (t = r), n !== void 0 && t < n && (t = n), t), fe = (t, n) => {
  const r = n.findIndex(([u, o]) => !!o && t.indexOf(o) === t.length - o.length);
  if (r === -1)
    return -1;
  const e = n[r][1];
  return t.length - e.length;
}, me = (t, n) => {
  const r = n.findIndex(([u, o]) => !!u && t.indexOf(u) === 0);
  return r === -1 ? -1 : n[r][0].length;
}, Ve = (t, n, r) => {
  const e = fe(t, n);
  if (e !== -1 && r.selectionStart > e) {
    r.selectionStart = r.selectionEnd = e;
    return;
  }
  r.selectionStart > t.length && (r.selectionStart = r.selectionEnd = t.length);
  const u = me(t, n);
  u !== -1 && r.selectionStart < u && (r.selectionStart = r.selectionEnd = u), r.selectionStart === -1 && (r.selectionStart = r.selectionEnd = 0);
}, b = (t, n, r, e) => {
  t.selectionStart = t.selectionEnd = n, Ve(r, e, t);
}, A = (t, n, r, e) => {
  t.eventValue = e.parseNumber(t.prevLooseValue, n), t.currentLooseValue = t.prevLooseValue, t.valueIsCorrected = !0, b(t, t.selectionStart, t.currentLooseValue, r);
}, _ = (t, n, r) => n.split(t).length !== r.split(t).length && n.length === r.length + t.length, pe = (t, n) => {
  const r = String(t.currentLooseValue), e = String(t.prevLooseValue);
  return _(n.minusSign, r, e) || _("-", r, e) || _("−", r, e);
}, xe = (t, n) => {
  const r = String(t.currentLooseValue), e = String(t.prevLooseValue);
  return r.indexOf(n.minusSign) === -1 && e.indexOf(n.minusSign) !== -1;
}, be = (t, n) => String(t.currentLooseValue).split(n.decimal).length > 2, he = (t, n) => {
  const r = n.formatNumber(Q, t), e = n.formatNumber(-11111111111111e-7, t), u = n.formatNumber(w, t), o = n.formatNumber(Y, t), a = O(r), s = O(e), i = O(u), l = O(o), I = P(r), C = P(e), x = P(u), h = P(o);
  return {
    positiveInfo: [a, I],
    negativeInfo: [s, C],
    zeroInfo: [i, x],
    oneInfo: [l, h]
  };
}, Le = (t, n) => {
  const r = n.formatNumber(Q, t), e = n.formatNumber(-11111111111111e-7, t), u = n.formatNumber(w, t), o = n.formatNumber(Y, t), a = n.numberSymbols(), s = new RegExp(`[\\d\\${a.decimal}${a.group}]`, "g");
  return [r, e, u, o].map((l) => l.replace(s, "")).join("").split("").filter((l, I, C) => C.indexOf(l) === I).join("");
}, B = (t, n) => {
  const r = t.indexOf(n.decimal);
  return r > -1 ? r : R(t, m);
}, T = (t) => t.split("").reverse().join(""), R = (t, n) => t.length - T(t).search(n), O = (t) => t.split(t[t.search(m)])[0], P = (t) => {
  const n = T(t);
  return T(n.split(n[n.search(m)])[0]);
}, $ = (t, n) => t.search(n), J = (t, n) => {
  const r = t.indexOf(n);
  return r > -1 ? t.length - r - 1 : 0;
}, K = (t, n, r, e, u) => {
  const o = t.replace(u, "")[0] === "0", a = n.replace(u, "")[0] === "0";
  if (o && !a)
    return r - 1;
  if (a && e)
    return r + 1;
  let s = 0;
  for (let l = 0; l < r; l++)
    m.test(t.charAt(l)) && s++;
  let i = 0;
  for (; s > 0 && n.length > i; )
    m.test(n.charAt(i)) && s--, i++;
  return i;
}, Ee = (t, n, r) => {
  const e = {
    ...t
  }, {
    prevLooseValue: u
  } = e, o = r.numberSymbols(), a = Le(n, r), s = String(e.currentLooseValue), i = String(u), l = new RegExp(`[^\\d\\${o.decimal}]`, "g"), I = new RegExp(`[^\\d\\${o.decimal}\\${o.group}]`, "g"), C = new RegExp(`[\\d\\${o.decimal}\\${o.group}]`), x = s.replace(l, ""), h = $(s, m), E = h === -1 ? -1 : R(s, m), oe = s.indexOf(o.decimal), G = (s.substring(0, h) + s.substring(h, E).replace(I, "") + s.substring(E, s.length)).split("").filter((V) => a.indexOf(V) !== -1 || V.search(C) !== -1).join(""), U = r.formatNumber(ae, n).replace(l, ""), j = U.indexOf(o.decimal), N = j > -1 ? U.length - j - 1 : 0, v = r.formatNumber(de, n).replace(l, ""), X = v.indexOf(o.decimal), D = X > -1 ? v.length - X - 1 : 0, {
    positiveInfo: se,
    negativeInfo: ue,
    zeroInfo: ce,
    oneInfo: ie
  } = he(n, r), g = [se, ue, ce, ie], le = g.findIndex((V) => V.findIndex((L) => !!L) !== -1) !== 1, M = s.length > 0 && s.length < i.length, Z = typeof n == "string" && n[0] === "p" && s && s.indexOf(o.percentSign) === -1;
  if (!e.isPaste) {
    if (s === "")
      return e.eventValue = null, e.currentLooseValue = "", e;
    if (e.currentLooseValue === o.minusSign && r.formatNumber(-0, n) !== i)
      return e.eventValue = -0, e.currentLooseValue = p(e.eventValue, n, r), b(e, B(e.currentLooseValue, o), e.currentLooseValue, g), e;
    if (e.currentLooseValue === o.decimal) {
      e.eventValue = 0;
      const f = p(e.eventValue, n, r);
      if (D === 0 && N > 0) {
        const c = R(f, m);
        e.currentLooseValue = f.substring(0, c) + o.decimal + f.substring(c);
      } else
        e.currentLooseValue = f;
      return b(e, B(e.currentLooseValue, o) + 1, e.currentLooseValue, g), e;
    }
    if (pe(e, o)) {
      const f = r.parseNumber(u, n);
      e.eventValue = -(f !== null ? f : 0), e.currentLooseValue = p(e.eventValue, n, r);
      const c = $(e.currentLooseValue, m), d = $(i, m);
      return b(e, e.selectionEnd - 1 + (c - d), e.currentLooseValue, g), e;
    }
    if (xe(e, o))
      return e.eventValue = r.parseNumber(e.currentLooseValue, n), b(e, e.selectionStart, e.currentLooseValue, g), e;
    if (be(e, o))
      return A(e, n, g, r), e;
    if (Z)
      return e.eventValue = r.parseNumber(s, n) / 100, e.currentLooseValue = p(e.eventValue, n, r), e;
    if (String(e.currentLooseValue).replace(/[^\d]/g, "").length > ee || x !== s && s && le && g.findIndex(([c, d]) => {
      const F = s.indexOf(c), z = s.indexOf(d), S = F === 0, W = z === s.length - d.length, k = F + c.length !== h && h !== -1 && s[F + c.length] !== o.decimal, q = z !== E && E !== -1 && s[z - 1] !== o.decimal;
      return c && d ? k || q ? !1 : S && W : c ? k ? !1 : S : d ? q ? !1 : W : !1;
    }) === -1)
      return A(e, n, g, r), e;
    if (x[x.length - 1] === o.decimal && N > 0)
      return e.eventValue = r.parseNumber(s, n), e.currentLooseValue = G, e;
    if (e.currentLooseValue && u && (a + o.decimal + o.group).split("").findIndex((c) => s.split("").filter((d) => d === c).length < i.split("").filter((d) => d === c).length && s.length + 1 === i.length ? !(c === o.decimal && J(i.replace(l, ""), o.decimal) === 0) : !1) > -1)
      return e.eventValue = r.parseNumber(t.prevLooseValue, n), e.currentLooseValue = t.prevLooseValue, e;
    const L = J(x, o.decimal), y = x[x.length - 1] === "0";
    if (M && y && L < D)
      return e.eventValue = r.parseNumber(e.currentLooseValue, n), e.currentLooseValue = p(e.eventValue, n, r), e;
    if (L > 0) {
      const f = s.substring(0, oe);
      if (y && (!f || i.indexOf(f) !== 0)) {
        e.eventValue = r.parseNumber(e.currentLooseValue, n);
        const c = p(e.eventValue, n, r);
        return b(e, K(s, c, e.selectionEnd, M, l), c, g), e.currentLooseValue = c, e;
      }
      if (L > N) {
        const c = s.indexOf(o.decimal), d = s.substring(0, c) + s.substring(c, c + 1 + N) + s.substring(E, String(e.currentLooseValue).length);
        return e.eventValue = r.parseNumber(d, n), e.currentLooseValue = d, b(e, e.selectionStart, d, g), e;
      }
      if (D !== N && L <= N && y)
        return e.eventValue = r.parseNumber(e.currentLooseValue, n), e.currentLooseValue = G, e;
      if (L < D)
        return e.eventValue = r.parseNumber(e.currentLooseValue, n), e.currentLooseValue = p(e.eventValue, n, r), e;
    }
  }
  if (e.eventValue = r.parseNumber(e.currentLooseValue, n), Z && (e.eventValue = e.eventValue / 100), typeof e.eventValue == "number") {
    const V = p(e.eventValue, n, r);
    s.length === 1 ? b(e, B(V, o), V, g) : b(e, K(s, V, e.selectionEnd, M, l), V, g), e.currentLooseValue = V;
  } else
    e.currentLooseValue = p(r.parseNumber(x), n, r);
  return e;
};
export {
  K as changeBasedSelection,
  Ce as decreaseValue,
  p as formatValue,
  H as fractionLength,
  J as getDecimalCount,
  $ as getFirstNumberIndex,
  he as getFormatPrefixSufix,
  Le as getFormatSymbols,
  B as getInitialPosition,
  R as getLastNumberIndex,
  fe as getMaxCursorPosition,
  me as getMinCursorPosition,
  O as getPrefix,
  Ne as getStateOrPropsValue,
  P as getSuffix,
  Ie as increaseValue,
  be as isDecimalDuplicated,
  pe as isMinusSymbolAdded,
  xe as isMinusSymbolRemoved,
  ge as limitPrecision,
  Ve as rangeSelection,
  re as rangeValue,
  T as reverseString,
  Ee as sanitizeNumber,
  A as setInvalid,
  b as setSelection,
  te as toFixedPrecision
};
