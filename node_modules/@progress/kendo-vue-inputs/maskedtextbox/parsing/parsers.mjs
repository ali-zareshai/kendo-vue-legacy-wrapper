/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { Result as i, ResultType as c } from "./result.mjs";
import { Stream as o } from "./stream.mjs";
const h = (r) => (r || "").split(""), f = "\\";
class w {
  constructor(n) {
    this.parse = n;
  }
  run(n, e = "") {
    return n instanceof o ? this.parse(n) : this.parse(new o(h(n), h(e)));
  }
  // map :: Functor f => f a ~> (a -> b) -> f b
  map(n) {
    return new w((e) => this.parse(e).map(n));
  }
  // chain :: Chain m => m a ~> (a -> m b) -> m b
  chain(n) {
    return new w((e) => this.parse(e).chain((t, u) => n(t).run(u)));
  }
  isLiteral(n) {
    return this.run(n).type === c.Literal;
  }
}
const p = ({ prompt: r, promptPlaceholder: n }) => (e) => new w((t) => {
  for (; !t.eof(); ) {
    const { char: u, control: l } = t.peek();
    if (u === l && l === r)
      return t.eat(), new i(r, t, c.Mask);
    if (e.test(u))
      return t.eat(), new i(u, t, c.Mask);
    if (u === n)
      return t.eat(), new i(r, t, c.Mask);
    t.eat_input();
  }
  return t.eat(), new i(r, t, c.Mask);
}), s = (r) => new w((n) => n.peek().char === r ? (n.eat(), new i(r, n, c.Literal)) : new i(r, n, c.Literal)), x = (r) => (n) => new w((e) => {
  for (; !e.eof(); ) {
    const { char: t, control: u } = e.peek();
    if (t === r && u === r)
      return e.eat(), new i(t, e);
    if (n.test(t))
      return e.eat(), new i(t, e);
    e.eat_input();
  }
  return e.eat(), new i("", e);
}), L = (r) => new w((n) => {
  if (n.eof())
    return new i("", n);
  const { char: e } = n.peek();
  return e === r && n.eat(), new i(r, n);
}), M = (r, n) => new w((e) => {
  let { char: t } = e.next();
  const u = r[t];
  return t === f ? (t = e.next().char, new i(n.literal(t), e)) : u ? new i(n.mask(u), e) : new i(n.literal(t), e);
}), A = ({ prompt: r, promptPlaceholder: n }) => new w((e) => {
  let { char: t } = e.next();
  return t === r ? new i(n, e) : new i(t, e);
}), R = (r) => new w((n) => {
  let { char: e } = n.next();
  return r ? new i(e, n) : new i("", n);
});
export {
  w as Parser,
  s as literal,
  p as mask,
  R as rawLiteral,
  A as rawMask,
  M as token,
  L as unliteral,
  x as unmask
};
