/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { parseColor as u, Color as g } from "@progress/kendo-drawing";
import { isPresent as c, fitIntoBounds as s } from "./misc.mjs";
const R = (t, r, o = !1, n = !0) => {
  if (["hex", "rgba"].indexOf(r) === -1)
    throw new Error(`Unsupported color output format '${r}'. The available options are 'hex' or 'rgba'.`);
  if (!c(t))
    return;
  const e = u(t.trim(), n);
  if (c(e))
    return r === "hex" ? C(e, o) : e.toCssRgba();
}, C = (t, r) => r && t.a < 1 ? t.toCss({ alpha: !0 }) : t.toCss(), x = (t, r = !0) => {
  const o = u(t, r);
  return c(o) ? o.toHSV() : {};
}, F = (t, r = !0) => {
  const o = u(t, r);
  return c(o) ? o.toBytes() : {};
}, f = (t) => {
  const r = s(t.h, 0, 359.9), o = s(t.s, 0, 1), n = s(t.v, 0, 1), a = s(t.a, 0, 1);
  return g.fromHSV(r, o, n, a).toCssRgba();
}, w = (t) => f({ h: t, s: 1, v: 1, a: 1 }), H = (t) => {
  const r = s(t.r, 0, 255), o = s(t.g, 0, 255), n = s(t.b, 0, 255), a = s(t.a, 0, 1);
  return g.fromBytes(r, o, n, a).toCssRgba();
}, p = (t, r) => {
  const o = s(t.r, 0, 255), n = s(t.g, 0, 255), a = s(t.b, 0, 255), e = s(t.a, 0, 1), h = s(r.r, 0, 255), m = s(r.g, 0, 255), l = s(r.b, 0, 255);
  return {
    r: Math.round((1 - e) * h + e * o),
    g: Math.round((1 - e) * m + e * n),
    b: Math.round((1 - e) * l + e * a)
  };
}, i = (t) => {
  let r = [t.r, t.g, t.b].map(function(o) {
    return o /= 255, o <= 0.03928 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4);
  });
  return r[0] * 0.2126 + r[1] * 0.7152 + r[2] * 0.0722;
}, b = (t, r) => {
  const o = Math.max(t, r), n = Math.min(t, r);
  return (o + 0.05) / (n + 0.05);
}, M = (t, r) => b(
  i(p(t, r)),
  i(p(r, { r: 0, g: 0, b: 0 }))
);
export {
  f as getColorFromHSV,
  w as getColorFromHue,
  H as getColorFromRGBA,
  b as getContrast,
  M as getContrastFromTwoRGBAs,
  x as getHSV,
  C as getHexValue,
  i as getLuminance,
  F as getRGBA,
  p as getRGBFromRGBA,
  R as parseColor
};
