/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { isPresent as i } from "./misc.mjs";
import { parseColor as n } from "@progress/kendo-drawing";
class c {
  constructor() {
    this.colorRows = [];
  }
  setColorMatrix(o, r) {
    if (this.colorRows = [], !!(i(o) && o.length)) {
      r = r || o.length;
      for (let t = 0; t < o.length; t += r) {
        const s = o.slice(t, r + t);
        this.colorRows.push(s);
      }
    }
  }
  isInColors(o, r) {
    return o.some((t) => t === r);
  }
  getCellCoordsFor(o) {
    if (!i(o))
      return;
    const r = o && n(o, !0), t = [o];
    i(r) && t.push(r.toCss(), r.toCssRgba());
    for (let s = 0; s < this.colorRows.length; s++)
      for (let e = 0; e < this.colorRows[s].length; e++)
        if (this.isInColors(t, this.colorRows[s][e]))
          return { row: s, col: e };
  }
  getColorAt(o) {
    if (i(o) && i(this.colorRows[o.row]))
      return this.colorRows[o.row][o.col];
  }
  getNextCell(o, r, t) {
    if (!(i(o) && i(o.row) && i(o.col)))
      return { row: 0, col: 0 };
    const s = this.clampIndex(o.row + t, this.colorRows.length - 1), e = this.clampIndex(o.col + r, this.colorRows[s].length - 1);
    return { row: s, col: e };
  }
  clampIndex(o, r) {
    return o < 0 ? 0 : o > r ? r : o;
  }
}
export {
  c as ColorPaletteService
};
