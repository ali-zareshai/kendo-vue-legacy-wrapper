/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { Align } from '@progress/kendo-vue-popup';
import { ButtonsPopupSettings as ButtonsPopupSettings_2 } from '..';
import { ComponentOptionsMixin } from 'vue';
import { ComponentProvideOptions } from 'vue';
import { DefineComponent } from 'vue';
import { ExtractPropTypes } from 'vue';
import { FloatingActionButtonAlignOffset as FloatingActionButtonAlignOffset_2 } from '..';
import { FloatingActionButtonPopupSettings as FloatingActionButtonPopupSettings_2 } from '..';
import { FormComponentProps } from '@progress/kendo-vue-common';
import { PopupAnimation } from '@progress/kendo-vue-popup';
import { PropType } from 'vue';
import { PublicProps } from 'vue';
import { Ref } from 'vue';
import { SVGIcon } from '@progress/kendo-vue-common';
import { SVGIcon as SVGIcon_2 } from '@progress/kendo-svg-icons';
import { SvgIconProps } from '@progress/kendo-vue-common';

/**
 * @hidden
 */
export declare const Button: DefineComponent<ExtractPropTypes<    {
ariaLabel: PropType<string>;
ariaPressed: PropType<boolean>;
title: PropType<string>;
dir: PropType<string>;
selected: {
type: PropType<boolean>;
default: any;
};
togglable: {
type: PropType<boolean>;
default: boolean;
};
icon: {
type: PropType<string>;
default: () => any;
};
svgIcon: PropType<SVGIcon>;
iconSize: {
type: PropType<string>;
default: string;
};
iconClass: {
type: PropType<string>;
default: () => any;
};
imageUrl: {
type: PropType<string>;
default: () => any;
};
imageAlt: PropType<string>;
disabled: {
type: PropType<boolean>;
default: any;
};
size: {
type: PropType<string>;
default: string;
};
shape: {
type: PropType<string>;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
};
themeColor: {
type: PropType<string>;
default: string;
};
tabIndex: PropType<number>;
accessKey: PropType<string>;
id: PropType<string>;
type: PropType<string>;
role: PropType<string>;
}>, {}, {
currentActive: any;
}, {
computedSelected(): boolean;
buttonClasses(): {
[x: string]: any;
'k-icon-button': boolean;
'k-disabled': any;
'k-selected': any;
'k-rtl': boolean;
};
}, {
focus(e: any): void;
toggleIfApplicable(): void;
handleClick(event: any): void;
handleMouseDown(event: any): void;
handlePointerDown(event: any): void;
handleMouseUp(event: any): void;
handlePointerUp(event: any): void;
handleFocus(event: FocusEvent): void;
handleBlur(event: FocusEvent): void;
handleKeypress(event: any): void;
handleKeydown(event: any): void;
handleContextmenu(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
click: (event: Event) => true;
mousedown: (event: MouseEvent) => true;
mouseup: (event: MouseEvent) => true;
pointerdown: (event: PointerEvent) => true;
pointerup: (event: PointerEvent) => true;
focus: (event: ButtonFocusEvent) => true;
blur: (event: ButtonBlurEvent) => true;
keypress: (event: KeyboardEvent) => true;
keydown: (event: KeyboardEvent) => true;
contextmenu: (event: MouseEvent) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
ariaLabel: PropType<string>;
ariaPressed: PropType<boolean>;
title: PropType<string>;
dir: PropType<string>;
selected: {
type: PropType<boolean>;
default: any;
};
togglable: {
type: PropType<boolean>;
default: boolean;
};
icon: {
type: PropType<string>;
default: () => any;
};
svgIcon: PropType<SVGIcon>;
iconSize: {
type: PropType<string>;
default: string;
};
iconClass: {
type: PropType<string>;
default: () => any;
};
imageUrl: {
type: PropType<string>;
default: () => any;
};
imageAlt: PropType<string>;
disabled: {
type: PropType<boolean>;
default: any;
};
size: {
type: PropType<string>;
default: string;
};
shape: {
type: PropType<string>;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
};
themeColor: {
type: PropType<string>;
default: string;
};
tabIndex: PropType<number>;
accessKey: PropType<string>;
id: PropType<string>;
type: PropType<string>;
role: PropType<string>;
}>> & Readonly<{
onClick?: (event: Event) => any;
onBlur?: (event: ButtonBlurEvent) => any;
onContextmenu?: (event: MouseEvent) => any;
onFocus?: (event: ButtonFocusEvent) => any;
onKeydown?: (event: KeyboardEvent) => any;
onKeypress?: (event: KeyboardEvent) => any;
onMousedown?: (event: MouseEvent) => any;
onMouseup?: (event: MouseEvent) => any;
onPointerdown?: (event: PointerEvent) => any;
onPointerup?: (event: PointerEvent) => any;
}>, {
themeColor: string;
size: string;
icon: string;
rounded: string;
fillMode: string;
iconSize: string;
selected: boolean;
togglable: boolean;
iconClass: string;
imageUrl: string;
disabled: boolean;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The arguments for the `onBlur` event of the Button.
 */
export declare interface ButtonBlurEvent {
    /**
     * The native browser blur event.
     */
    event: FocusEvent;
}

/**
 * @hidden
 */
export declare interface ButtonComputed {
    [key: string]: any;
    buttonClasses: object;
}

/**
 * @hidden
 */
export declare interface ButtonData {
    currentActive: boolean;
}

/**
 * The arguments for the `onFocus` event of the Button.
 */
export declare interface ButtonFocusEvent {
    /**
     * The native browser focus event.
     */
    event: FocusEvent;
}

/**
 * @hidden
 */
export declare const ButtonGroup: DefineComponent<ExtractPropTypes<    {
disabled: {
type: PropType<boolean>;
default: any;
};
width: PropType<string>;
dir: {
type: PropType<string>;
default: () => any;
};
}>, {}, {}, {}, {
isValidButton(child: any): any;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
disabled: {
type: PropType<boolean>;
default: any;
};
width: PropType<string>;
dir: {
type: PropType<string>;
default: () => any;
};
}>> & Readonly<{}>, {
dir: string;
disabled: boolean;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * Represents the properties which can be set to a ButtonGroup.
 */
declare interface ButtonGroupInterface {
    /**
     * By default, the ButtonGroup is enabled ([see example]({% slug disabledstate_buttongroup %})). To disable the whole group of buttons,
     * set its `disabled` attribute to `true`. To disable a specific button, set its own `disabled` attribute to `true` and leave the `disabled` attribute of the ButtonGroup undefined.
     *
     * If you define the `disabled` attribute of the ButtonGroup, it will take precedence over the `disabled` attributes
     *  of the underlying buttons and they will be ignored.
     */
    disabled?: boolean;
    /**
     * Sets the width of the ButtonGroup.
     *
     * If the width of the ButtonGroup is set:
     * - The buttons resize automatically to fill the full width of the group wrapper.
     * - The buttons acquire the same width.
     */
    width?: string;
    /**
     * Sets the direction of the ButtonGroup ([more information](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir)).
     *
     * The available options are:
     * * `rtl`
     * * `ltr`
     * * `auto`
     */
    dir?: string;
}

/**
 * Represents the props of the [Kendo UI for Vue ButtonGroup component]({% slug overview_buttongroup %}).
 */
export declare interface ButtonGroupProps extends ButtonGroupInterface, ButtonProps {
    /**
     * Sets the `className` of the ButtonGroup component.
     */
    className?: string;
}

/**
 * Inherits the native HTML Button. Represents the properties which can be set to a Button.
 */
declare interface ButtonInterface {
    /**
     * Adds visual weight to the Button and makes it primary ([see example]({% slug primary_button %})).
     * **Deprecated**. Use [`themeColor`]({% slug api_buttons_buttonprops %}#toc-themecolor) prop instead.
     *
     * @deprecated
     */
    primary?: boolean;
    /**
     * Specifies if the Button is disabled ([see example]({% slug disabled_button %})). Defaults to `false`.
     */
    disabled?: boolean;
    /**
     * Sets the aria-label of the Button.
     */
    ariaLabel?: string;
    /**
     * Sets the `title` HTML attribute of the Button.
     */
    title?: string;
    /**
     * Sets the direction of the Button.
     */
    dir?: string;
    /**
     * Sets the selected state of the Button. Can be used for controlled mode.
     */
    selected?: boolean;
    /**
     * Provides visual styling that indicates if the Button is selected ([see example]({% slug toggleable_button %})). Defaults to `false`.
     */
    togglable?: boolean;
    /**
     * Defines the name for an existing icon in a Kendo UI for Vue theme ([see example]({% slug icons_button %})). The icon is rendered inside the Button by a `span.k-icon` element.
     */
    icon?: string;
    /**
     * Defines an SVGIcon to be rendered within the button.
     */
    svgIcon?: SVGIcon;
    /**
     * Defines a CSS class&mdash;or multiple classes separated by spaces&mdash;which are applied to a `span` element inside the Button ([see example]({% slug icons_button %})). Allows the usage of custom icons.
     */
    iconClass?: string;
    /**
     * Defines a URL which is used as an `img` element inside the Button ([see example]({% slug icons_button %})). The URL can be relative or absolute. If relative, it is evaluated with relation to the URL of the web page.
     */
    imageUrl?: string;
    /**
     * Defines the alternative text of the image rendered inside the Button component.
     */
    imageAlt?: string;
}

/**
 * @hidden
 */
export declare const ButtonItem: DefineComponent<ExtractPropTypes<    {
focused: PropType<boolean>;
index: PropType<number>;
item: PropType<any>;
render: PropType<any>;
dataItem: PropType<any>;
id: PropType<string>;
textField: PropType<string>;
role: PropType<string>;
}>, {}, {}, {
wrapperClass(): object;
innerClass(): object;
}, {
onClick(event: any): void;
onDown(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
click: (event: any, index: number) => true;
down: (event: any, index: number) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
focused: PropType<boolean>;
index: PropType<number>;
item: PropType<any>;
render: PropType<any>;
dataItem: PropType<any>;
id: PropType<string>;
textField: PropType<string>;
role: PropType<string>;
}>> & Readonly<{
onClick?: (event: any, index: number) => any;
onDown?: (event: any, index: number) => any;
}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The interface for describing items that can be passed to the `items` property of the SplitButton or the DropDownButton as an alternative to passing them as children.
 */
export declare interface ButtonItemInterface {
    /**
     * Specifies the text of the item.
     */
    text: string;
    /**
     * Defines an icon that will be rendered next to the item text.
     */
    icon?: string;
    /**
     * Defines an icon with a custom CSS class that will be rendered next to the item text.
     */
    iconClass?: string;
    /**
     * Defines the location of an image that will be displayed next to the item text.
     */
    imageUrl?: string;
    /**
     * Determines whether the item is disabled.
     */
    disabled?: boolean;
    /**
     * Defines a named slot `string`, functional or class component for rendering the item. The default rendering includes an icon, an image, and text.
     */
    render?: any;
}

/**
 * The props of the ButtonItem component.
 * The ButtonItem component renders each list item in the dropdown buttons list.
 */
export declare interface ButtonItemProps {
    focused?: boolean;
    index?: number;
    item?: any;
    render?: any;
    dataItem: any;
    id?: string;
    textField?: string;
    role?: string;
}

/**
 * @hidden
 */
export declare interface ButtonMethods {
    [key: string]: any;
    focus: (e: any) => void;
    toggleIfApplicable: () => void;
    handleClick: (event: any) => void;
}

/**
 * Represents the props of the [Kendo UI for Vue Button component]({% slug overview_button %}).
 * Extends the [native button props](https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement).
 */
export declare interface ButtonProps extends ButtonInterface {
    /**
     * Configures the `size` of the Button.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - null&mdash;Does not set a size `className`.
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large' | string;
    /**
     * Configures the `shape` of the Button.
     *
     * The available options are:
     * - rectangle
     * - square
     * - null&mdash;Does not set a shape `class`.
     *
     */
    shape?: null | 'rectangle' | 'square' | string;
    /**
     * Configures the `roundness` of the Button.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - circle
     * - full
     * - null&mdash;Does not set a rounded `className`.
     *
     * @default `medium`
     */
    rounded?: null | 'small' | 'medium' | 'large' | 'full' | string;
    /**
     * Configures the `fillMode` of the Button.
     *
     * The available options are:
     * - solid
     * - outline
     * - flat
     * - link
     * - null&mdash;Does not set a fillMode `className`.
     *
     * @default `solid`
     */
    fillMode?: null | 'solid' | 'outline' | 'flat' | 'link' | string;
    /**
     * Configures the `themeColor` of the Button.
     *
     * The available options are:
     * - base
     * - primary
     * - secondary
     * - tertiary
     * - info
     * - success
     * - warning
     * - dark
     * - light
     * - inverse
     * - null&mdash;Does not set a themeColor `className`.
     *
     * @default `base`
     */
    themeColor?: null | 'base' | 'primary' | 'secondary' | 'tertiary' | 'info' | 'success' | 'warning' | 'dark' | 'light' | 'inverse' | string;
    /**
     * Sets the `tabIndex` property of the Button.
     */
    tabIndex?: number;
    /**
     * Sets the `accessKey` property of the Button.
     */
    accessKey?: string;
    /**
     * Sets the `id` property of the Button.
     */
    id?: string;
    /**
     * Sets the `type` property of the Button.
     */
    type?: string;
    /**
     * Sets the `role` attribute of the Button.
     */
    role?: string;
    /**
     * Sets the `aria-pressed` attribute of the Button.
     */
    ariaPressed?: boolean;
    /**
     * defines the size of the SVG icon displayed inside the Button.
     */
    iconSize?: SvgIconProps['size'];
}

/**
 * The settings of the popup container.
 */
export declare interface ButtonsPopupSettings {
    /**
     * Controls the popup animation. By default, the open and close animations are enabled.
     */
    animate?: boolean | PopupAnimation;
    /**
     * Specifies a list of CSS classes that are used for styling the popup.
     */
    popupClass?: string;
    /**
     * Specifies the pivot point of the anchor
     * ([see example]({% slug alignmentpositioning_popup %})).
     */
    anchorAlign?: Align;
    /**
     * Specifies the pivot point of the Popup
     * ([see example]({% slug alignmentpositioning_popup %})).
     */
    popupAlign?: Align;
}

/**
 * @hidden
 */
export declare const Chip: DefineComponent<ExtractPropTypes<    {
id: PropType<string>;
text: PropType<string>;
avatar: {
type: PropType<string | Object | Function>;
default: () => any;
};
value: PropType<any>;
dir: {
type: PropType<string>;
default: () => string;
};
removable: {
type: PropType<boolean>;
default: boolean;
};
removeIcon: {
type: PropType<string>;
default: () => string;
};
removeSvgIcon: {
type: PropType<SVGIcon>;
default: () => SVGIcon_2;
};
disabled: {
type: PropType<boolean>;
default: boolean;
};
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
selectedIcon: {
type: PropType<string>;
default: () => string;
};
selectedSvgIcon: {
type: PropType<SVGIcon>;
default: () => SVGIcon_2;
};
size: {
type: PropType<string>;
default: string;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
themeColor: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
dataItem: PropType<any>;
selected: PropType<boolean>;
ariaDescribedBy: PropType<string>;
role: {
type: PropType<string>;
default: string;
};
tabIndex: PropType<number>;
onMousedown: PropType<(event: any) => void>;
}>, {
chipRef: Ref<any, any>;
}, {}, {
currentSelected(): any;
chipLabelClass(): {
'k-chip-label': boolean;
};
}, {
computedFocused(): boolean;
handleMouseDown(event: any): void;
handleClick(event: any): void;
handleRemove(event: any): void;
handleKeyDown(event: any): void;
handleFocus(event: FocusEvent): void;
handleBlur(event: FocusEvent): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
click: (event: ChipMouseEvent) => true;
keydown: (event: ChipKeyboardEvent) => true;
blur: (event: ChipFocusEvent) => true;
focus: (event: ChipFocusEvent) => true;
remove: (event: ChipRemoveEvent) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
id: PropType<string>;
text: PropType<string>;
avatar: {
type: PropType<string | Object | Function>;
default: () => any;
};
value: PropType<any>;
dir: {
type: PropType<string>;
default: () => string;
};
removable: {
type: PropType<boolean>;
default: boolean;
};
removeIcon: {
type: PropType<string>;
default: () => string;
};
removeSvgIcon: {
type: PropType<SVGIcon>;
default: () => SVGIcon_2;
};
disabled: {
type: PropType<boolean>;
default: boolean;
};
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
selectedIcon: {
type: PropType<string>;
default: () => string;
};
selectedSvgIcon: {
type: PropType<SVGIcon>;
default: () => SVGIcon_2;
};
size: {
type: PropType<string>;
default: string;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
themeColor: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
dataItem: PropType<any>;
selected: PropType<boolean>;
ariaDescribedBy: PropType<string>;
role: {
type: PropType<string>;
default: string;
};
tabIndex: PropType<number>;
onMousedown: PropType<(event: any) => void>;
}>> & Readonly<{
onClick?: (event: ChipMouseEvent) => any;
onBlur?: (event: ChipFocusEvent) => any;
onFocus?: (event: ChipFocusEvent) => any;
onKeydown?: (event: ChipKeyboardEvent) => any;
onRemove?: (event: ChipRemoveEvent) => any;
}>, {
themeColor: string;
size: string;
role: string;
rounded: string;
fillMode: string;
dir: string;
disabled: boolean;
avatar: string | Object | Function;
removable: boolean;
removeIcon: string;
removeSvgIcon: SVGIcon;
selectedIcon: string;
selectedSvgIcon: SVGIcon;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * Represents the return type of the ChipFocusEvent.
 */
export declare interface ChipFocusEvent {
    /**
     * The target of the ChipFocusEvent from ChipHandle.
     */
    target: ChipHandle;
    /**
     * The native browser focus event.
     */
    event: FocusEvent;
}

/**
 * Represents the target(element and props) of the ChipRemoveEvent.
 */
export declare interface ChipHandle {
    /**
     * The current element or `null` if there is no one.
     */
    element: HTMLDivElement | null;
    /**
     * The props values of the Chip.
     */
    props: ChipProps;
}

/**
 * Represents the return type of the ChipKeyboardEvent.
 */
export declare interface ChipKeyboardEvent {
    /**
     * The target of the ChipKeyboardEvent from ChipHandle.
     */
    target: ChipHandle;
    /**
     * The event of the ChipKeyboardEvent.
     */
    event: any;
}

/**
 * @hidden
 */
export declare const ChipList: DefineComponent<ExtractPropTypes<    {
id: StringConstructor;
tabIndex: NumberConstructor;
dataItems: ArrayConstructor;
defaultDataItems: {
type: ArrayConstructor;
default: () => any[];
};
value: (ArrayConstructor | ObjectConstructor | StringConstructor | NumberConstructor)[];
defaultValue: {
type: (ArrayConstructor | ObjectConstructor | StringConstructor | NumberConstructor)[];
default: () => any;
};
size: {
type: StringConstructor;
default: string;
};
rounded: {
type: StringConstructor;
default: string;
};
fillMode: {
type: StringConstructor;
default: string;
validator: (value: any) => any;
};
selection: {
type: StringConstructor;
default: () => "none";
};
textField: {
type: StringConstructor;
default: () => "text";
};
valueField: {
type: StringConstructor;
default: () => "value";
};
avatarField: {
type: StringConstructor;
default: () => "avatar";
};
disabled: {
type: BooleanConstructor;
default: boolean;
};
dir: {
type: StringConstructor;
default: () => "ltr";
};
chip: (ObjectConstructor | StringConstructor | FunctionConstructor)[];
ariaLabelledBy: StringConstructor;
ariaDescribedBy: StringConstructor;
}>, {
chipListRef: Ref<any, any>;
}, {
currentDataItems: any[];
currentDir: string;
isRtl: boolean;
currentFocused: {
value: boolean;
};
currentValue: {
value: any;
};
}, {
computedDataItems(): any;
computedValue(): any;
items(): any;
}, {
handleDispatchSelection(action: any): void;
handleDispatchFocus(action: any): void;
handleDispatchDataItems(action: any): void;
handleChange(newValue: any, event: any): void;
handleDataChange(newData: any, event: any): void;
itemsReducer(acc: any, current: any): any;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
change: (event: ChipListChangeEvent) => true;
datachange: (event: ChipListDataChangeEvent) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
id: StringConstructor;
tabIndex: NumberConstructor;
dataItems: ArrayConstructor;
defaultDataItems: {
type: ArrayConstructor;
default: () => any[];
};
value: (ArrayConstructor | ObjectConstructor | StringConstructor | NumberConstructor)[];
defaultValue: {
type: (ArrayConstructor | ObjectConstructor | StringConstructor | NumberConstructor)[];
default: () => any;
};
size: {
type: StringConstructor;
default: string;
};
rounded: {
type: StringConstructor;
default: string;
};
fillMode: {
type: StringConstructor;
default: string;
validator: (value: any) => any;
};
selection: {
type: StringConstructor;
default: () => "none";
};
textField: {
type: StringConstructor;
default: () => "text";
};
valueField: {
type: StringConstructor;
default: () => "value";
};
avatarField: {
type: StringConstructor;
default: () => "avatar";
};
disabled: {
type: BooleanConstructor;
default: boolean;
};
dir: {
type: StringConstructor;
default: () => "ltr";
};
chip: (ObjectConstructor | StringConstructor | FunctionConstructor)[];
ariaLabelledBy: StringConstructor;
ariaDescribedBy: StringConstructor;
}>> & Readonly<{
onChange?: (event: ChipListChangeEvent) => any;
onDatachange?: (event: ChipListDataChangeEvent) => any;
}>, {
size: string;
rounded: string;
fillMode: string;
dir: string;
disabled: boolean;
defaultDataItems: unknown[];
defaultValue: string | number | Record<string, any> | unknown[];
selection: string;
textField: string;
valueField: string;
avatarField: string;
}, {}, {}, {}, string, () => {
kendoSelection: any;
kendoFocused: any;
kendoDataItems: any;
handleDispatchDataItems: any;
handleDispatchSelection: any;
handleDispatchFocus: any;
}, true, {}, any>;

/**
 * Represents the return type of the ChipListChangeEvent.
 */
export declare interface ChipListChangeEvent {
    /**
     * Represents the new state value.
     */
    value: any | any[];
    /**
     * The target of the ChipListChangeEvent from ChipListHandle.
     */
    target: any;
    /**
     * The event of the ChipListChangeEvent.
     */
    event: any;
}

/**
 * Represents the return type of the ChipListDataChangeEvent.
 */
export declare interface ChipListDataChangeEvent {
    /**
     * Represents the new data state value.
     */
    value: any | any[];
    /**
     * The target of the ChipListChangeEvent from ChipListHandle.
     */
    target: any;
    /**
     * The event of the ChipListChangeEvent.
     */
    event: any;
}

/**
 * Represents the target(element and props) of the ChipListChangeEvent.
 */
export declare interface ChipListHandle {
    /**
     * The current element or `null` if there is no one.
     */
    element: HTMLDivElement | null;
    /**
     * The props values of the ChipList.
     */
    props: ChipListProps;
}

/**
 * Represents the properties of [ChipList]({% slug overview_chiplist %}) component.
 */
export declare interface ChipListProps extends FormComponentProps, ChipProps {
    /**
     * Sets the `id` property of the top div element of the ChipList.
     */
    id?: string;
    /**
     * Sets additional classes to the ChipList.
     */
    className?: string;
    /**
     * Sets the `tabIndex` attribute.
     */
    tabIndex?: number;
    /**
     * Represents Chip component.
     */
    chip?: any;
    /**
     * Represents the data about the child Chips.
     */
    dataItems?: any;
    /**
     * Represents the default data about the child Chips.
     */
    defaultDataItems?: any[];
    /**
     * Triggered after Chip data change.
     */
    onDatachange?: (event: ChipListDataChangeEvent) => void;
    /**
     * Represents the selection state of Chip component.
     */
    value?: any | any[];
    /**
     * Represents the default value of the selection state of Chip component.
     */
    defaultValue?: any | any[];
    /**
     * Triggered after value change.
     */
    onChange?: (event: ChipListChangeEvent) => void;
    /**
     * Configures the `size` of the Chip.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - null&mdash;Does not set a size `class`.
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large' | string;
    /**
     * Configures the `roundness` of the Chip.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - full
     * - null&mdash;Does not set a rounded `class`.
     *
     * @default `medium`
     */
    rounded?: null | 'small' | 'medium' | 'large' | 'full' | string;
    /**
     * Configures the `fillMode` of the Chip.
     *
     * The available options are:
     * - solid
     * - outline
     * - flat
     * - null&mdash;Does not set a fillMode `class`.
     *
     * @default `solid`
     */
    fillMode?: null | 'solid' | 'outline' | 'flat' | string;
    /**
     * Represents the selection state of Chip component.
     */
    selection?: string;
    /**
     * Represents the `text` field of Chip, defaults to 'text'.
     */
    textField?: string;
    /**
     * Represents the `value` field of the Chip, defaults to 'value'.
     */
    valueField?: string;
    /**
     * Represents the 'avatar' field in the Chip,  defaults to 'avatar'.
     */
    avatarField?: object;
    /**
     * Determines of ChipList is disabled.
     */
    disabled?: boolean;
    /**
     * The ChipList direction 'ltr' as default or 'rtl'.
     */
    dir?: string;
    /**
     * Identifies the element(s) which will describe the component, similar to HTML aria-describedby attribute.
     * For example these elements could contain error or hint message.
     */
    ariaDescribedBy?: string;
    /**
     * Identifies the element(s) which will label the component.
     */
    ariaLabelledBy?: string;
}

/**
 * Represents the return type of the ChipMouseEvent.
 */
export declare interface ChipMouseEvent {
    /**
     * The target of the ChipMouseEvent from ChipHandle.
     */
    target: ChipHandle;
    /**
     * The event of the ChipMouseEvent.
     */
    event: any;
}

/**
 * Represents the properties of [Chip]({% slug overview_chip %}) component.
 */
export declare interface ChipProps {
    /**
     * Sets the `id` property of the top div element of the Chip.
     */
    id?: string;
    /**
     * Sets the `tabIndex` attribute.
     */
    tabIndex?: number;
    /**
     * Sets the label text of the Chip.
     */
    text?: string;
    /**
     * Sets the `id` value of the Chip.
     */
    value?: any;
    /**
     * The Chip direction 'ltr' as default or 'rtl'.
     */
    dir?: string;
    /**
     * Determines if the Chip could be removed.
     */
    removable?: boolean;
    /**
     * Determines if the Chip has custom `removeIcon`.
     */
    removeIcon?: string;
    /**
     * Defines an remove SVGIcon to be rendered within the chip.
     */
    removeSvgIcon?: SVGIcon;
    /**
     * Determines if the Chip is disabled.
     */
    disabled?: boolean;
    /**
     * Determines if the Chip has an `icon`.
     */
    icon?: string;
    /**
     * Defines an SVGIcon to be rendered within the chip.
     */
    svgIcon?: SVGIcon;
    /**
     * Determines if the Chip has custom selection `icon`.
     */
    selectedIcon?: string;
    /**
     * Defines an selection SVGIcon to be rendered within the chip.
     */
    selectedSvgIcon?: SVGIcon;
    /**
     * If set to object of type ChipAvatarProps with image and imageAlt it renders a default Avatar. If set to string or a `render` function it
     * defines the avatar template that will be shown.
     */
    avatar?: string | Function | Object;
    /**
     * Configures the `size` of the Chip.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - null&mdash;Does not set a size `class`.
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large' | string;
    /**
     * Configures the `roundness` of the Chip.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - full
     * - null&mdash;Does not set a rounded `class`.
     *
     * @default `medium`
     */
    rounded?: null | 'small' | 'medium' | 'large' | 'full' | string;
    /**
     * Configures the `fillMode` of the Chip.
     *
     * The available options are:
     * - solid
     * - outline
     * - flat
     * - null&mdash;Does not set a fillMode `class`.
     *
     * @default `solid`
     */
    fillMode?: null | 'solid' | 'outline' | 'flat' | string;
    /**
     * Configures the `themeColor` of the Chip.
     *
     * The available options are:
     * - base
     * - info
     * - success
     * - warning
     * - error
     * - null&mdash;Does not set a themeColor `class`.
     *
     * @default `base`
     */
    themeColor?: null | 'base' | 'info' | 'success' | 'warning' | 'error' | string;
    /**
     * Triggered on Chip removing.
     */
    onRemove?: (event: ChipRemoveEvent) => void;
    /**
     * Triggered on onClick event.
     */
    onClick?: (event: ChipMouseEvent) => void;
    /**
     * Triggered on onKeyDown event.
     */
    onKeydown?: (event: ChipKeyboardEvent) => void;
    /**
     * Triggered on onFocus event.
     */
    onFocus?: (event: ChipFocusEvent) => void;
    /**
     * Triggered on onBlur event.
     */
    onBlur?: (event: ChipFocusEvent) => void;
    /**
     * Represents the item data, coming from the `ChipList` component.
     */
    dataItem?: any;
    /**
     * Determines if the Chip is selected.
     */
    selected?: boolean;
    /**
     * Identifies the element(s) which will describe the component, similar to HTML aria-describedby attribute.
     * For example these elements could contain error or hint message.
     */
    ariaDescribedBy?: string;
    /**
     * @hidden
     */
    role?: string;
    /**
     * @hidden
     */
    onMousedown?: (event: any) => void;
}

/**
 * Represents the return type of the ChipRemoveEvent.
 */
export declare interface ChipRemoveEvent {
    /**
     * The target of the ChipRemoveEvent from ChipHandle.
     */
    target: ChipHandle;
    /**
     * The event of the ChipRemoveEvent.
     */
    event: any;
}

/**
 * @hidden
 */
export declare const DropDownButton: DefineComponent<ExtractPropTypes<    {
accessKey: PropType<string>;
items: {
type: PropType<any[]>;
default: () => any[];
};
ariaLabel: PropType<string>;
text: PropType<any>;
textField: PropType<string>;
tabIndex: PropType<number>;
disabled: PropType<boolean>;
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
iconClass: PropType<string>;
imageUrl: PropType<string>;
popupSettings: PropType<ButtonsPopupSettings_2>;
itemRender: PropType<any>;
item: PropType<any>;
size: {
type: PropType<string>;
default: string;
};
shape: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
themeColor: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
opened: {
type: PropType<boolean>;
default: any;
};
buttonClass: PropType<string>;
dir: PropType<string>;
}>, {
kendoAnchorRef: Ref<any, any>;
}, {
currentOpened: boolean;
focused: boolean;
focusedIndex: number;
}, {
computedOpened(): boolean;
wrapperClass(): {
'k-dropdown-button': boolean;
'k-focus': any;
};
}, {
element(): HTMLButtonElement | null;
onKeyDown(event: any): void;
onFocus(event: FocusEvent): void;
onBlur(event: FocusEvent): void;
createBlurTimeout(event: FocusEvent): void;
onItemClick(event: any, clickedItemIndex: number): void;
onItemDown(event: any): void;
mouseDown(event: any): void;
dispatchClickEvent(dispatchedEvent: any, index: number): void;
onClickMainButton(event: any): void;
dispatchPopupEvent(dispatchedEvent: any, open: boolean): void;
isItemDisabled(index: number): any;
isRtl(): boolean;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
focus: (event: DropDownButtonFocusEvent) => true;
blur: (event: DropDownButtonBlurEvent) => true;
itemclick: (event: DropDownButtonItemClickEvent) => true;
open: (event: DropDownButtonOpenEvent) => true;
close: (event: DropDownButtonCloseEvent) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
accessKey: PropType<string>;
items: {
type: PropType<any[]>;
default: () => any[];
};
ariaLabel: PropType<string>;
text: PropType<any>;
textField: PropType<string>;
tabIndex: PropType<number>;
disabled: PropType<boolean>;
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
iconClass: PropType<string>;
imageUrl: PropType<string>;
popupSettings: PropType<ButtonsPopupSettings_2>;
itemRender: PropType<any>;
item: PropType<any>;
size: {
type: PropType<string>;
default: string;
};
shape: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
themeColor: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
opened: {
type: PropType<boolean>;
default: any;
};
buttonClass: PropType<string>;
dir: PropType<string>;
}>> & Readonly<{
onBlur?: (event: DropDownButtonBlurEvent) => any;
onClose?: (event: DropDownButtonCloseEvent) => any;
onFocus?: (event: DropDownButtonFocusEvent) => any;
onOpen?: (event: DropDownButtonOpenEvent) => any;
onItemclick?: (event: DropDownButtonItemClickEvent) => any;
}>, {
themeColor: string;
size: string;
shape: string;
rounded: string;
fillMode: string;
items: any[];
opened: boolean;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The arguments for the `blur` event.
 */
export declare interface DropDownButtonBlurEvent {
    /**
     * The native browser blur event (FocusEvent).
     */
    event: FocusEvent;
}

/**
 * The arguments for the `close` event.
 */
export declare interface DropDownButtonCloseEvent {
    /**
     * The native browser event.
     */
    event: any;
}

/**
 * The arguments for the `focus` event.
 */
export declare interface DropDownButtonFocusEvent {
    /**
     * The native browser focus event.
     */
    event: FocusEvent;
}

/**
 * The arguments for the `itemClick` event.
 */
export declare interface DropDownButtonItemClickEvent {
    /**
     * The clicked item.
     */
    item: any;
    /**
     * The zero-based index of the clicked item.
     */
    itemIndex: number;
    /**
     * The native browser event.
     */
    event: any;
}

/**
 * The arguments for the `open` event.
 */
export declare interface DropDownButtonOpenEvent {
    /**
     * The native browser event.
     */
    event: any;
}

export declare interface DropDownButtonProps {
    /**
     * Specifies the `accessKey` of the main button.
     */
    accessKey?: string;
    /**
     * Specifies the `ariaLabel` of the main button. By default it is set to the text of the DropDownButton and 'dropdownbutton'.
     */
    ariaLabel?: string;
    /**
     * Specifies the text of the main button ([see example]({% slug overview_dropdownbutton %})).
     */
    text?: any;
    /**
     * Specifies the list items ([see example]({% slug binding_dropdownbutton %}#toc-arrays-of-objects)).
     */
    items?: any[];
    /**
     * Configures the field that will be used for the text of the `items`. `textField` has to be used together with the `items` prop ([see example]({% slug binding_dropdownbutton %}#toc-arrays-of-objects)).
     */
    textField?: string;
    /**
     * Specifies the `tabIndex` of the main button.
     */
    tabIndex?: number;
    /**
     * Determines whether the component is disabled ([see example]({% slug disabled_dropdownbutton %})).
     */
    disabled?: boolean;
    /**
     * Opens the popup of the DropDownButton if set to `true`.
     */
    opened?: boolean;
    /**
     * Defines an icon that will be rendered next to the main button text ([see example]({% slug icons_dropdownbutton %})).
     */
    icon?: string;
    /**
     * Defines an SVGIcon to be rendered within the DropDownButton.
     */
    svgIcon?: SVGIcon;
    /**
     * Defines an icon with a custom CSS class that will be rendered next to the main button text ([see example]({% slug icons_dropdownbutton %})).
     */
    iconClass?: string;
    /**
     * Defines the location of an image that will be displayed next to the main button text ([see example]({% slug icons_dropdownbutton %})).
     */
    imageUrl?: string;
    /**
     * Configures the popup
     * ([see example]({% slug customization_dropdownbutton %}#toc-popup)).
     */
    popupSettings?: ButtonsPopupSettings;
    /**
     * Defines a named slot `string`, functional or class component which is used for rendering items ([see example]({% slug customization_dropdownbutton %}#toc-items-rendering)). The default rendering includes an icon, an image, and text.
     */
    item?: null | any;
    /**
     * Fires when a dropdown list button item is about to be rendered. Use it to override the default appearance of the list items.
     * if `item` prop is not declared, `itemRender` behaves like `item`, for backward compatibility with versions before 4.2.0
     */
    itemRender?: any;
    /**
     * Sets the `className` of the main button.
     */
    buttonClass?: string;
    /**
     * Sets the direction of the component.
     */
    dir?: string;
    /**
     * Configures the `size` of the Button.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - null&mdash;Does not set a size `className`.
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large' | string;
    /**
     * Configures the `shape` of the Button.
     *
     * The available options are:
     * - rectangle
     * - square
     * - null&mdash;Does not set a shape `className`.
     *
     * @default `rectangle`
     */
    shape?: null | 'rectangle' | 'square' | string;
    /**
     * Configures the `roundness` of the Button.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - circle
     * - full
     * - null&mdash;Does not set a rounded `className`.
     *
     * @default `medium`
     */
    rounded?: null | 'small' | 'medium' | 'large' | 'full' | string;
    /**
     * Configures the `fillMode` of the Button.
     *
     * The available options are:
     * - solid
     * - outline
     * - flat
     * - link
     * - null&mdash;Does not set a fillMode `className`.
     *
     * @default `solid`
     */
    fillMode?: null | 'solid' | 'outline' | 'flat' | 'link' | string;
    /**
     * Configures the `themeColor` of the Button.
     *
     * The available options are:
     * - base
     * - primary
     * - secondary
     * - tertiary
     * - info
     * - success
     * - warning
     * - dark
     * - light
     * - inverse
     * - null&mdash;Does not set a themeColor `className`.
     *
     * @default `base`
     */
    themeColor?: null | 'base' | 'primary' | 'secondary' | 'tertiary' | 'info' | 'success' | 'warning' | 'dark' | 'light' | 'inverse' | string;
    /**
     * Fires when the component is focused ([see example]({% slug events_dropdownbutton %})).
     */
    onFocus?: (event: DropDownButtonFocusEvent) => void;
    /**
     * Fires when the component is blurred ([see example]({% slug events_dropdownbutton %})).
     */
    onBlur?: (event: DropDownButtonBlurEvent) => void;
    /**
     * Fires when an item is clicked ([see example]({% slug events_dropdownbutton %})).
     */
    onItemclick?: (event: DropDownButtonItemClickEvent) => void;
    /**
     * Fires when the popup which contains the items is opened ([see example]({% slug events_dropdownbutton %})).
     */
    onOpen?: (event: DropDownButtonOpenEvent) => void;
    /**
     * Fires when the popup which contains the items is closed ([see example]({% slug events_dropdownbutton %})).
     */
    onClose?: (event: DropDownButtonCloseEvent) => void;
}

/**
 * @hidden
 */
export declare const FloatingActionButton: DefineComponent<ExtractPropTypes<    {
id: PropType<string>;
dir: PropType<string>;
tabIndex: PropType<number>;
accessKey: PropType<string>;
disabled: {
type: PropType<boolean>;
default: boolean;
};
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
iconClass: PropType<string>;
items: PropType<any>;
item: PropType<any>;
text: PropType<string>;
alignOffset: PropType<FloatingActionButtonAlignOffset_2>;
opened: {
type: PropType<boolean>;
default: any;
};
align: {
type: PropType<FloatingActionButtonAlign>;
default: () => FloatingActionButtonAlign;
};
positionMode: {
type: PropType<FloatingActionButtonPositionMode>;
default: () => FloatingActionButtonPositionMode;
};
popupSettings: {
type: PropType<FloatingActionButtonPopupSettings_2>;
default: () => {};
};
shape: {
type: PropType<string>;
default: () => FloatingActionButtonShape;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
size: {
type: PropType<FloatingActionButtonSize>;
default: () => FloatingActionButtonSize;
};
themeColor: {
type: PropType<FloatingActionButtonThemeColor>;
default: () => FloatingActionButtonThemeColor;
};
}>, {
chipRef: Ref<any, any>;
kendoAnchorRef: Ref<any, any>;
}, {
currentOpened: boolean;
currentFocused: boolean;
focusedIndex: number;
currentDir: string;
isRtl: boolean;
}, {
buttonClassNames(): {
[x: string]: any;
'k-fab': boolean;
'k-disabled': any;
'k-focus': any;
};
computedOpened(): any;
rootClassNames(): string;
}, {
dispatchPopupEvent(dispatchedEvent: any, isOpen?: boolean): void;
handleClick(event: any): void;
handleFocus(event: FocusEvent): void;
handleBlur(event: FocusEvent): void;
handleMouseDown(event: any): void;
handleMouseUp(event: any): void;
dispatchItemClickEvent(dispatchedEvent: any, index: number): void;
handleItemClick(event: any, clickedItemIndex: number): void;
handleItemDown(event: any): void;
handleKeyDown(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
click: (event: FloatingActionButtonEvent) => true;
mousedown: (event: FloatingActionButtonEvent) => true;
mouseup: (event: FloatingActionButtonEvent) => true;
open: (event: FloatingActionButtonEvent) => true;
close: (event: FloatingActionButtonEvent) => true;
itemclick: (event: FloatingActionButtonItemEvent) => true;
focus: (event: FloatingActionButtonEvent) => true;
blur: (event: FloatingActionButtonEvent) => true;
keydown: (event: FloatingActionButtonEvent) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
id: PropType<string>;
dir: PropType<string>;
tabIndex: PropType<number>;
accessKey: PropType<string>;
disabled: {
type: PropType<boolean>;
default: boolean;
};
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
iconClass: PropType<string>;
items: PropType<any>;
item: PropType<any>;
text: PropType<string>;
alignOffset: PropType<FloatingActionButtonAlignOffset_2>;
opened: {
type: PropType<boolean>;
default: any;
};
align: {
type: PropType<FloatingActionButtonAlign>;
default: () => FloatingActionButtonAlign;
};
positionMode: {
type: PropType<FloatingActionButtonPositionMode>;
default: () => FloatingActionButtonPositionMode;
};
popupSettings: {
type: PropType<FloatingActionButtonPopupSettings_2>;
default: () => {};
};
shape: {
type: PropType<string>;
default: () => FloatingActionButtonShape;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
size: {
type: PropType<FloatingActionButtonSize>;
default: () => FloatingActionButtonSize;
};
themeColor: {
type: PropType<FloatingActionButtonThemeColor>;
default: () => FloatingActionButtonThemeColor;
};
}>> & Readonly<{
onClick?: (event: FloatingActionButtonEvent) => any;
onBlur?: (event: FloatingActionButtonEvent) => any;
onClose?: (event: FloatingActionButtonEvent) => any;
onFocus?: (event: FloatingActionButtonEvent) => any;
onKeydown?: (event: FloatingActionButtonEvent) => any;
onMousedown?: (event: FloatingActionButtonEvent) => any;
onMouseup?: (event: FloatingActionButtonEvent) => any;
onOpen?: (event: FloatingActionButtonEvent) => any;
onItemclick?: (event: FloatingActionButtonItemEvent) => any;
}>, {
themeColor: FloatingActionButtonThemeColor;
size: FloatingActionButtonSize;
shape: string;
rounded: string;
fillMode: string;
disabled: boolean;
opened: boolean;
align: FloatingActionButtonAlign;
positionMode: FloatingActionButtonPositionMode;
popupSettings: FloatingActionButtonPopupSettings_2;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * Specifies the horizontal and vertical alignment of the Floating Action Button in relation to the container.
 *
 * > Centering the Floating Action Button in both horizontal and vertical dimension is not a typical use case.
 * Still, it is possible to achieve such a layout with appropriate offsets. Setting horizontal: "center" and
 * vertical: "middle" at the same time is not supported.
 */
export declare interface FloatingActionButtonAlign {
    /**
     * Defines the possible horizontal alignment of the Floating Action Button.
     *
     * The available values are:
     * - `start`&mdash;Uses the start point of the container.
     * - `center`&mdash;Uses the center point of the container.
     * - `end`(Default)&mdash;Uses the end point of the container.
     */
    horizontal?: 'start' | 'center' | 'end';
    /**
     * Defines the possible vertical alignment of the Floating Action Button.
     *
     * The available values are:
     * - `top`&mdash;Uses the top point of the container.
     * - `middle`&mdash;Uses the middle point of the container.
     * - `bottom`(Default)&mdash;Uses the bottom point of the container.
     */
    vertical?: 'top' | 'middle' | 'bottom';
}

/**
 * Specifies the horizontal and vertical offset applied to the Floating Action Button.
 *
 * Normally, the floating button is positioned next to the boundaries of its container with a default offset of `16px`.
 *
 * Positive offsets move floating buttons, which are in a corner, further from that corner. Buttons, which are
 * not in a corner, can be moved along the container's boundary or towards the center of the container.
 *
 * A negative offset can be used to force a button to overflow the boundaries of its container.
 */
export declare interface FloatingActionButtonAlignOffset {
    /**
     * Sets the horizontal offset of the Floating Action Button.
     */
    x?: number | string;
    /**
     * Sets the vertical offset of the Floating Action Button.
     */
    y?: number | string;
}

/**
 * Represents the return type of the FloatingActionButton events.
 */
export declare interface FloatingActionButtonEvent {
    /**
     * The native browser event.
     */
    event: Event | FocusEvent;
}

/**
 * The FloatingActionButton ref.
 */
export declare interface FloatingActionButtonHandle {
    /**
     * The FloatingActionButton element.
     */
    element: HTMLButtonElement | null;
    /**
     * Focus the FloatingActionButton.
     */
    focus: () => void;
}

/**
 * @hidden
 */
export declare const FloatingActionButtonItem: DefineComponent<ExtractPropTypes<    {
id: PropType<string>;
disabled: PropType<boolean>;
focused: PropType<boolean>;
index: PropType<number>;
icon: PropType<string>;
item: PropType<any>;
dataItem: PropType<any>;
text: PropType<string>;
tabIndex: PropType<number>;
customProp: PropType<any>;
class: PropType<string>;
}>, {
elementRef: Ref<any, any>;
}, {}, {
itemClassNames(): string;
}, {
handleClick(event: any): void;
focusElement(): void;
onMouseDown(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
click: (event: any, index: number) => true;
down: (event: any) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
id: PropType<string>;
disabled: PropType<boolean>;
focused: PropType<boolean>;
index: PropType<number>;
icon: PropType<string>;
item: PropType<any>;
dataItem: PropType<any>;
text: PropType<string>;
tabIndex: PropType<number>;
customProp: PropType<any>;
class: PropType<string>;
}>> & Readonly<{
onClick?: (event: any, index: number) => any;
onDown?: (event: any) => any;
}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * Represents the return type of the FloatingActionButtonItemEvent.
 */
export declare interface FloatingActionButtonItemEvent {
    /**
     * The clicked item props.
     */
    itemProps?: any;
    /**
     * The zero-based index of the clicked item.
     */
    itemIndex: number;
}

/**
 * The FloatingActionButtonItemHandle ref.
 */
export declare interface FloatingActionButtonItemHandle {
    /**
     * The FloatingActionButtonItemHandle element.
     */
    element: HTMLLIElement | null;
    /**
     * Focus the FloatingActionButtonItem.
     */
    focus: () => void;
}

/**
 * Represents the props of the
 * [Kendo UI for Vue FloatingActionButtonItem component]({% slug overview_floatingactionbutton %}).
 */
export declare interface FloatingActionButtonItemProps {
    /**
     * Specifies if the Floating Action Button Item
     * is disabled [see example]({% slug disabled_floatingactionbuttonitem %}).
     * Defaults to `false`.
     */
    disabled?: boolean;
    /**
     * Sets the index of the Floating Action Button Item that is used to identify it.
     */
    index?: number;
    /**
     * Defines the icon rendered in the FloatingActionButtonItem
     * [see example]({% slug databinding_floatingactionbutton %}).
     */
    icon?: string;
    /**
     * Defines the svg icon in a Kendo UI for Vue theme.
     */
    svgIcon?: SVGIcon;
    /**
     * Specifies the text of the FloatingActionButtonItem
     * [see example]({% slug databinding_floatingactionbutton %}).
     */
    text?: string;
    /**
     * Sets the `tabIndex` property of the FloatingActionButtonItem..
     * Defaults to `0`.
     */
    tabIndex?: number;
    /**
     * Sets a custom property. Contained in the FloatingActionButtonItem props that are
     * returned from the `onItemClick` FloatingActionButton event
     * [see example]({% slug customization_floatingactionbutton %}#toc-items-rendering).
     */
    [customProp: string]: any;
    /**
     * @hidden
     */
    id?: string;
    /**
     * @hidden
     */
    class?: string;
    /**
     * @hidden
     */
    dataItem?: any;
    /**
     * @hidden
     */
    item?: any;
    /**
     * @hidden
     */
    focused?: boolean;
    /**
     * @hidden
     */
    onDown?: (event: any) => void;
    /**
     * @hidden
     */
    onClick?: (event: any, index: number) => void;
}

/**
 * Represents the settings that can be passed to the Popup inside the FloatingActionButtonPopupSettings.
 */
export declare interface FloatingActionButtonPopupSettings {
    /**
     * Controls the popup animation. By default, the open and close animations are enabled
     * [see example]({% slug customization_floatingactionbutton %}#toc-popup-behavior).
     */
    animate?: boolean | PopupAnimation;
    /**
     * Specifies a list of CSS classes that are used for styling the popup
     * [see example]({% slug customization_floatingactionbutton %}#toc-popup-behavior).
     */
    popupClass?: string;
    /**
     * @hidden
     */
    anchorAlign?: Align;
    /**
     * @hidden
     */
    popupAlign?: Align;
}

/**
 * Specifies the position mode of the Floating Action Button. It is based on the
 * [CSS position](https://developer.mozilla.org/en-US/docs/Web/CSS/position) rule.
 *
 * * The possible values are:
 * * 'absolute' (Default)
 * * 'fixed'
 */
export declare type FloatingActionButtonPositionMode = 'absolute' | 'fixed';

/**
 * Represents the props of the [Kendo UI for Vue
 *  FloatingActionButton component]({% slug overview_floatingactionbutton %}).
 */
export declare interface FloatingActionButtonProps extends Omit_2<any, 'onBlur' | 'onFocus' | 'onKeyDown' | 'onClick'> {
    /**
     * Specifies a list of CSS classes that will be added to the Floating Action Button.
     */
    className?: string;
    /**
     * Represents the `dir` HTML attribute. This is used to
     *  switch from LTR to RTL [see example]({% slug rtl_buttons %}).
     */
    dir?: string;
    /**
     * Sets the `id` property of the root HTML element.
     */
    id?: string;
    /**
     * Specifies if the Floating Action Button is
     *  disabled [see example]({% slug disabled_floatingactionbutton %}). Defaults to `false`.
     */
    disabled?: boolean;
    /**
     * If defined it specifies if the Floating Action Button is opened.
     */
    opened?: boolean;
    /**
     * Defines the icon rendered in the Floating Action
     *  Button [see example]({% slug contenttypes_floatingactionbutton %}).
     */
    icon?: string;
    /**
     * Defines the svg icon in a Kendo UI for Vue theme.
     */
    svgIcon?: SVGIcon;
    /**
     * Defines a CSS class or multiple classes separated by spaces which are applied
     * to a `span` element inside the Floating Action Button. Allows the usage of custom icons.
     */
    iconClass?: string;
    /**
     * Specifies the text of the Floating Action
     *  Button [see example]({% slug contenttypes_floatingactionbutton %}).
     */
    text?: string;
    /**
     * Specifies the horizontal and vertical offset applied to the Floating Action Button
     * [see example]({% slug positioning_floatingactionbutton %}).
     *
     * Normally, the floating button is positioned next to the boundaries of its container
     *  with a default offset of `16px`.
     *
     * Positive offsets move floating buttons, which are in a corner, further from that corner. Buttons, which are
     * not in a corner, can be moved along the container's boundary or towards the center of the container.
     *
     * A negative offset can be used to force a button to overflow the boundaries of its container.
     *
     * The possible keys are:
     * * `x`&mdash;Sets the horizontal offset of the Floating Action Button.
     * * `y`&mdash;Sets the vertical offset of the Floating Action Button.
     *
     */
    alignOffset?: FloatingActionButtonAlignOffset;
    /**
     * Specifies the horizontal and vertical alignment of the Floating Action Button in relation to the container
     * [see example]({% slug positioning_floatingactionbutton %}).
     *
     * > Centering the Floating Action Button in both horizontal and vertical dimension is not a typical use case.
     * Still, it is possible to achieve such a layout with appropriate offsets.
     * Setting horizontal: "center" and vertical: "middle"
     * at the same time is not supported.
     *
     * The possible keys are:
     * * `horizontal`&mdash; Defines the possible horizontal alignment of the Floating Action Button..
     *   * `start`&mdash;Uses the start point of the container.
     *   * `center`&mdash;Uses the center point of the container.
     *   * `end`(Default)&mdash;Uses the end point of the container
     * * `vertical`&mdash; Defines the possible vertical alignment of the Floating Action Button..
     *   * `top`&mdash;Uses the top point of the container.
     *   * `middle`&mdash;Uses the middle point of the container.
     *   * `bottom`(Default)&mdash;Uses the bottom point of the container.
     *
     */
    align?: FloatingActionButtonAlign;
    /**
     * Specifies the position mode of the Floating Action Button
     * [see example]({% slug positioning_floatingactionbutton %}). It is based on the
     * [CSS position](https://developer.mozilla.org/en-US/docs/Web/CSS/position) rule.
     *
     * * The possible values are:
     * * 'fixed' (Default)
     * * 'absolute'
     */
    positionMode?: FloatingActionButtonPositionMode;
    /**
     * Specifies the shape of the Floating Action Button
     * [see example]({% slug appearance_floatingactionbutton %}).
     *
     * The possible values are:
     * * `pill`(Default)&mdash;Applies border radius equal to half of the height of the FloatingActionButton.
     * If the Floating Action Button contains only icon, the shape will be circle.
     * * `circle`&mdash;Applies circle shape on the FloatingActionButton.
     * * `rectangle`&mdash;Applies no border radius on the FloatingActionButton.
     * * `rounded`&mdash;Applies default border radius on the FloatingActionButton.
     * * `square`&mdash;Applies square shape on the FloatingActionButton.
     *
     */
    shape?: null | 'rectangle' | 'square' | string;
    /**
     * Configures the `roundness` of the Floating Action Button.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - circle
     * - full
     * - null&mdash;Does not set a rounded `class`.
     *
     * @default `medium`
     */
    rounded?: null | 'small' | 'medium' | 'large' | 'full' | string;
    /**
     * Configures the `fillMode` of the Floating Action Button.
     *
     * The available options are:
     * - solid
     * - outline
     * - flat
     * - link
     * - null&mdash;Does not set a fillMode `class`.
     *
     * @default `solid`
     */
    fillMode?: null | 'solid' | 'outline' | 'flat' | 'link' | string;
    /**
     * Specifies the size of the Floating Action Button
     * [see example]({% slug appearance_floatingactionbutton %}).
     *
     * The possible values are:
     * * `small`&mdash;Applies half of the default padding, e.g. `8px`.
     * * `medium` (Default)&mdash;Applies the default padding, e.g. `16px`.
     * * `large`&mdash;Applies one and one half of the default padding, e.g. `24px`.
     *
     */
    size?: FloatingActionButtonSize;
    /**
     * Specifies the theme color of the Floating Action Button
     * [see example]({% slug appearance_floatingactionbutton %}).
     *
     * The possible values are:
     * * `primary` (Default)&mdash;Applies coloring based on the primary theme color.
     * * `secondary`&mdash;Applies coloring based on the secondary theme color.
     * * `tertiary`&mdash; Applies coloring based on the tertiary theme color.
     * * `info`&mdash;Applies coloring based on the info theme color.
     * * `success`&mdash; Applies coloring based on the success theme color.
     * * `warning`&mdash; Applies coloring based on the warning theme color.
     * * `error`&mdash; Applies coloring based on the error theme color.
     * * `dark`&mdash; Applies coloring based on the dark theme color.
     * * `light`&mdash; Applies coloring based on the light theme color.
     * * `inverse`&mdash; Applies coloring based on the inverse theme color.
     *
     */
    themeColor?: FloatingActionButtonThemeColor;
    /**
     * The collection of items that will be rendered in the Floating Action Button
     * [see example]({% slug databinding_floatingactionbutton %}).
     */
    items?: any;
    /**
     * Overrides the default component responsible for visualizing a single item
     * [see example]({% slug customization_floatingactionbutton %}#toc-items-rendering).
     *
     * The default Component is: [FloatingActionButtonItem]({% slug api_buttons_floatingactionbuttonitemprops %}).
     */
    item?: any;
    /**
     * Represents the additional props that will be passed to the Popup inside the Floating Action Button
     * [see example]({% slug customization_floatingactionbutton %}#toc-popup-behavior).
     */
    popupSettings?: FloatingActionButtonPopupSettings;
    /**
     * Specifies the `tabIndex` of the main button.
     */
    tabIndex?: number;
    /**
     * Specifies the `accessKey` of the main button.
     */
    accessKey?: string;
    /**
     * Fires when the Floating Action Button is focused
     * [see example]({% slug overview_floatingactionbutton %}#toc-events).
     */
    onFocus?: (event: FloatingActionButtonEvent) => void;
    /**
     * Fires when the Floating Action Button is blurred
     * [see example]({% slug overview_floatingactionbutton %}#toc-events).
     */
    onBlur?: (event: FloatingActionButtonEvent) => void;
    /**
     * Fires when the Floating Action Button is clicked.
     */
    onClick?: (event: FloatingActionButtonEvent) => void;
    /**
     * Fires when the Floating Action Button Item is clicked
     * [see example]({% slug overview_floatingactionbutton %}#toc-events).
     */
    onItemclick?: (event: FloatingActionButtonItemEvent) => void;
    /**
     * Triggers onKeyDown event
     * [see example]({% slug overview_floatingactionbutton %}#toc-events).
     */
    onKeydown?: (event: FloatingActionButtonEvent) => void;
    /**
     * Triggers onMousedown event
     * [see example]({% slug overview_floatingactionbutton %}#toc-events).
     */
    onMousedown?: (event: FloatingActionButtonEvent) => void;
    /**
     * Triggers onMouseup event
     * [see example]({% slug overview_floatingactionbutton %}#toc-events).
     */
    onMouseup?: (event: FloatingActionButtonEvent) => void;
    /**
     * Fires when the popup which contains the items is opened
     * [see example]({% slug overview_floatingactionbutton %}#toc-events).
     */
    onOpen?: (event: FloatingActionButtonEvent) => void;
    /**
     * Fires when the popup which contains the items is closed
     * [see example]({% slug overview_floatingactionbutton %}#toc-events).
     */
    onClose?: (event: FloatingActionButtonEvent) => void;
}

/**
 * Specifies the shape of the Floating Action Button.
 *
 * The possible values are:
 * * `full`(Default)&mdash;Applies border radius equal to half of the height of the FloatingActionButton.
 * If the Floating Action Button contains only icon, the shape will be circle.
 * * `circle`&mdash;Applies circle shape on the FloatingActionButton.
 * * `rectangle`&mdash;Applies no border radius on the FloatingActionButton.
 * * `rounded`&mdash;Applies default border radius on the FloatingActionButton.
 * * `square`&mdash;Applies square shape on the FloatingActionButton.
 *
 */
export declare type FloatingActionButtonShape = 'rectangle' | 'rounded' | 'pill' | 'circle' | 'square';

/**
 * Specifies the size of the Floating Action Button.
 *
 * The possible values are:
 * * `small`&mdash;Applies half of the default padding, e.g. `8px`.
 * * `medium` (Default)&mdash;Applies the default padding, e.g. `16px`.
 * * `large`&mdash;Applies one and one half of the default padding, e.g. `24px`.
 *
 */
export declare type FloatingActionButtonSize = 'small' | 'medium' | 'large';

/**
 * Specifies the theme color of the Floating Action Button..
 *
 * The possible values are:
 * * `primary` (Default)&mdash;Applies coloring based on the primary theme color.
 * * `secondary`&mdash;Applies coloring based on the secondary theme color.
 * * `tertiary`&mdash; Applies coloring based on the tertiary theme color.
 * * `info`&mdash;Applies coloring based on the info theme color.
 * * `success`&mdash; Applies coloring based on the success theme color.
 * * `warning`&mdash; Applies coloring based on the warning theme color.
 * * `error`&mdash; Applies coloring based on the error theme color.
 * * `dark`&mdash; Applies coloring based on the dark theme color.
 * * `light`&mdash; Applies coloring based on the light theme color.
 * * `inverse`&mdash; Applies coloring based on the inverse theme color.
 *
 */
export declare type FloatingActionButtonThemeColor = 'primary' | 'secondary' | 'tertiary' | 'info' | 'success' | 'warning' | 'error' | 'dark' | 'light' | 'inverse';

/**
 * @hidden
 */
declare type Omit_2<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

/**
 * Represents a single recognition alternative from the speech engine.
 */
declare interface SpeechRecognitionAlternative_2 {
    /**
     * The transcript of the recognized speech.
     */
    transcript: string;
    /**
     * A confidence score for the transcript, where 0 indicates no confidence and 1 indicates complete confidence.
     */
    confidence: number;
}
export { SpeechRecognitionAlternative_2 as SpeechRecognitionAlternative }

/**
 * @hidden
 */
export declare const SpeechToTextButton: DefineComponent<ExtractPropTypes<    {
lang: {
type: PropType<string>;
default: string;
};
continuous: {
type: PropType<boolean>;
default: boolean;
};
interimResults: {
type: PropType<boolean>;
default: boolean;
};
maxAlternatives: {
type: PropType<number>;
default: number;
};
integrationMode: {
type: PropType<"WebSpeech" | "None">;
default: SpeechToTextButtonMode;
};
onStart: {
type: PropType<() => void>;
};
onResult: {
type: PropType<(event: SpeechToTextResultEvent) => void>;
};
onEnd: {
type: PropType<() => void>;
};
onError: {
type: PropType<(event: SpeechToTextErrorEvent) => void>;
};
svgIcon: {
type: PropType<SVGIcon>;
default: SVGIcon_2;
};
iconSize: {
type: PropType<string>;
default: string;
};
disabled: {
type: PropType<boolean>;
default: any;
};
size: {
type: PropType<string>;
default: string;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
};
themeColor: {
type: PropType<string>;
default: string;
};
title: {
type: PropType<string>;
default: string;
};
ariaLabel: {
type: PropType<string>;
default: string;
};
}>, {
clickHandler: () => void;
isInActiveState: Ref<boolean, boolean>;
}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
lang: {
type: PropType<string>;
default: string;
};
continuous: {
type: PropType<boolean>;
default: boolean;
};
interimResults: {
type: PropType<boolean>;
default: boolean;
};
maxAlternatives: {
type: PropType<number>;
default: number;
};
integrationMode: {
type: PropType<"WebSpeech" | "None">;
default: SpeechToTextButtonMode;
};
onStart: {
type: PropType<() => void>;
};
onResult: {
type: PropType<(event: SpeechToTextResultEvent) => void>;
};
onEnd: {
type: PropType<() => void>;
};
onError: {
type: PropType<(event: SpeechToTextErrorEvent) => void>;
};
svgIcon: {
type: PropType<SVGIcon>;
default: SVGIcon_2;
};
iconSize: {
type: PropType<string>;
default: string;
};
disabled: {
type: PropType<boolean>;
default: any;
};
size: {
type: PropType<string>;
default: string;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
};
themeColor: {
type: PropType<string>;
default: string;
};
title: {
type: PropType<string>;
default: string;
};
ariaLabel: {
type: PropType<string>;
default: string;
};
}>> & Readonly<{}>, {
title: string;
ariaLabel: string;
themeColor: string;
size: string;
rounded: string;
fillMode: string;
iconSize: string;
svgIcon: SVGIcon;
disabled: boolean;
lang: string;
continuous: boolean;
interimResults: boolean;
maxAlternatives: number;
integrationMode: "WebSpeech" | "None";
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

export declare enum SpeechToTextButtonMode {
    WebSpeech = "WebSpeech",
    None = "None"
}

export declare interface SpeechToTextButtonProps extends Omit<ButtonProps, 'shape'> {
    /**
     * The valid BCP 47 language tag to use for speech recognition. Defaults to `en-US`.
     */
    lang?: string;
    /**
     * Specifies whether the speech recognition should continue until explicitly stopped. Defaults to `true`.
     */
    continuous?: boolean;
    /**
     * Specifies whether to return interim results. Defaults to `false`.
     */
    interimResults?: boolean;
    /**
     * Specifies the maximum number of alternative transcriptions to return. Defaults to `1`.
     */
    maxAlternatives?: number;
    /**
     * Specifies which speech recognition engine or integration the component should use.
     * This allows the component to operate in different environments or use alternative implementations.
     */
    integrationMode?: 'WebSpeech' | 'None';
    /**
     * Callback function that is called when speech recognition starts.
     */
    onStart?: () => void;
    /**
     * Callback function that is called when a speech recognition result is available.
     * The event contains the `isFinal` flag and an array of alternatives.
     */
    onResult?: (event: SpeechToTextResultEvent) => void;
    /**
     * Callback function that is called when speech recognition ends.
     */
    onEnd?: () => void;
    /**
     * Callback function that is called when an error occurs during speech recognition.
     */
    onError?: (event: SpeechToTextErrorEvent) => void;
    /**
     * The `start` event callback that starts the speech recognition service listening to incoming audio with intent to recognize grammars.
     *
     * @memberof SpeechToTextButtonProps
     */
    start(): void;
    /**
     * The `stop` event callback that stops the speech recognition service from listening to incoming audio, and attempts to return a result using the audio captured so far.
     *
     * @memberof SpeechToTextButtonProps
     */
    stop(): void;
    /**
     * The `abort` event callback that stops the speech recognition service from listening to incoming audio, and doesn't attempt to return a result.
     *
     * @memberof SpeechToTextButtonProps
     */
    abort(): void;
    /**
     * The `isActive` event callback that returns a boolean value if the SpeechToTextButton is in an active state.
     *
     * @returns `true` if the speech recognition is active, otherwise `false`.
     */
    isActive(): boolean;
}

/**
 * The event argument for the `error` event of the SpeechToTextButton.
 */
export declare interface SpeechToTextErrorEvent {
    /**
     * Message detailing the cause of the speech recognition error. Use this message for debugging or user feedback.
     */
    errorMessage: string;
}

/**
 * The event argument for the `result` event of the SpeechToTextButton.
 */
export declare interface SpeechToTextResultEvent {
    /**
     * Indicates whether the speech recognition result is final (`true`) or interim (`false`).
     */
    isFinal: boolean;
    /**
     * An array of possible recognition alternatives returned by the speech engine.
     */
    alternatives: SpeechRecognitionAlternative_2[];
}

/**
 * @hidden
 */
export declare const SplitButton: DefineComponent<ExtractPropTypes<    {
accessKey: PropType<string>;
ariaLabel: PropType<string>;
text: PropType<string>;
items: {
type: PropType<any[]>;
default: () => any[];
};
textField: PropType<string>;
tabIndex: PropType<number>;
disabled: PropType<boolean>;
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
size: {
type: PropType<string>;
default: string;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
themeColor: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
opened: {
type: PropType<boolean>;
default: any;
};
iconClass: PropType<string>;
imageUrl: PropType<string>;
popupSettings: PropType<ButtonsPopupSettings_2>;
itemRender: PropType<any>;
item: PropType<any>;
className: PropType<string>;
buttonClass: PropType<string>;
dir: PropType<string>;
}>, {
kendoAnchorRef: Ref<any, any>;
}, {
focused: boolean;
focusedIndex: number;
currentOpened: boolean;
}, {
computedOpened(): boolean;
wrapperClass(): {
'k-split-button': boolean;
'k-button-group': boolean;
'k-focus': any;
};
}, {
element(): HTMLButtonElement | null;
onKeyDown(event: any): void;
onFocus(event: FocusEvent): void;
onItemClick(event: any, clickedItemIndex: number): void;
onBlur(event: FocusEvent): void;
createBlurTimeout(event: FocusEvent): void;
dispatchClickEvent(dispatchedEvent: any, clickedItemIndex: number): void;
onSplitPartClick(event: any): void;
onDownSplitPart(event: any): void;
onItemDown(event: any): void;
dispatchPopupEvent(dispatchedEvent: any, open?: boolean): void;
isItemDisabled(index: number): any;
isRtl(): boolean;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
focus: (event: SplitButtonFocusEvent) => true;
blur: (event: SplitButtonBlurEvent) => true;
buttonclick: (event: SplitButtonClickEvent) => true;
itemclick: (event: SplitButtonItemClickEvent) => true;
open: (event: SplitButtonOpenEvent) => true;
close: (event: SplitButtonCloseEvent) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
accessKey: PropType<string>;
ariaLabel: PropType<string>;
text: PropType<string>;
items: {
type: PropType<any[]>;
default: () => any[];
};
textField: PropType<string>;
tabIndex: PropType<number>;
disabled: PropType<boolean>;
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
size: {
type: PropType<string>;
default: string;
};
rounded: {
type: PropType<string>;
default: string;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
themeColor: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
opened: {
type: PropType<boolean>;
default: any;
};
iconClass: PropType<string>;
imageUrl: PropType<string>;
popupSettings: PropType<ButtonsPopupSettings_2>;
itemRender: PropType<any>;
item: PropType<any>;
className: PropType<string>;
buttonClass: PropType<string>;
dir: PropType<string>;
}>> & Readonly<{
onBlur?: (event: SplitButtonBlurEvent) => any;
onClose?: (event: SplitButtonCloseEvent) => any;
onFocus?: (event: SplitButtonFocusEvent) => any;
onOpen?: (event: SplitButtonOpenEvent) => any;
onItemclick?: (event: SplitButtonItemClickEvent) => any;
onButtonclick?: (event: SplitButtonClickEvent) => any;
}>, {
themeColor: string;
size: string;
rounded: string;
fillMode: string;
items: any[];
opened: boolean;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The arguments for the `blur` event.
 */
export declare interface SplitButtonBlurEvent {
    /**
     * The native browser blur event (FocusEvent).
     */
    event: FocusEvent;
}

/**
 * The arguments for the `buttonclick` event.
 */
export declare interface SplitButtonClickEvent {
    /**
     * The native browser event.
     */
    event: any;
}

/**
 * The arguments for the `close` event.
 */
export declare interface SplitButtonCloseEvent {
    /**
     * The native browser event.
     */
    event: any;
}

/**
 * The arguments for the `focus` event.
 */
export declare interface SplitButtonFocusEvent {
    /**
     * The native browser focus event.
     */
    event: FocusEvent;
}

/**
 * The arguments for the `itemClick` event.
 */
export declare interface SplitButtonItemClickEvent {
    /**
     * The clicked item.
     */
    item: any;
    /**
     * The zero-based index of the clicked item.
     */
    itemIndex: number;
}

/**
 * The arguments for the `open` event.
 */
export declare interface SplitButtonOpenEvent {
    /**
     * The native browser event.
     */
    event: any;
}

/**
 * @hidden
 */
export declare const Toolbar: DefineComponent<ExtractPropTypes<    {
tabIndex: {
type: PropType<number>;
default: number;
};
dir: {
type: PropType<string>;
validator: (value: any) => any;
default: string;
};
keyboardNavigation: {
type: PropType<boolean>;
default: boolean;
};
buttons: {
type: PropType<string[]>;
default: () => any;
};
size: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
ariaLabel: PropType<string>;
overflow: {
type: PropType<"section" | "scroll" | "none">;
default: string;
validator: (value: any) => any;
};
scrollButtons: {
type: PropType<"auto" | "hidden" | "visible">;
default: string;
validator: (value: any) => any;
};
scrollButtonsPosition: {
type: PropType<"split" | "end" | "start">;
default: string;
validator: (value: any) => any;
};
buttonScrollSpeed: {
type: PropType<number>;
default: number;
};
}>, {}, {
defaultSlot: any;
offsetWidth: number;
offsetHeight: number;
currentButtons: HTMLElement[];
focusedSelector: string;
isScrollStartPosition: boolean;
isScrollEndPosition: boolean;
focusableButtons: any[];
isOverflowing: boolean;
scrollContentRef: any;
lastToolbarWidthRef: number;
overFlowToolsRef: any[];
overFlowOpened: boolean;
visibleToolsRef: any;
}, {
selectors(): ToolbarComputed['selectors'];
wrapperClass(): ToolbarComputed['wrapperClass'];
}, {
getCurrentButtons(): HTMLElement[];
getInternalButtons(): HTMLElement[];
focusedIndex(): number;
setTabIndex(focusedIndex: number): void;
onKeyDown(event: any): void;
focusButton(prevIndex: number, index: number): void;
initOverflow(toolbarRef: any, totalInnerWidth: any): void;
checkOverflow(): void;
onWindowResize(event: any): void;
onContentScroll(buttonClicked: any): void;
onToggleoverflow(opened: boolean): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
resize: (event: ToolbarResizeEvent) => true;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
tabIndex: {
type: PropType<number>;
default: number;
};
dir: {
type: PropType<string>;
validator: (value: any) => any;
default: string;
};
keyboardNavigation: {
type: PropType<boolean>;
default: boolean;
};
buttons: {
type: PropType<string[]>;
default: () => any;
};
size: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
fillMode: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
ariaLabel: PropType<string>;
overflow: {
type: PropType<"section" | "scroll" | "none">;
default: string;
validator: (value: any) => any;
};
scrollButtons: {
type: PropType<"auto" | "hidden" | "visible">;
default: string;
validator: (value: any) => any;
};
scrollButtonsPosition: {
type: PropType<"split" | "end" | "start">;
default: string;
validator: (value: any) => any;
};
buttonScrollSpeed: {
type: PropType<number>;
default: number;
};
}>> & Readonly<{
onResize?: (event: ToolbarResizeEvent) => any;
}>, {
tabIndex: number;
size: string;
fillMode: string;
dir: string;
keyboardNavigation: boolean;
buttons: string[];
buttonScrollSpeed: number;
scrollButtons: "auto" | "hidden" | "visible";
scrollButtonsPosition: "split" | "end" | "start";
overflow: "section" | "scroll" | "none";
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
declare interface ToolbarComputed {
    [key: string]: any;
    selectors: string[];
    wrapperClass: object;
}

/**
 * @hidden
 */
export declare const ToolbarItem: DefineComponent<    {}, {}, {}, {}, {
element(): any;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
declare interface ToolbarOverflowProps {
    /**
     * Represents the possible overflow mode options of the Toolbar.
     * Applicable when there is not enough space to render all tools.
     *
     * @default `section`
     */
    overflow?: 'none' | 'section' | 'scroll';
    /**
     * Determines the Toolbar scroll buttons visibility.
     * Applicable when the overflow property is set to `scroll`.
     *
     * @default `auto`
     */
    scrollButtons?: 'hidden' | 'visible' | 'auto';
    /**
     * Determines the Toolbar scroll buttons position.
     * Applicable when the overflow property is set to `scroll`.
     *
     * @default `split`
     */
    scrollButtonsPosition?: 'start' | 'end' | 'split';
    /**
     * Sets the Toolbar scroll speed in pixels when scrolling via clicking the previous or next button.
     * Applicable when the overflow property is set to `scroll`.
     *
     * @default 100
     */
    buttonScrollSpeed?: number;
    /**
     * Defines the custom component that will be rendered as a previous button.
     */
    prevButton?: any;
    /**
     * Defines the custom component that will be rendered as a next button.
     */
    nextButton?: any;
}

/**
 * Represents the props of the [Kendo UI for Vue Toolbar component]({% slug overview_toolbar %}).
 */
export declare interface ToolbarProps extends ToolbarOverflowProps {
    /**
     * Sets additional classes to the Toolbar.
     */
    className?: string;
    /**
     * Represents the `dir` HTML attribute.
     */
    dir?: string | undefined;
    /**
     * Specifies the `tabIndex` of the Toolbar.
     */
    tabIndex?: number;
    /**
     * The `resize` event of the Toolbar.
     */
    onResize?: (event: ToolbarResizeEvent) => void;
    /**
     * If set to `false`, it will turn off the built-in keyboard navigation.
     */
    keyboardNavigation?: boolean;
    /**
     * @hidden
     *
     * The CSS selectors of the toolbar HTML elements used by built-in keyboard navigation.
     * Each selector needs to point to a focusable element.
     * Defaults to [
     *  'button',
     *  '.k-button-group > button',
     *  '.k-dropdown > .k-dropdown-wrap',
     *  '.k-colorpicker > .k-picker-wrap'
     * ].
     */
    buttons?: string[];
    /**
     * Configures the `size` of the Toolbar.
     *
     * The available options are:
     * - `small`&mdash;sets the padding of the component to 4px 4px
     * - `medium`&mdash;sets the padding of the component to 8px 8px
     * - `large`&mdash;sets the padding of the component to 10px 10px
     * - `null`&mdash;removes the styling related to the Toolbar sizing option
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large' | string;
    /**
     * Configures the `fillMode` of the Toolbar.
     *
     * The available options are:
     * - solid&mdash;Applies a `background` color and `solid borders`.
     * - flat&mdash;Sets a `transparent background` and `solid bottom border`.
     * - outline&mdash;Sets a `transparent background` and `solid borders`.
     * - null&mdash;This option removes the built-in fill mode styles of the Toolbar. Allows for custom `background` and `border` styles.
     *
     * @default `solid`
     */
    fillMode?: null | 'solid' | 'flat' | 'outline' | string;
    /**
     * Defines the `aria-label` HTML attribute of the Toolbar.
     */
    ariaLabel?: string;
}

/**
 * Represents the `resize` event of the Toolbar.
 */
export declare interface ToolbarResizeEvent {
    /**
     * An event target.
     */
    target: any;
    /**
     * The `offsetWidth` event of the Toolbar.
     */
    offsetWidth: number;
    /**
     * The `offsetHeight` event of the Toolbar.
     */
    offsetHeight: number;
    /**
     * A native DOM event.
     */
    nativeEvent: any;
}

/**
 * Represents the [Kendo UI for Vue ToolbarSeparator component]({% slug overview_toolbar %}).  A separator element for the sub-elements of the Toolbar.
 *
 * ```jsx
 * <template>
 *   <div>
 *     <Toolbar>
 *       <SplitButton
 *         :class="'k-toolbar-split-button'"
 *         :text="'Insert'"
 *         :items="splitItems"
 *       >
 *       </SplitButton>
 *       <ToolbarSeparator />
 *       <DropDownButton
 *         :text="'Paste'"
 *         :svg-icon="clipboardIcon"
 *         :items="ddItems"
 *       >
 *       </DropDownButton>
 *     </Toolbar>
 *   </div>
 * </template>
 * ```
 */
export declare const ToolbarSeparator: DefineComponent<    {}, {}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * Represents the [Kendo UI for Vue ToolbarSpacer component]({% slug overview_toolbar %}).  A spacer element for the sub-elements of the Toolbar.
 *
 * ```jsx
 * <template>
 *  <div>
 *    <Toolbar>
 *      <ButtonGroup :class="'k-toolbar-button-group'">
 *        <Button
 *          :class="'k-toolbar-button'"
 *          :svg-icon="boldIcon"
 *          :title="'Bold'"
 *          :togglable="true"
 *        />
 *        <Button
 *          :class="'k-toolbar-button'"
 *          :svg-icon="italicIcon"
 *          :title="'Italic'"
 *          :togglable="true"
 *        />
 *        <Button
 *          :class="'k-toolbar-button'"
 *          :svg-icon="underlineIcon"
 *          :title="'Underline'"
 *          :togglable="true"
 *        />
 *      </ButtonGroup>
 *      <ToolbarSpacer />
 *      <Button :class="'k-toolbar-button'" :svg-icon="cutIcon" :title="'Cut'">
 *        Cut
 *      </Button>
 *      <Button :class="'k-toolbar-button'" :svg-icon="copyIcon" :title="'Copy'">
 *        Copy
 *      </Button>
 *    </Toolbar>
 *  </div>
 * </template>
 * ```
 */
export declare const ToolbarSpacer: DefineComponent<    {}, {}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

export { }
