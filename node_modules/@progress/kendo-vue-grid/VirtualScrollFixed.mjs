/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
class c {
  constructor(t = 0, i, h, e) {
    this.total = t, this.offsets = [], this.heights = [];
    let s = 0;
    for (let a = 0; a < t; a++) {
      this.offsets.push(s);
      const r = e && e[a].expanded && e[a].rowType === "data" ? h : i;
      s += r, this.heights.push(r);
    }
  }
  height(t) {
    return this.heights[t];
  }
  index(t) {
    if (t < 0)
      return;
    const i = this.offsets.reduce(
      (h, e, s) => {
        if (h !== void 0)
          return h;
        if (e === t)
          return s;
        if (e > t)
          return s - 1;
      },
      void 0
    );
    return i === void 0 ? this.total - 1 : i;
  }
  offset(t) {
    return this.offsets[t];
  }
  totalHeight() {
    const t = this.offsets[this.offsets.length - 1], i = this.heights[this.heights.length - 1];
    return t + i;
  }
}
class d {
  constructor(t) {
    this.table = null, this.containerHeight = 0, this.topCacheCount = 0, this.attendedSkip = 0, this.propsSkip = 0, this.total = 0, this.scrollableVirtual = !1, this.realSkip = 0, this.pageSize = 0, this.PageChange = null, this.fixedScroll = !1, this.askedSkip = void 0, this.tableTransform = "", this.scrollSyncing = !1, this.lastLoaded = 0, this.firstLoaded = 0, this.lastScrollTop = 0, this.firstLoaded = this.pageSize, this.lastLoaded = this.realSkip + this.pageSize, this.scrollHandler = this.scrollHandler.bind(this);
  }
  get container() {
    return this.containerRef;
  }
  translate(t) {
    this.scrollableVirtual && this.table && (this.table.style.transform = "translateY(" + t + "px)");
  }
  changePage(t, i) {
    this.PageChange && this.PageChange({ skip: Math.max(0, t), take: this.pageSize }, i);
  }
  reset() {
    this.scrollSyncing = !0, !this.fixedScroll && (this.container && (this.container.scrollTop = 0), this.translate(0));
  }
  scrollHandler(t) {
    if (!this.scrollableVirtual || !this.container || !this.table || !this.rowHeightService || !this.containerRef)
      return;
    if (this.scrollSyncing) {
      this.scrollSyncing = !1;
      return;
    }
    const i = this.container.scrollTop, h = this.lastScrollTop >= i, e = !h;
    this.lastScrollTop = i;
    let s = this.rowHeightService.index(i), a = this.rowHeightService.offset(s);
    const { offsetHeight: r } = this.containerRef, n = this.rowHeightService.index(i + r);
    if (e && n >= this.lastLoaded && this.lastLoaded < this.total) {
      const o = s + this.pageSize - this.total;
      o > 0 && (s = s - o, a = this.rowHeightService.offset(s)), this.firstLoaded = s, this.translate(a);
      const f = this.firstLoaded + this.pageSize;
      this.lastLoaded = Math.min(f, this.total), this.changePage(this.firstLoaded, t);
    } else if (h && s < this.firstLoaded) {
      const o = Math.floor(this.pageSize * 0.3);
      this.firstLoaded = Math.max(s - o, 0), this.translate(this.rowHeightService.offset(this.firstLoaded)), this.lastLoaded = Math.min(this.firstLoaded + this.pageSize, this.total), this.changePage(this.firstLoaded, t);
    }
  }
}
export {
  c as RowHeightService,
  d as VirtualScrollFixed
};
