/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { defineComponent as A, createVNode as r, isVNode as F } from "vue";
import { normalize as z } from "../interfaces/GridSortSettings.mjs";
import { ColumnResizer as v } from "../drag/ColumnResizer.mjs";
import { ColumnDraggable as B } from "../drag/ColumnDraggable.mjs";
import { GridHeaderCell as K } from "./GridHeaderCell.mjs";
import { ColumnMenu as V } from "../columnMenu/ColumnMenu.mjs";
import { noop as N, templateRendering as T, getListeners as _, Keys as H, hasListener as P, Icon as E } from "@progress/kendo-vue-common";
import { HeaderThElement as q } from "@progress/kendo-vue-data-tools";
import { sortableColumnAriaLabel as S, messages as C, sortableColumnAscendingAriaLabel as y, sortableColumnDescendingAriaLabel as M } from "../messages/main.mjs";
import { provideLocalizationService as G } from "@progress/kendo-vue-intl";
import { sortAscSmallIcon as U, sortDescSmallIcon as J } from "@progress/kendo-svg-icons";
function $(t) {
  return typeof t == "function" || Object.prototype.toString.call(t) === "[object Object]" && !F(t);
}
const k = {
  none: "none",
  asc: "ascending",
  desc: "descending"
}, Q = {
  true: {
    asc: "desc",
    desc: "",
    "": "asc"
  },
  false: {
    asc: "desc",
    desc: "asc",
    "": "asc"
  }
}, ae = /* @__PURE__ */ A({
  name: "KendoHeaderRow",
  props: {
    grid: Object,
    cellRender: [String, Function, Object],
    groupable: [Boolean, Object],
    reorderable: Boolean,
    sortable: [Boolean, Object],
    sort: {
      type: Array
    },
    filter: Object,
    filterable: Boolean,
    filterOperators: Object,
    filterChange: Function,
    filterRow: Object,
    columns: Array,
    columnsMap: Array,
    columnResize: Object,
    columnMenu: [Boolean, String, Function, Object],
    columnMenuAnimate: {
      type: [Boolean, Object],
      default: function() {
        return !0;
      }
    },
    columnMenuIcon: Object,
    isRtl: Boolean,
    isColCountDefined: Boolean,
    // columnsInitial prop:
    // Needed for hidden column scenarios. By this value we can define correct aria-colindex attribute
    columnsInitial: Array,
    onSortChange: Function,
    onFilterChange: Function,
    onSelectionchange: Function,
    onPressHandler: Function,
    onDragHandler: Function,
    onReleaseHandler: Function
  },
  inject: {
    onNavFocus: {
      default: N
    },
    kendoLocalizationService: {
      default: null
    }
  },
  data() {
    return {
      columnMenuOpened: {}
    };
  },
  created() {
    this.serviceIndex = 0, this.index = -1, this._element = null, this.cellClick = this.cellClick.bind(this);
  },
  methods: {
    pressHandler(t, n) {
      this.$emit("pressHandler", t, n);
    },
    dragHandler(t, n) {
      this.$emit("dragHandler", t, n);
    },
    releaseHandler(t) {
      this.$emit("releaseHandler", t);
    },
    selectionChangeHandler(t) {
      this.$emit("selectionchange", t);
    },
    cellClick(t, n) {
      if (t.preventDefault(), !P.call(this, "sortChange"))
        return;
      const {
        allowUnsort: u,
        mode: h
      } = z(this.$props.sortable || !1, n.sortable || !1), o = (this.$props.sort || []).filter((a) => a.field === n.field)[0], s = Q[u][o && o.dir || ""], i = h === "single" ? [] : (this.$props.sort || []).filter((a) => a.field !== n.field);
      s !== "" && n.field && i.push({
        field: n.field,
        dir: s
      }), this.sortChangeHandler(i, {
        event: t,
        field: n.field
      });
    },
    sortChangeHandler(t, n) {
      this.$emit("sortChange", t, n);
    },
    filterChangeHandler(t, n) {
      this.$emit("filterChange", t, n);
    },
    cellClass(t, n, u) {
      const h = n ? " " + n : "";
      let o = "k-header" + (u ? " k-grid-header-sticky" : "") + h;
      return this.$props.sort && this.$props.sort.filter((s) => s.field === t).length > 0 && (o += " k-sorted"), o;
    },
    cellKeyDown(t, n) {
      t.defaultPrevented || (t.keyCode === H.enter && this.cellClick(t, n), t.altKey && t.keyCode === H.down && n.field && (t.preventDefault(), this.columnMenuOpened = {
        [n.field]: !0
      }));
    },
    getTemplate(t) {
      return T.call(this.$props.grid, t, _.call(this.$props.grid));
    },
    columnMenuClose() {
      this.onNavFocus({}), this.columnMenuOpened = {};
    }
  },
  computed: {
    element() {
      return this._element;
    },
    theadClasses() {
      return {
        "k-table-thead": !0
      };
    }
  },
  render(t) {
    const n = G(this), u = n.toLanguageString(S, C[S]), h = n.toLanguageString(y, C[y]), o = n.toLanguageString(M, C[M]);
    this.serviceIndex = 0, this.index = -1;
    const s = function(i) {
      return i.map(function(a) {
        const e = this.$props.columns[a], f = this.$props.sortable && e.sortable, g = this.$props.sort ? this.$props.sort.findIndex((l) => l.field === e.field) : -1, b = g >= 0 && this.$props.sort[g].dir || "none", d = function(l) {
          if (!this.$props.sort)
            return null;
          const m = l >= 0 ? this.$props.sort[l].dir : "";
          return l >= 0 && [r("span", {
            key: 1,
            class: "k-sort-icon"
          }, [r(E, {
            name: "sort-" + m + "-small",
            icon: m === "asc" ? U : J
          }, null)]), this.$props.sort.length > 1 && r("span", {
            key: 2,
            class: "k-sort-icon"
          }, [r("span", {
            class: "k-sort-order"
          }, [l + 1])])];
        }.call(this, g), c = e.columnMenu || e.columnMenu === !1 ? e.columnMenu : this.$props.columnMenu, R = e.menuIcon || this.$props.columnMenuIcon, O = (e.kFirst ? "k-first " : "") + this.cellClass(e.field, e.headerClassName, e.locked) + (c ? " k-filterable" : ""), I = !c || typeof c == "boolean" ? !!c : this.getTemplate(c), L = e.left !== void 0 ? this.$props.isRtl ? {
          left: e.right + "px",
          right: e.left + "px"
        } : {
          left: e.left + "px",
          right: e.right + "px"
        } : {}, D = k[b] === "none" ? u : k[b] === "ascending" ? h : o;
        let p = e.isAccessible ? {
          ariaSort: k[b],
          ariaLabel: D,
          role: "columnheader",
          ariaColumnIndex: this.$props.isColCountDefined ? this.$props.columnsInitial.findIndex((l) => l.field === e.field) + 1 : void 0,
          ariaSelected: !1,
          ariaHaspopup: c ? "menu" : this.$props.filterable && e.filterable ? "dialog" : void 0
        } : {
          role: "columnheader"
        };
        const j = e.declarationIndex >= 0 ? ++this.index : --this.serviceIndex, w = e.columnMenuOpened !== void 0 ? e.columnMenuOpened : this.columnMenuOpened[e.field];
        return r(q, {
          ariaSort: f ? p.ariaSort : void 0,
          ariaLabel: f ? p.ariaLabel : void 0,
          role: p.role,
          ariaColumnIndex: p.ariaColumnIndex,
          ariaSelected: p.ariaSelected,
          ariaHaspopup: p.ariaHaspopup,
          key: j,
          colSpan: e.colSpan,
          rowSpan: e.rowSpan,
          class: O,
          style: L,
          columnId: e.id,
          navigatable: e.navigatable,
          onKeydown: (l) => this.cellKeyDown(l, e)
        }, {
          default: () => [[e.children.length === 0 && c && r(V, {
            key: 0,
            column: {
              field: e.field,
              filter: e.filter
            },
            opened: w,
            animate: this.$props.columnMenuAnimate,
            sortable: f,
            sort: this.$props.sort,
            onClose: this.columnMenuClose,
            onSortchange: this.sortChangeHandler,
            filter: this.$props.filter,
            filterable: this.$props.filterable && e.filterable,
            filterOperators: this.$props.filterOperators,
            onFilterchange: this.filterChangeHandler,
            render: I,
            columnMenuIcon: R
          }, null), e.internalHeaderCell && r("span", {
            class: "k-cell-inner"
          }, [r(e.internalHeaderCell, {
            key: 1,
            field: e.field,
            sortable: f,
            onHeadercellclick: (l) => this.cellClick(l, e),
            onSelectionchange: this.selectionChangeHandler,
            selectionValue: e.headerSelectionValue,
            title: e.title,
            render: (e.headerCell || this.$props.cellRender) && this.getTemplate(e.headerCell || this.$props.cellRender)
          }, $(d) ? d : {
            default: () => [d]
          })]) || r("span", {
            class: "k-cell-inner"
          }, [r(K, {
            key: 1,
            field: e.field,
            sortable: f,
            onHeadercellclick: (l) => this.cellClick(l, e),
            selectionValue: e.headerSelectionValue,
            title: e.title,
            render: (e.headerCell || this.$props.cellRender) && this.getTemplate(e.headerCell || this.$props.cellRender)
          }, $(d) ? d : {
            default: () => [d]
          })]), this.$props.columnResize && this.$props.columnResize.resizable && e.resizable && r(v, {
            key: 2,
            onResize: (l, m, x) => this.$props.columnResize && this.$props.columnResize.dragHandler(l, e, m, x)
          }, null)]]
        });
      }, this);
    };
    return r("thead", {
      role: "rowgroup",
      class: this.theadClasses,
      "data-keyboardnavheader": !0
    }, [this.$props.columnsMap.map(function(i, a) {
      let e;
      return (this.$props.groupable || this.$props.reorderable) && r(B, {
        key: a,
        onPressHandler: this.pressHandler,
        onDragHandler: this.dragHandler,
        onReleaseHandler: this.releaseHandler
      }, $(e = s.call(this, i)) ? e : {
        default: () => [e]
      }) || r("tr", {
        class: "k-table-row",
        role: "row",
        "aria-rowindex": this.columnsMap.length
      }, [s.call(this, i)]);
    }, this), this.$props.filterRow]);
  }
});
export {
  ae as HeaderRow
};
