/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
class a {
  constructor(l) {
    this.resizable = !1, this.isRtl = !1, this.setIsRtl = (h) => {
      this.isRtl = h;
    }, this.onResize = l, this.dragHandler = this.dragHandler.bind(this);
  }
  dragHandler(l, h, o, i) {
    const n = l.originalEvent;
    i || (n.preventDefault(), n.stopPropagation(), n.stopImmediatePropagation());
    const t = o.parentElement;
    if (!t || !t.parentElement)
      return;
    const e = t.clientWidth;
    let s;
    if (this.isRtl ? (s = o.getBoundingClientRect().right - o.offsetWidth / 2 - l.clientX, s += e) : s = e + l.clientX - o.getBoundingClientRect().left - o.offsetWidth / 2, !i && Math.abs(s - e) < 1)
      return;
    this.fixateInitialWidths(t.parentElement.clientWidth), this.setWidths(h, Math.floor(s) / e);
    const r = this.columns.filter((c) => !c.children.length).indexOf(h);
    this.onResize(r, e, s, n, i);
  }
  fixateInitialWidths(l) {
    const h = this.columns.filter((t) => !t.children.length);
    let o = 0;
    const i = this.colGroupMain ? this.colGroupMain.children : [];
    for (let t = 0; t < i.length; t++)
      i[t].width ? l -= parseFloat(i[t].width) : o++;
    if (o === 0)
      return;
    const n = Math.floor(l / o);
    for (let t = 0; t < i.length; t++) {
      const e = i[t];
      e.width || (e.width = n, h[t].width = n.toString(), this.colGroupHeader && (this.colGroupHeader.children[t].width = n), this.colGroupFooter && (this.colGroupFooter.children[t].width = n));
    }
  }
  setWidths(l, h) {
    const o = this.columns.indexOf(l), i = [];
    let n = l.children.length;
    for (let t = o + 1; n > 0 && t < this.columns.length; t++) {
      const e = this.columns[t];
      e.children.length ? n += e.children.length : i.push(e), n--;
    }
    i.length === 0 && i.push(l), i.forEach((t) => {
      let e = t.width ? parseFloat(t.width.toString()) * h : 0;
      const s = t.minResizableWidth === void 0 ? 10 : t.minResizableWidth;
      e < s && (e = s), t.width = e;
    }), this.updateColElements(i);
  }
  updateColElements(l) {
    const h = this.columns.filter((i) => !i.children.length);
    let o = 1e-10;
    for (let i = 0; i < l.length; i++) {
      const n = h.indexOf(l[i]), t = parseFloat((l[i].width || 0).toString());
      o += t - Math.floor(t);
      const e = Math.floor(t) + Math.floor(o);
      o -= Math.floor(o), this.colGroupMain && (this.colGroupMain.children[n].width = e + "px"), this.colGroupHeader && (this.colGroupHeader.children[n].width = e + "px"), this.colGroupFooter && this.colGroupFooter.children[n] && (this.colGroupFooter.children[n].width = e + "px");
    }
  }
}
export {
  a as ColumnResize
};
