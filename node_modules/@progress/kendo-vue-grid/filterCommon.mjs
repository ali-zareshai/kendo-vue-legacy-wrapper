/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { messages as i, dateFilterAriaLabel as n, booleanFilterAriaLabel as p, numericFilterAriaLabel as g, textFilterAriaLabel as s } from "./messages/main.mjs";
const x = [
  { text: "grid.filterAndLogic", operator: "and" },
  { text: "grid.filterOrLogic", operator: "or" }
], O = {
  text: [
    { text: "grid.filterContainsOperator", operator: "contains" },
    { text: "grid.filterNotContainsOperator", operator: "doesnotcontain" },
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterStartsWithOperator", operator: "startswith" },
    { text: "grid.filterEndsWithOperator", operator: "endswith" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" },
    { text: "grid.filterIsEmptyOperator", operator: "isempty" },
    { text: "grid.filterIsNotEmptyOperator", operator: "isnotempty" }
  ],
  numeric: [
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterGteOperator", operator: "gte" },
    { text: "grid.filterGtOperator", operator: "gt" },
    { text: "grid.filterLteOperator", operator: "lte" },
    { text: "grid.filterLtOperator", operator: "lt" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" }
  ],
  date: [
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterAfterOrEqualOperator", operator: "gte" },
    { text: "grid.filterAfterOperator", operator: "gt" },
    { text: "grid.filterBeforeOperator", operator: "lt" },
    { text: "grid.filterBeforeOrEqualOperator", operator: "lte" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" }
  ],
  boolean: [
    { text: "grid.filterEqOperator", operator: "eq" }
  ]
}, l = (t) => t === "isnull" || t === "isnotnull" || t === "isempty" || t === "isnotempty", c = (t, e) => t.map((o) => ({
  text: e.toLanguageString(o.text, i[o.text]),
  operator: o.operator
})), f = "eq", q = [
  { text: "grid.filterBooleanAll", operator: "" },
  { text: "grid.filterIsTrue", operator: !0 },
  { text: "grid.filterIsFalse", operator: !1 }
], L = (t, e, o) => {
  const a = d(o.operators);
  let r = o.operator;
  switch (o.filterType) {
    case "numeric":
      (!r || l(r)) && (r = a), t === null && r === a && (r = "");
      break;
    case "date":
      (!r || l(r)) && (r = a), t === null && r === a && (r = "");
      break;
    case "text":
      (!r || l(r)) && (r = a), !t && r === a && (r = "");
      break;
    default:
      return;
  }
  return { value: t, operator: r, event: e };
}, d = (t, e) => e ? t[e][0].operator : t[0].operator, m = (t) => t || "text", N = (t, e) => ({
  value: t,
  operator: t === "" ? "" : f,
  event: e
}), b = (t, e, o) => (l(t) && (o = null), { value: o, operator: t, event: e }), E = (t, e) => {
  switch (t) {
    case "text":
      return e.toLanguageString(s, i[s]);
    case "numeric":
      return e.toLanguageString(g, i[g]);
    case "boolean":
      return e.toLanguageString(p, i[p]);
    case "date":
      return e.toLanguageString(n, i[n]);
    default:
      return;
  }
};
export {
  l as IsUnaryFilter,
  q as booleanFilterValues,
  N as cellBoolDropdownChange,
  L as cellInputChange,
  b as cellOperatorChange,
  f as defaultBooleanOperator,
  x as filterLogicList,
  E as getAriaLabel,
  d as getDefaultOperator,
  m as getFilterType,
  c as operatorMap,
  O as operators
};
