/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { siblingContainer as p, parents as h } from "@progress/kendo-popup-common";
const C = (e, t) => e || {
  height: 0,
  left: t.left,
  top: t.top,
  width: 0
}, E = (e, t) => t ? {
  height: e.height,
  left: t.left,
  top: t.top,
  width: e.width
} : e, T = (e, t) => t ? {
  height: e.height,
  left: e.left - t.left,
  top: e.top - t.top,
  width: e.width
} : e, f = () => typeof document != "undefined" && !!document.body, c = () => typeof window != "undefined", m = /auto|scroll/, w = (e) => {
  const t = window.getComputedStyle(e);
  return `${t.overflow}${t.overflowX}${t.overflowY}`;
}, b = (e) => {
  const t = [];
  if (!f() || !c())
    return t;
  let n = e.parentElement;
  for (; n; )
    m.test(w(n)) && t.push(n), n = n.parentElement;
  return t.push(window), t;
}, x = 1e3 / 60, g = () => {
  if (!f())
    return !1;
  const e = 10, t = document.createElement("div");
  if (t.style.transform = "matrix(10, 0, 0, 10, 0, 0)", t.innerHTML = "<div>child</div>", document.body.appendChild(t), t && t.firstChild) {
    const l = t.firstChild;
    l.style.position = "fixed", l.style.top = `${e}px`;
  }
  const n = t.children[0].getBoundingClientRect().top !== e;
  return document.body.removeChild(t), n;
}, A = g(), I = (e, t) => {
  if (!e || !f() || !c())
    return null;
  const n = p(e, t);
  if (!n)
    return null;
  const l = [e].concat(h(e, n)).reduce((o, i) => {
    const s = i.style.zIndex || window.getComputedStyle(i).zIndex, r = parseInt(s, 10);
    return r > o ? r : o;
  }, 0);
  return l ? l + 1 : null;
}, R = {
  fit: "fit",
  flip: "flip"
}, S = {
  left: "left",
  bottom: "bottom",
  top: "top"
}, D = function(e, t, n = {}) {
  let l, o, i, s, r = 0;
  n = n || {};
  const a = function() {
    r = n.leading === !1 ? 0 : (/* @__PURE__ */ new Date()).getTime(), l = null, s = e.apply(o, i), l || (o = i = null);
  };
  return function() {
    const u = (/* @__PURE__ */ new Date()).getTime();
    !r && n.leading === !1 && (r = u);
    const d = t - (u - r);
    return o = this, i = arguments, d <= 0 || d > t ? (l && (clearTimeout(l), l = null), r = u, s = e.apply(o, i), l || (o = i = null)) : !l && n.trailing !== !1 && (l = setTimeout(a, d)), s;
  };
};
export {
  S as AlignPoint,
  R as CollisionType,
  x as FRAME_DURATION,
  A as HAS_RELATIVE_STACKING_CONTEXT,
  m as OVERFLOW_REGEXP,
  C as eitherRect,
  g as hasRelativeStackingContext,
  f as isDocumentAvailable,
  c as isWindowAvailable,
  T as removeStackingOffset,
  E as replaceOffset,
  b as scrollableParents,
  D as throttle,
  I as zIndex
};
