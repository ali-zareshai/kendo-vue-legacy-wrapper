/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { align as l, boundingOffset as s, isBodyOffset as f, offset as n, siblingContainer as u, positionWithScroll as a, applyLocationOffset as c, addScroll as d, removeScroll as m, restrictToView as p, scrollPosition as g, getWindowViewPort as w } from "@progress/kendo-popup-common";
import { isWindowAvailable as o, scrollableParents as E, HAS_RELATIVE_STACKING_CONTEXT as h, zIndex as v, isDocumentAvailable as x } from "../util.mjs";
class S {
  addOffset(t, e) {
    return {
      left: t.left + e.left,
      top: t.top + e.top
    };
  }
  align(t) {
    return l(t);
  }
  boundingOffset(t) {
    return s(t);
  }
  getWindow() {
    return o() ? window : null;
  }
  isBodyOffset(t) {
    return f(t);
  }
  hasOffsetParent(t) {
    if (!t)
      return !1;
    const e = t.offsetParent;
    return e && !(e.nodeName === "BODY" && window.getComputedStyle(e).position === "static");
  }
  offset(t) {
    return t ? n(t) : null;
  }
  staticOffset(t) {
    if (!t)
      return null;
    const { left: e, top: r } = t.style;
    t.style.left = "0px", t.style.top = "0px";
    const i = n(t);
    return t.style.left = e, t.style.top = r, i;
  }
  position(t, e) {
    if (!t || !e)
      return null;
    const r = u(t, e);
    return a(t, r);
  }
  relativeOffset(t, e) {
    return c(this.offset(t), e, this.isBodyOffset(t));
  }
  addScroll(t, e) {
    return d(t, e);
  }
  removeScroll(t, e) {
    return m(t, e);
  }
  restrictToView(t) {
    return p(t);
  }
  scrollPosition(t) {
    return g(t);
  }
  scrollableParents(t) {
    return E(t);
  }
  stackingElementOffset(t) {
    const e = this.getRelativeContextElement(t);
    return e ? n(e) : null;
  }
  stackingElementScroll(t) {
    const e = this.getRelativeContextElement(t);
    return e ? {
      x: e.scrollLeft,
      y: e.scrollTop
    } : { x: 0, y: 0 };
  }
  stackingElementViewPort(t) {
    const e = this.getRelativeContextElement(t);
    return e ? {
      height: e.scrollHeight,
      width: e.scrollWidth
    } : null;
  }
  getRelativeContextElement(t) {
    if (!t || !h)
      return null;
    let e = t.parentElement;
    for (; e; ) {
      if (window.getComputedStyle(e).transform !== "none")
        return e;
      e = e.parentElement;
    }
    return null;
  }
  useRelativePosition(t) {
    return !!this.getRelativeContextElement(t);
  }
  windowViewPort(t) {
    return w(t);
  }
  zIndex(t, e) {
    return v(t, e);
  }
  zoomLevel() {
    return !x() || !o() ? 1 : parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2));
  }
  isZoomed() {
    return this.zoomLevel() > 1;
  }
}
export {
  S as DOMService
};
