/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { resolveItemsIds as g, updateItem as C } from "./utils/itemUtils.mjs";
import { EXPAND_FIELD as D, SELECT_FIELD as L, CHECK_FIELD as E, CHILDREN_FIELD as p, CHECK_INDETERMINATE_FIELD as N } from "./utils/consts.mjs";
import { isArray as I, getNestedValue as m } from "./utils/misc.mjs";
const H = function(n, t) {
  if (!n || !n.length)
    return [];
  let e = n;
  const l = t.cloneField || "cloned", f = t.expandField || D, s = t.selectField || L, c = t.checkField || E, i = t.childrenField || p;
  return e = d(e, f, t.expand, l, i), e = d(e, s, t.select, l, i), e = d(e, c, t.check, l, i), h(e, i, t.check), e;
};
function d(n, t, e, l, f) {
  if (e) {
    let { ids: s, field: c } = o(e, t), i = !I(e) && e.idField ? g(s, e.idField, n, f) : s;
    return _(n, i, c, l, f);
  } else
    return n;
}
function o(n, t) {
  let e, l;
  return I(n) ? (e = n, l = t) : (e = n.ids || [], l = n.operationField || t), { ids: e, field: l };
}
function _(n, t, e, l, f) {
  let s = n;
  return t.forEach((c) => {
    s = C(s, c, (i) => F(e, i), l, f);
  }), s;
}
function F(n, t) {
  const e = (n || "").split(".");
  let l = t;
  for (let f = 0; f < e.length; f++) {
    const s = e[f];
    if (f === e.length - 1)
      l[s] = !0;
    else if (l[s] !== void 0)
      l[s] = { ...l[s] }, l = l[s];
    else
      return;
  }
}
function h(n, t, e) {
  if (e && !I(e) && e.applyCheckIndeterminate) {
    const { field: l } = o(e, E), f = e.checkIndeterminateField || N;
    for (let s = 0; s < n.length; s++) {
      const c = n[s], i = c[t];
      i && u(
        i,
        m(l, c) ? [] : [c],
        t,
        l,
        f
      );
    }
  }
}
function u(n, t, e, l, f) {
  let s = !1;
  for (let c = 0; c < n.length; c++) {
    const i = n[c];
    if (m(l, i)) {
      if (!s)
        for (let r = 0; r < t.length; r++)
          F(f, t[r]);
      s = !0, i[e] && u(
        i[e],
        [],
        e,
        l,
        f
      );
    } else
      i[e] && u(
        i[e],
        s ? [i] : t.concat([i]),
        e,
        l,
        f
      );
  }
}
export {
  H as processTreeViewItems
};
