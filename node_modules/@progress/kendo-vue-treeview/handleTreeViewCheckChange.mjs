/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { getAllDirectIndirectChildrenIds as I, areAllDirectChildrenChecked as p, getAllParents as g } from "./utils/itemUtils.mjs";
import { getDirectParentId as u, getItemById as O } from "./utils/itemIdUtils.mjs";
import { isArray as m, getNestedValue as x } from "./utils/misc.mjs";
import { CHILDREN_FIELD as k } from "./utils/consts.mjs";
function E(i, n, t, o = {}, f) {
  if (!t || !t.length)
    return [];
  const { ids: l, idField: r } = C(n), c = r ? x(r, i.item) : i.itemHierarchicalIndex, h = l.indexOf(c), d = h === -1, a = f || k;
  let e;
  return o.singleMode ? e = d ? [c] : [] : (e = l.slice(), d ? e.push(c) : e.splice(h, 1), o.checkChildren && w(i.item, i.itemHierarchicalIndex, d, r, a, e), o.checkParents && D(i.itemHierarchicalIndex, d, r, a, e, t)), m(n) ? e : Object.assign({}, n, { ids: e });
}
function C(i) {
  let n, t;
  return m(i) ? n = i : (n = i.ids || [], t = i.idField), { ids: n, idField: t };
}
function w(i, n, t, o, f, l) {
  I(i, n, f, o).forEach((r) => {
    t && l.indexOf(r) === -1 ? l.push(r) : !t && l.indexOf(r) > -1 && l.splice(l.indexOf(r), 1);
  });
}
function D(i, n, t, o, f, l) {
  const r = a();
  let c = r.next();
  n ? h() : d();
  function h() {
    for (; !c.done; ) {
      const { id: e, item: s } = c.value;
      if (f.indexOf(e) === -1 && p(s, e, t, o, f))
        f.push(e), c = r.next();
      else
        break;
    }
  }
  function d() {
    for (; !c.done; ) {
      const { id: e } = c.value, s = f.indexOf(e);
      if (s > -1)
        f.splice(s, 1), c = r.next();
      else
        break;
    }
  }
  function* a() {
    if (t) {
      const e = g(i, o, l);
      for (let s = e.length - 1; s > -1; s--)
        yield { id: x(t, e[s]), item: n ? e[s] : void 0 };
    } else {
      let e = u(i);
      for (; e; )
        yield { id: e, item: n ? O(e, l, o) : void 0 }, e = u(e);
    }
  }
}
export {
  E as handleTreeViewCheckChange
};
