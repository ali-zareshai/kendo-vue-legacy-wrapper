/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function g(t, n, r) {
  return r ? { ...t, [n]: r.length ? [...r] : void 0 } : t && t[n] ? [...t[n]] : [];
}
function s(t, n, r) {
  if (t[n]) {
    const o = g(t, n).map((e) => s(e, n, r));
    return r(g(t, n, o));
  }
  return r(t);
}
const i = (t, n, r) => [...t.map((o) => s(o, n, r))], u = (t, n, r, o) => {
  let e = t;
  const c = [];
  for (let h = 0; h < n.length; h++)
    e = e[n[h]], e = Array.isArray(e) ? e : e[r], c.push(e);
  const p = c.length > 1 ? c[c.length - 2] : t, a = n[n.length - 1], f = o(p[a]);
  p.splice(a, 1, f);
}, w = (t, n, r) => Object.assign(
  {},
  t,
  t[n] ? { [n]: t[n].slice() } : {},
  r || {}
), x = (t, n, r) => {
  const o = [], e = [...n];
  if (e.length) {
    let c = t[e.shift() || 0];
    for (o.push(c); e.length && r; )
      c = c[r][e.shift() || 0], o.push(c);
  }
  return o;
};
function l(t, n) {
  const r = t.split(".");
  let o = n;
  return r.forEach((e) => {
    o = o ? o[e] : void 0;
  }), o;
}
export {
  w as extendDataItem,
  x as getItemPath,
  l as getNestedValue,
  i as mapTree,
  u as mapTreeItem
};
