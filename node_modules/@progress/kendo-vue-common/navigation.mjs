/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const i = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
];
class a {
  constructor(t) {
    this.rovingTabIndex = !0, this.update = () => {
    }, this.focusNextIndex = (e, n) => {
      const s = this.elements;
      let o = s.indexOf(e) + n;
      o = o < 0 ? s.length - 1 : o, this.focusElement(s[o % s.length], e);
    }, this.tabIndex = t.tabIndex || 0, this.root = t.root, this.selectors = t.selectors, this.rovingTabIndex = t.rovingTabIndex !== void 0 ? t.rovingTabIndex : !0, this.mouseEvents = t.mouseEvents || {}, this.keyboardEvents = t.keyboardEvents || {};
  }
  get elements() {
    return this.root ? Array.from(this.root.querySelectorAll(this.selectors.join(","))) : [];
  }
  get first() {
    return this.root && this.root.querySelector(this.selectors.join(",")) || null;
  }
  get last() {
    const t = this.elements;
    return t[t.length - 1] || null;
  }
  get current() {
    return this.elements.find((t) => t.matches(":focus")) || null;
  }
  focusNext(t) {
    this.focusNextIndex(t, 1);
  }
  focusPrevious(t) {
    this.focusNextIndex(t, -1);
  }
  triggerKeyboardEvent(t) {
    const e = t.target instanceof Element && t.target.closest(this.selectors.join(",")), n = t.key === " " ? "Space" : t.key, s = t.type;
    e && this.keyboardEvents[s][n] && this.keyboardEvents[s][n].call(void 0, e, this, t);
  }
  triggerMouseEvent(t) {
    const e = t.target instanceof Element && t.target.closest(this.selectors.join(",")), n = t.type;
    e && this.mouseEvents[n].call(void 0, e, this, t);
  }
  focusElement(t, e) {
    t && (e && (this.rovingTabIndex && e.removeAttribute("tabindex"), e.classList.remove("k-focus")), this.rovingTabIndex && t.setAttribute("tabindex", String(this.tabIndex)), t.focus({ preventScroll: !0 }));
  }
}
export {
  i as FOCUSABLE_ELEMENTS,
  a as Navigation
};
