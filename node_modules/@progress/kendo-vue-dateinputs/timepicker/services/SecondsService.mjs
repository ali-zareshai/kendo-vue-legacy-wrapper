/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { isEqual as m } from "@progress/kendo-date-math";
import "@progress/kendo-vue-intl";
import { MIDNIGHT_DATE as x } from "../../utils.mjs";
import { setSeconds as r, range as u } from "../utils.mjs";
const h = 60, S = (n) => (t) => t % n, g = S(h), I = (n, t) => (s) => g(n + s * t), a = (n, t) => g(h + n - t), M = (n) => (t, s) => !s || t.getMinutes() === s.getMinutes() && t.getHours() === s.getHours() ? t : r(t, n), f = M(0), L = M(h - 1);
class R {
  constructor(t) {
    this.intl = t, this.insertUndividedMax = !1;
  }
  apply(t, s) {
    return r(t, s.getSeconds());
  }
  configure(t) {
    const {
      insertUndividedMax: s = this.insertUndividedMax,
      min: i = this.min,
      max: o = this.max,
      part: e,
      step: d = this.step
    } = t;
    this.insertUndividedMax = s, this.toListItem = (p) => {
      const c = r(x, p);
      return {
        text: this.intl.formatDate(c, e.pattern),
        value: c
      };
    }, this.min = i, this.max = o, this.step = d;
  }
  data(t) {
    const [s] = this.range(t), i = I(s, this.step), o = (d) => this.toListItem(i(d)), e = u(0, this.countFromMin(t)).map(o);
    return this.addLast(e), t && this.addMissing(e, t), e;
  }
  isRangeChanged(t, s) {
    return !m(this.min, t) || !m(this.max, s);
  }
  limitRange(t, s, i) {
    return [f(t, i), L(s, i)];
  }
  total(t) {
    const s = this.insertUndividedMax && this.isLastMissing(t) ? 1 : 0, i = this.isMissing(t) ? 1 : 0;
    return this.countFromMin(t) + i + s;
  }
  selectedIndex(t) {
    return Math.ceil(this.divideByStep(t));
  }
  valueInList(t) {
    return t ? this.insertUndividedMax && this.lastSecond(t) === t.getSeconds() || !this.isMissing(t) : !0;
  }
  divideByStep(t) {
    return a(t.getSeconds(), this.min.getSeconds()) / this.step;
  }
  addLast(t, s) {
    return this.insertUndividedMax && this.isLastMissing(s) && t.push(this.toListItem(this.lastSecond(s))), t;
  }
  addMissing(t, s) {
    if (this.valueInList(s))
      return t;
    const i = this.toListItem(s.getSeconds());
    return t.splice(this.selectedIndex(s), 0, i), t;
  }
  countFromMin(t) {
    const [s, i] = this.range(t);
    return Math.floor(a(i, s) / this.step) + 1;
  }
  isMissing(t) {
    return t ? this.selectedIndex(t) !== this.divideByStep(t) : !1;
  }
  isLastMissing(t) {
    return this.isMissing(r(this.max, this.lastSecond(t)));
  }
  lastSecond(t) {
    return this.range(t)[1];
  }
  range(t) {
    const [s, i] = this.limitRange(this.min, this.max, t);
    return [s.getSeconds(), i.getSeconds()];
  }
}
export {
  R as SecondsService
};
