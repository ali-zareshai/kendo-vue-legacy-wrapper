/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { cloneDate as c } from "@progress/kendo-date-math";
const a = (s, t) => {
  const n = c(s);
  return n.setHours(t), n;
}, m = (s) => s !== null && s < 12, g = (s) => s !== null && (!s || s > 11), d = (s, t, n) => !t && !n || s >= t && s <= n, l = (s, t, n) => !t && !n || s >= t || s <= n;
class H {
  constructor(t) {
    this.intl = t;
  }
  /**
   * @hidden
   */
  apply(t, n) {
    const e = t.getHours(), r = m(e), i = m(n.getHours());
    if (r && i || !r && !i)
      return t;
    const [o, h = 24] = this.normalizedRange(), u = e + (i ? -12 : 12);
    return a(t, Math.min(Math.max(o, u), h || 24));
  }
  /**
   * @hidden
   */
  configure(t) {
    const { min: n = this.min, max: e = this.max, part: r = this.part } = t;
    this.min = n, this.max = e, this.part = r;
  }
  /**
   * @hidden
   */
  data(t) {
    const n = this.part.names;
    if (!n)
      return [];
    const e = [], [r, i] = this.normalizedRange(), o = this.intl.dateFormatNames(n);
    return m(r) && e.push({ text: o.am, value: a(this.min, r) }), g(i) && e.push({ text: o.pm, value: a(this.min, Math.max(12, i)) }), this.min.getHours() !== r ? e.reverse() : e;
  }
  /**
   * @hidden
   */
  isRangeChanged(t, n) {
    return !1;
  }
  /**
   * @hidden
   */
  limitRange(t, n, e) {
    return [t, n];
  }
  /**
   * @hidden
   */
  total() {
    const [t, n] = this.normalizedRange();
    return !t && !n ? 2 : t > 11 || n < 12 ? 1 : 2;
  }
  /**
   * @hidden
   */
  selectedIndex(t) {
    if (!this.valueInList(t))
      return -1;
    const n = Math.floor(t.getHours() / 12);
    return this.min.getHours() === this.normalizedRange()[0] ? n : n === 0 ? 1 : 0;
  }
  /**
   * @hidden
   */
  valueInList(t) {
    return (this.min.getHours() !== this.normalizedRange()[0] ? l : d)(t.getHours(), this.min.getHours(), this.max.getHours());
  }
  normalizedRange() {
    const t = this.min.getHours(), n = this.max.getHours();
    return [
      Math.min(t, n),
      Math.max(t, n)
    ];
  }
}
export {
  H as DayPeriodService
};
