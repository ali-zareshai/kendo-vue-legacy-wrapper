/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { isEqual as d, getDate as g } from "@progress/kendo-date-math";
import "@progress/kendo-vue-intl";
import { MIDNIGHT_DATE as H } from "../../utils.mjs";
import { setHours as r, range as f } from "../utils.mjs";
const a = 24, I = (n) => (t) => t % n, u = I(a), l = (n, t) => (i) => u(n + i * t), c = (n, t) => u(a + n - t), p = (n) => (t, i) => !i || g(t).getTime() === g(i).getTime() ? t : r(t, n), L = p(0), R = p(a - 1);
class S {
  constructor(t) {
    this.intl = t, this.boundRange = !1, this.insertUndividedMax = !1;
  }
  apply(t, i) {
    return r(t, i.getHours());
  }
  configure(t) {
    const {
      boundRange: i = this.boundRange,
      insertUndividedMax: s = this.insertUndividedMax,
      min: o = this.min,
      max: e = this.max,
      part: h,
      step: M = this.step
    } = t;
    this.boundRange = i, this.insertUndividedMax = s, this.toListItem = (x) => {
      const m = r(H, x);
      return {
        text: this.intl.formatDate(m, h.pattern),
        value: m
      };
    }, this.min = o, this.max = e, this.step = M;
  }
  data(t) {
    const [i] = this.range(t), s = l(i, this.step), o = (h) => this.toListItem(s(h)), e = f(0, this.countFromMin(t)).map(o);
    return this.addLast(e), t && this.addMissing(e, t), e;
  }
  isRangeChanged(t, i) {
    return !d(this.min, t) || !d(this.max, i);
  }
  limitRange(t, i, s) {
    return this.boundRange ? [L(t, s), R(i, s)] : [t, i];
  }
  total(t) {
    const i = this.insertUndividedMax && this.isLastMissing(t) ? 1 : 0, s = this.isMissing(t) ? 1 : 0;
    return this.countFromMin(t) + s + i;
  }
  selectedIndex(t) {
    return Math.ceil(this.divideByStep(t));
  }
  valueInList(t) {
    return t ? this.insertUndividedMax && this.lastHour(t) === t.getHours() || !this.isMissing(t) : !0;
  }
  addLast(t, i) {
    return this.insertUndividedMax && this.isLastMissing(i) && t.push(this.toListItem(this.lastHour(i))), t;
  }
  addMissing(t, i) {
    if (this.valueInList(i))
      return t;
    const s = this.toListItem(i.getHours());
    return t.splice(this.selectedIndex(i), 0, s), t;
  }
  countFromMin(t) {
    const [i, s] = this.range(t);
    return Math.floor(c(s, i) / this.step) + 1;
  }
  isMissing(t) {
    return t ? this.selectedIndex(t) !== this.divideByStep(t) : !1;
  }
  isLastMissing(t) {
    return this.isMissing(r(this.max, this.lastHour(t)));
  }
  divideByStep(t) {
    return c(t.getHours(), this.min.getHours()) / this.step;
  }
  lastHour(t) {
    return this.range(t)[1];
  }
  range(t) {
    const [i, s] = this.limitRange(this.min, this.max, t);
    return [i.getHours(), s.getHours()];
  }
}
export {
  S as HoursService
};
