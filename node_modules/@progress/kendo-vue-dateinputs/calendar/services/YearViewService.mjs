/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import "@progress/kendo-vue-intl";
import { addYears as g, firstMonthOfYear as I, lastMonthOfYear as R, addMonths as u, createDate as E, durationInYears as c } from "@progress/kendo-date-math";
import { Action as o } from "../models/NavigationAction.mjs";
import { range as M, getToday as _, isInSelectionRange as O, isInRange as F } from "../../utils.mjs";
import { EMPTY_SELECTIONRANGE as $ } from "../models/SelectionRange.mjs";
import { cloneDate as p } from "@progress/kendo-vue-common";
const C = [[]], T = 4, G = 3, P = {
  [o.Left]: (n) => u(n, -1),
  [o.Up]: (n) => u(n, -4),
  [o.Right]: (n) => u(n, 1),
  [o.Down]: (n) => u(n, 4),
  [o.PrevView]: (n) => g(n, -1),
  [o.NextView]: (n) => g(n, 1),
  [o.FirstInView]: (n) => I(n),
  [o.LastInView]: (n) => R(n)
};
class K {
  constructor(t) {
    this._intl = t;
  }
  addToDate(t, e) {
    return g(t, e);
  }
  datesList(t, e) {
    return M(0, e).map((r) => g(t, r));
  }
  data(t) {
    const {
      cellUID: e,
      focusedDate: r,
      isActiveView: l,
      max: i,
      min: a,
      selectedDate: h,
      selectionRange: f = $,
      viewDate: m
    } = t;
    if (!m)
      return C;
    const b = this.abbrMonthNames(), d = I(m), q = R(m), y = d.getFullYear(), A = M(0, T), V = _();
    return M(0, G).map((v) => {
      const D = u(d, v * T);
      return A.map((N) => {
        const s = this.normalize(u(D, N), a, i);
        if (!s || y < s.getFullYear())
          return null;
        const w = this.isEqual(s, f.start), S = this.isEqual(s, f.end), Y = !w && !S && O(s, f), L = l && (Array.isArray(h) ? this.isSelectedFromArray(s, h, a, i) : F(h, a, i) && this.isEqual(s, h));
        return {
          formattedValue: b[s.getMonth()],
          id: `${e}${s.getTime()}`,
          isFocused: this.isEqual(s, r),
          isSelected: L,
          isInRange: F(s, a, i),
          isWeekend: !1,
          isRangeStart: w,
          isRangeMid: Y,
          isRangeEnd: S,
          isRangeSplitEnd: Y && this.isEqual(s, q),
          isRangeSplitStart: Y && this.isEqual(s, d),
          isToday: this.isEqual(s, V),
          title: this.cellTitle(s),
          value: s
        };
      });
    });
  }
  isSelectedFromArray(t, e, r, l) {
    let i = !1;
    return e.forEach((a) => {
      F(t, r, l) && this.isEqual(t, a) && (i = !0);
    }), i;
  }
  isEqual(t, e) {
    return !t || !e ? !1 : t.getFullYear() === e.getFullYear() && t.getMonth() === e.getMonth();
  }
  isInArray(t, e) {
    if (!e.length)
      return !1;
    const r = t.getFullYear();
    return e[0].getFullYear() <= r && r <= e[e.length - 1].getFullYear();
  }
  isInRange(t, e, r) {
    const l = E(t.getFullYear(), t.getMonth(), 1), i = !e || E(e.getFullYear(), e.getMonth(), 1) <= l, a = !r || l <= E(r.getFullYear(), r.getMonth(), 1);
    return i && a;
  }
  isInSameView(t, e) {
    return c(t, e) === 0;
  }
  isRangeStart(t) {
    return t.getFullYear() % 10 === 0;
  }
  move(t, e) {
    const r = P[e];
    return r ? r(t) : t;
  }
  cellTitle(t) {
    return `${t.getFullYear()} ${this.value(t)}`;
  }
  navigationTitle(t) {
    return this.title(t);
  }
  title(t) {
    return t ? t.getFullYear().toString() : "";
  }
  rowLength(t) {
    return T;
  }
  skip(t, e) {
    return c(e, t);
  }
  total(t, e) {
    return c(t, e) + 1;
  }
  value(t) {
    return t ? this.abbrMonthNames()[t.getMonth()] : "";
  }
  viewDate(t, e, r = 1) {
    return c(t, e) < r ? g(t, -1) : t;
  }
  abbrMonthNames() {
    return this._intl.dateFormatNames({ nameType: "abbreviated", type: "months" });
  }
  normalize(t, e, r) {
    return t < e && this.isEqual(t, e) ? p(e) : t > r && this.isEqual(t, r) ? p(r) : t;
  }
}
export {
  K as YearViewService
};
