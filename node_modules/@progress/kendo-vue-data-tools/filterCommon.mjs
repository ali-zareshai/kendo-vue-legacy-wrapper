/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { messages as l } from "./messages/main.mjs";
const f = [
  { text: "grid.filterAndLogic", operator: "and" },
  { text: "grid.filterOrLogic", operator: "or" }
], g = {
  text: [
    { text: "grid.filterContainsOperator", operator: "contains" },
    { text: "grid.filterNotContainsOperator", operator: "doesnotcontain" },
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterStartsWithOperator", operator: "startswith" },
    { text: "grid.filterEndsWithOperator", operator: "endswith" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" },
    { text: "grid.filterIsEmptyOperator", operator: "isempty" },
    { text: "grid.filterIsNotEmptyOperator", operator: "isnotempty" }
  ],
  numeric: [
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterGteOperator", operator: "gte" },
    { text: "grid.filterGtOperator", operator: "gt" },
    { text: "grid.filterLteOperator", operator: "lte" },
    { text: "grid.filterLtOperator", operator: "lt" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" }
  ],
  date: [
    { text: "grid.filterEqOperator", operator: "eq" },
    { text: "grid.filterNotEqOperator", operator: "neq" },
    { text: "grid.filterAfterOrEqualOperator", operator: "gte" },
    { text: "grid.filterAfterOperator", operator: "gt" },
    { text: "grid.filterBeforeOperator", operator: "lt" },
    { text: "grid.filterBeforeOrEqualOperator", operator: "lte" },
    { text: "grid.filterIsNullOperator", operator: "isnull" },
    { text: "grid.filterIsNotNullOperator", operator: "isnotnull" }
  ],
  boolean: [
    { text: "grid.filterEqOperator", operator: "eq" }
  ]
}, a = (t) => t === "isnull" || t === "isnotnull" || t === "isempty" || t === "isnotempty", d = (t, e) => t.map((o) => ({
  text: e.toLanguageString(o.text, l[o.text]),
  operator: o.operator
})), p = "eq", x = [
  { text: "grid.filterBooleanAll", operator: "" },
  { text: "grid.filterIsTrue", operator: !0 },
  { text: "grid.filterIsFalse", operator: !1 }
], u = {
  text: !1,
  numeric: !1,
  date: !1,
  boolean: !0
}, O = (t, e, o) => {
  const i = n(o.operators);
  let r = o.operator;
  switch (o.filterType) {
    case "numeric":
      (!r || a(r)) && (r = i), t === null && r === i && (r = "");
      break;
    case "date":
      (!r || a(r)) && (r = i), t === null && r === i && (r = "");
      break;
    case "text":
      (!r || a(r)) && (r = i), !t && r === i && (r = "");
      break;
    default:
      return;
  }
  return { value: t, operator: r, event: e };
}, n = (t, e) => e ? t[e][0].operator : t[0].operator, c = (t) => t || "text", q = (t, e) => ({
  value: t,
  operator: t === "" ? "" : p,
  event: e
}), N = (t, e, o) => (a(t) && (o = null), { value: o, operator: t, event: e });
export {
  a as IsUnaryFilter,
  x as booleanFilterValues,
  q as cellBoolDropdownChange,
  O as cellInputChange,
  N as cellOperatorChange,
  p as defaultBooleanOperator,
  u as defaultHideSecondFilter,
  f as filterLogicList,
  n as getDefaultOperator,
  c as getFilterType,
  d as operatorMap,
  g as operators
};
