/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { generateNavigatableId as x } from "../../navigation/utils.mjs";
import { ColumnDefaultProps as I } from "../../interfaces/ColumnProps.mjs";
function w(t, r) {
  const i = t[r].depth;
  let d = null;
  for (let l = r + 1; l < t.length; l++)
    if (t[l].depth === i) {
      d = t[l];
      break;
    }
  return d;
}
const o = (t) => {
  let r = t.width ? parseFloat(t.width.toString()) : 0;
  return !r && t.children && t.children.length && (r = t.children.reduce((i, d) => o(d) + i, 0)), r;
};
function E(t) {
  const r = [[]];
  let i = 0;
  for (let e = t.length - 1; e >= 0; e--)
    i = Math.max(i, t[e].depth), t[e].colSpan = t[e].colSpan || 1, t[e].parentIndex !== -1 && (t[t[e].parentIndex].colSpan = (t[t[e].parentIndex].colSpan || 0) + t[e].colSpan);
  const d = [];
  let l = 1;
  t.forEach((e, n) => {
    r[e.depth] = r[e.depth] || [];
    let g = !1;
    r[e.depth].length === 0 && (l <= 1 ? l = 1 + (e.children.length > 0 ? 0 : i - e.depth) : (l--, g = !0)), e.rowSpan = 1 + (e.children.length > 0 ? 0 : i - e.depth), e.kFirst = g, e.index = r[e.depth].length, r[e.depth].push(n), e.ariaColumnIndex = d[e.depth] ? d[e.depth] + 1 : 1;
    for (let p = e.depth; p < e.depth + e.rowSpan; p++)
      d[p] = (d[p] || 0) + e.colSpan;
  });
  let h = new Array(r.length).fill(0), a = 0;
  t.forEach((e) => {
    if (e.locked)
      if (e.left = h[e.depth], a = o(e), e.children.length === 0)
        for (let n = e.depth; n < h.length; n++)
          h[n] += a;
      else
        h[e.depth] += a;
  });
  let f = new Array(r.length).fill(0);
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n.locked) {
      if (n.right = f[n.depth], a = o(n), n.children.length === 0)
        for (let p = n.depth; p < f.length; p++)
          f[p] += a;
      else
        f[n.depth] += a;
      const g = w(t, e);
      n.rightBorder = !(g && g.locked);
    }
  }
  return r;
}
function S(t, r, i = 0) {
  let d = [];
  if (!t || !t.length)
    return [];
  t.forEach((h) => {
    const a = S(h.children || [], r, i + 1);
    d.push(
      Object.assign(
        {},
        { depth: i },
        I,
        h,
        {
          id: h.id ? h.id : x(`${r.prevId++}`, r.idPrefix, "column"),
          declarationIndex: d.length,
          children: a,
          rowSpan: 0,
          colSpan: 0,
          isAccessible: !0
        }
      )
    );
  });
  const l = (h, a) => h.orderIndex === a.orderIndex ? h.declarationIndex - a.declarationIndex : (h.orderIndex || 0) - (a.orderIndex || 0);
  if (d.sort(l), i === 0) {
    let h = [];
    const a = (f, e) => f.forEach((n) => {
      n.parentIndex = e, a(n.children, h.push(n) - 1);
    });
    return a(d, -1), h;
  }
  return d;
}
function k(t) {
  return !!(t && getComputedStyle(t).direction === "rtl");
}
function C(t, r) {
  if (!r || !t || !t.originalEvent)
    return -1;
  let i = r.ownerDocument ? r.ownerDocument.elementFromPoint(t.clientX, t.originalEvent.clientY) : null;
  for (; i && i.parentElement !== r; )
    i = i.parentElement;
  const d = r.children;
  for (let l = 0; l < d.length; l++)
    if (d[l] === i)
      return l;
  return -1;
}
export {
  C as getIndex,
  k as isRtl,
  E as mapColumns,
  S as readColumns
};
