/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { KEYBOARD_NAV_FILTER_COL_SUFFIX as E, KEYBOARD_NAV_DATA_ID as a, FOCUSABLE_ELEMENTS as i, KEYBOARD_NAV_DATA_LEVEL as u, TABBABLE_ELEMENTS as f, KEYBOARD_NAV_DATA_BODY as g, KEYBOARD_NAV_DATA_HEADER as d, KEYBOARD_NAV_DATA_SCOPE as _ } from "./constants.mjs";
const b = (e, t, r = "cell") => `${t}_${e}_${r}`, N = (e) => {
  if (e)
    return parseInt(e.getAttribute(u) || "", 10);
}, A = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(a);
  return t || void 0;
}, c = (e) => e ? !!e.getAttribute(a) : !1, I = (e, t = { level: 0 }) => e.querySelector(`[${u}='${t.level}']`), v = (e) => e.parentElement && e.parentElement.closest(`[${u}]`), $ = (e, t) => e.querySelector(`[${a}='${t}']`), m = (e) => e.parentElement && e.parentElement.closest(`[${_}]`), B = (e) => e.querySelector(`[${d}]`), D = (e) => e.querySelector(`[${g}]`), y = (e, t = { focusable: !1 }) => {
  let r = t.focusable ? i : f;
  return Array.from(e.querySelectorAll(r.join(",")));
}, S = (e, t = { level: 0 }) => {
  if (!e)
    return [];
  let r = i.map((n) => n + `[${u}='${t.level}']`).join(",");
  return Array.from(e.querySelectorAll(r));
}, p = (e = { level: 0 }) => {
  let t = i.map(
    (r) => r + `[${u}='${e.level}']`
  ).join(",");
  return (r) => r.matches(t);
}, x = (e) => {
  const { elementForFocus: t, event: r, kbContext: n, prevElement: o } = e;
  n && t && t.focus && (r.preventDefault(), t.focus(), c(t) && (t.setAttribute("tabIndex", "0"), n.activeId = A(t)), o && c(o) && o.setAttribute("tabIndex", "-1"));
}, O = (e) => e ? e.idPrefix : "", T = (e, t, r, n, o) => {
  if (!r)
    return [];
  let l = e + (o ? -1 : 1);
  for (; l >= 0 && l < n.length; ) {
    const s = n[l][t];
    if (s !== r)
      return [s, [l, t]];
    l = l + (o ? -1 : 1);
  }
  return [];
}, C = (e, t, r, n, o) => {
  if (!r)
    return [];
  let l = t + (o ? -1 : 1);
  for (; l >= 0 && l < n[e].length; ) {
    const s = n[e][l];
    if (s !== r)
      return [s, [e, l]];
    l = l + (o ? -1 : 1);
  }
  return [];
}, L = (e, t) => {
  if (t) {
    for (let r = 0; r < e.length; r++)
      for (let n = 0; n < e[r].length; n++)
        if (e[r][n] === t)
          return [r, n];
  }
}, h = (e) => e ? e.navigationMatrix.length : 0, F = (e) => e ? `${e}${E}` : "", K = {
  generateNavigatableId: b,
  getNavigatableId: A,
  getNavigatableLevel: N,
  getNavigatableElement: I,
  getClosestNavigatableElement: v,
  getActiveElement: $,
  getClosestScope: m,
  getHeaderElement: B,
  getBodyElement: D,
  getFocusableElements: y,
  getNavigatableElements: S,
  filterNavigatableElements: p,
  focusElement: x,
  getIdPrefix: O,
  isNavigatable: c,
  findNextIdByRowIndex: T,
  findNextIdByCellIndex: C,
  findId: L,
  getNextNavigationIndex: h,
  getFilterColumnId: F
};
export {
  p as filterNavigatableElements,
  L as findId,
  C as findNextIdByCellIndex,
  T as findNextIdByRowIndex,
  x as focusElement,
  b as generateNavigatableId,
  $ as getActiveElement,
  D as getBodyElement,
  v as getClosestNavigatableElement,
  m as getClosestScope,
  F as getFilterColumnId,
  y as getFocusableElements,
  B as getHeaderElement,
  O as getIdPrefix,
  I as getNavigatableElement,
  S as getNavigatableElements,
  A as getNavigatableId,
  N as getNavigatableLevel,
  h as getNextNavigationIndex,
  c as isNavigatable,
  K as tableKeyboardNavigationTools
};
