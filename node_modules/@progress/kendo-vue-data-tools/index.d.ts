/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { ComponentOptionsMixin } from 'vue';
import { ComponentProvideOptions } from 'vue';
import { CompositeFilterDescriptor } from '@progress/kendo-data-query';
import { DefineComponent } from 'vue';
import { DropDownListChangeEvent } from '@progress/kendo-vue-dropdowns';
import { ExtractPropTypes } from 'vue';
import { FilterDescriptor } from '@progress/kendo-data-query';
import { FilterOperator as FilterOperator_2 } from '../..';
import { FilterOperator as FilterOperator_3 } from '..';
import { FilterOperators as FilterOperators_2 } from '..';
import { GroupDescriptor } from '@progress/kendo-data-query';
import { PopupAnimation } from '@progress/kendo-vue-popup';
import { PropType } from 'vue';
import { PublicProps } from 'vue';
import { Ref } from 'vue';
import { SortDescriptor } from '@progress/kendo-data-query';
import { SortSettings as SortSettings_2 } from './main';
import { SVGIcon } from '@progress/kendo-svg-icons';
import { TableSelectableMode as TableSelectableMode_2 } from './TableSelectableSettings';

/**
 * @hidden
 */
export declare const BooleanFilter: DefineComponent<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
dataItems: {
type: PropType<{
text: string;
value: any;
}[]>;
default: () => any;
};
defaultItem: PropType<any>;
onFilterchange: PropType<(event: {
nextFilter: FilterOperator_2;
}) => void>;
}>, {}, {
currentData: {
text: string;
value: boolean;
}[];
}, {}, {
handleFilterChange(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
dataItems: {
type: PropType<{
text: string;
value: any;
}[]>;
default: () => any;
};
defaultItem: PropType<any>;
onFilterchange: PropType<(event: {
nextFilter: FilterOperator_2;
}) => void>;
}>> & Readonly<{}>, {
dataItems: {
text: string;
value: any;
}[];
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The props of the BooleanFilter component.
 */
export declare interface BooleanFilterProps extends TextFilterProps {
    /**
     * A collection of text-value pairs passed to the BooleanFilter DropDownList.
     * Defaults to [ { text: 'True', value: true }, { text: 'False', value: false } ]
     */
    dataItems?: Array<{
        text: string;
        value: any;
    }>;
    /**
     * The defaultItem passed to the BooleanFilter DropDownList.
     */
    defaultItem?: any;
}

/**
 * @hidden
 */
export declare const booleanFilterValues: ({
    text: string;
    operator: string;
} | {
    text: string;
    operator: boolean;
})[];

/**
 * @hidden
 */
export declare const cellBoolDropdownChange: (value: any, e: any) => {
    value: any;
    operator: string;
    event: any;
};

/**
 * @hidden
 */
export declare const cellInputChange: (value: any, e: any, props: any) => any;

/**
 * @hidden
 */
export declare const cellOperatorChange: (operator: any, e: any, value: any) => {
    value: any;
    operator: any;
    event: any;
};

/**
 * @hidden
 */
export declare interface CellProps {
    /**
     * @hidden
     */
    id: string;
    /**
     * The index to be applied to the `aria-colindex` attribute.
     */
    ariaColumnIndex: number;
    /**
     * Indicates if the cell is selected.
     */
    isSelected: boolean;
    /**
     * The expanded value of the cell.
     */
    expanded?: boolean;
    /**
     * The custom CSS classes of the cells.
     */
    class?: string;
    /**
     * The field to which the cell is bound.
     */
    field?: string;
    /**
     * The data item which corresponds to the current row.
     */
    dataItem: any;
    /**
     * The format that is applied to the value before the value is displayed.
     * Takes the `{0:format}` form where `format` is a standard number format, a custom number format,
     * a standard date format, or a custom date format. For more information on the supported date and number formats,
     * refer to the [kendo-intl](https://github.com/telerik/kendo-intl/blob/develop/docs/index.md) documentation.
     */
    format?: string;
    /**
     * The column span of the cell.
     */
    colSpan?: number;
    /**
     * The event that is fired when the cell is selected.
     */
    selectionChange?: (event: {
        event: any;
    }) => void;
    /**
     * The event that is fired when the cell value is changed.
     */
    onChange?: (event: {
        dataItem: any;
        event: any;
        field?: string;
        value?: any;
    }) => void;
    /**
     * A function for overriding the default rendering of the cell.
     */
    render?: any;
}

/** @hidden */
export declare const closestTagName: (target: HTMLElement | null, tagName: 'TD' | 'TR' | 'TABLE') => HTMLElement | null;

/**
 * @hidden
 */
export declare interface ColumnBaseProps {
    /**
     * The field to which the column is bound.
     */
    field?: string;
    /**
     * The title of the column.
     */
    title?: string;
    /**
     * Allows the column headers to be clicked and the `sortChange` event emitted.
     * You have to handle the `sortChange` event yourself and sort the data.
     * Defaults to `true`.
     */
    sortable?: boolean | ColumnSortSettings;
    /**
     * The width of the column (in pixels).
     */
    width?: string | number;
    /**
     * Defines if the header selection checkbox is checked.
     */
    headerSelectionValue?: boolean;
    /**
     * The format that is applied to the value before it is displayed.
     * Takes the `{0:format}` form where `format` is a standard number format, a custom number format,
     * a standard date format, or a custom date format. For more information on the supported date and number formats,
     * refer to the [kendo-intl](https://github.com/telerik/kendo-intl/blob/develop/docs/index.md) documentation.
     */
    format?: string;
    /**
     * Sets the custom CSS classes to the column header cell.
     */
    headerClassName?: string;
    /**
     * Sets the custom CSS classes to the column cells.
     */
    className?: string;
    /**
     * Indicates whether the column is resizable.
     */
    resizable?: boolean;
    /**
     * Indicates whether the column is reorderable.
     */
    reorderable?: boolean;
    /**
     * The width of the column (in pixels) below which the user is not able to resize the column through the UI. Defaults to `10`.
     */
    minResizableWidth?: number;
    /**
     * Determinates the position of the column.
     * Columns with smaller `orderIndex` will appear before columns with bigger `orderIndex`.
     * Defaults to `0`.
     */
    orderIndex?: number;
    /**
     * The column identifier used to distinguish columns for example in multi column header scenarios with resize and keyboard navigation.
     * Also used for unique key for rendering the component cells.
     * If not set, the component will generate unique `id` automatically.
     */
    id?: string;
    /**
     * Defines the component that will be rendered as a cell.
     * If not set, a `Cell` will be rendered by default.
     */
    cell?: any;
    /**
     * @hidden
     */
    navigatable?: boolean;
    /**
     * @hidden
     */
    locked?: boolean;
}

/**
 * @hidden
 */
export declare const ColumnDefaultProps: {
    filterable: boolean;
    editable: boolean;
    sortable: boolean;
    resizable: boolean;
    reorderable: boolean;
    groupable: boolean;
};

/**
 * @hidden
 */
declare interface ColumnDraggableProps {
    key?: any;
    onPressHandler?: (draggableEvent: any, element: HTMLElement) => void;
    onDragHandler?: (draggableEvent: any, element: HTMLElement) => void;
    onReleaseHandler?: (draggableEvent: any) => void;
}

/**
 * @hidden
 */
export declare class ColumnResize {
    /**
     * The main `colgroup` of the Grid.
     */
    colGroupMain: any | null;
    /**
     * The header `colgroup` of the Grid, if any.
     */
    colGroupHeader: any | null;
    /**
     * The footer `colgroup` of the Grid (if any).
     */
    colGroupFooter: any | null;
    columns: ExtendedColumnProps[];
    /**
     * The settings for resizing the Grid.
     */
    resizable: boolean;
    onResize: (index: number, newWidth: number, oldWidth: number, originalEvent: any, end: boolean) => void;
    private isRtl;
    constructor(triggerResize: (index: number, newWidth: number, oldWidth: number, originalEvent: any, end: boolean) => void);
    setIsRtl: (isRtl: boolean) => void;
    dragHandler(event: any, column: ExtendedColumnProps, dragCue: HTMLSpanElement, end: boolean): void;
    private fixateInitialWidths;
    private setWidths;
    private updateColElements;
}

/**
 * The settings for sorting the columns of the component.
 */
export declare type ColumnSortSettings = boolean | {
    /**
     * Enables the removal of the column sorting functionality.
     */
    allowUnsort?: boolean;
};

/**
 * @hidden
 */
export declare class CommonDragLogic {
    columns: ExtendedColumnProps[];
    reorderable: boolean;
    groupable: boolean;
    dropElementClue: any | null;
    dragElementClue: any | null;
    private startColumn;
    private startGroup;
    private currentColumn;
    private currentGroup;
    private columnReorder;
    private groupReorder;
    private columnToGroup;
    private groupPanelDivElement;
    constructor(columnReorder: handler, groupReorder: handler, columnToGroup: handler);
    refGroupPanelDiv: (e: any | null) => void;
    refDropElementClue: (e: any | null) => void;
    refDragElementClue: (e: any | null) => void;
    pressHandler: (event: any, element: HTMLElement) => void;
    dragHandler: (event: any, element: HTMLElement) => void;
    releaseHandler: (event: any) => void;
    private getColumnIndex;
    private isTargetGroupingContainer;
    private getGroupIndex;
    private isValid;
    private updateDragElementClue;
    private updateDropElementClue;
}

/**
 * @hidden
 */
export declare const DateFilter: DefineComponent<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
onFilterchange: PropType<(event: {
nextFilter: FilterOperator_2;
}) => void>;
}>, {}, {}, {}, {
onChange(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
onFilterchange: PropType<(event: {
nextFilter: FilterOperator_2;
}) => void>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The props of the DateFilter component.
 */
export declare interface DateFilterProps extends TextFilterProps {
}

/**
 * @hidden
 */
export declare const defaultBooleanOperator: string;

/**
 * @hidden
 */
export declare const defaultHideSecondFilter: {
    text: boolean;
    numeric: boolean;
    date: boolean;
    boolean: boolean;
};

/**
 * @hidden
 */
export declare const DragClue: DefineComponent<    {}, {}, {
visible: boolean;
top: number;
left: number;
innerText: string;
status: string;
}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const DropClue: DefineComponent<    {}, {}, {
height: number;
visible: boolean;
left: number;
top: number;
}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const EnumFilter: DefineComponent<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
dataItems: PropType<{
text: string;
value: any;
}[]>;
defaultItem: PropType<any>;
ariaLabel: PropType<string>;
onFilterchange: PropType<(event: {
nextFilter: FilterOperator_2;
}) => void>;
}>, {}, {}, {}, {
onChange(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
dataItems: PropType<{
text: string;
value: any;
}[]>;
defaultItem: PropType<any>;
ariaLabel: PropType<string>;
onFilterchange: PropType<(event: {
nextFilter: FilterOperator_2;
}) => void>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The props of the EnumFilter component.
 */
export declare interface EnumFilterProps extends TextFilterProps {
    /**
     * A collection of text-value pairs passed to the EnumFilter DropDownList.
     */
    dataItems?: Array<{
        text: string;
        value: any;
    }>;
    /**
     * The defaultItem passed to the EnumFilter DropDownList.
     */
    defaultItem?: any;
}

/**
 * @hidden
 */
export declare const Expression: DefineComponent<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
fields: {
type: PropType<FieldSettings[]>;
required: true;
};
}>, {}, {}, {}, {
onFieldChange(event: DropDownListChangeEvent): void;
onOperatorChange(event: DropDownListChangeEvent): void;
onInputChange(event: any): void;
triggerOnFilterChange(prevFilter: FilterDescriptor, nextFilter: FilterDescriptor, event: any): void;
onFilterRemove(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
change: any;
remove: any;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
fields: {
type: PropType<FieldSettings[]>;
required: true;
};
}>> & Readonly<{
onChange?: (...args: any[] | unknown[]) => any;
onRemove?: (...args: any[] | unknown[]) => any;
}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare interface ExpressionChangeEvent {
    target: any;
    event: any;
    prevFilter: FilterDescriptor;
    nextFilter: FilterDescriptor;
}

/**
 * @hidden
 */
export declare interface ExpressionProps {
    filter: FilterDescriptor;
    fields: Array<FieldSettings>;
}

/**
 * @hidden
 */
export declare interface ExpressionRemoveEvent {
    target: any;
    event: any;
    filter: FilterDescriptor;
}

/**
 * @hidden
 */
export declare interface ExtendedColumnProps extends TreeColumnBaseProps {
    declarationIndex: number;
    parentIndex: number;
    colSpan: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    index: number;
    children: ExtendedColumnProps[];
    left: number;
    right: number;
    rightBorder: boolean;
    groupable: boolean;
    ariaColumnIndex: number;
    isAccessible: boolean;
}

/**
 * The FieldSettings object.
 */
export declare interface FieldSettings {
    /**
     * The field name.
     */
    name: string;
    /**
     * The field label, which will be shown in the fields DropDownList.
     */
    label: string;
    /**
     * The filter editor component. Could be any of the built-in TextFilter, NumericFilter, DateFilter, BooleanFilter or a custom component.
     */
    filter: any;
    /**
     * The collection of operators which will be passed to the operators DropDownList.
     */
    operators: Array<FilterOperator>;
}

/**
 * @hidden
 */
export declare const Filter: DefineComponent<ExtractPropTypes<    {
fields: {
type: PropType<FieldSettings[]>;
required: true;
};
modelValue: {
type: PropType<any>;
default: any;
};
value: PropType<CompositeFilterDescriptor>;
defaultGroupFilter: PropType<CompositeFilterDescriptor>;
upperToolbarAriaLabel: {
type: PropType<string>;
default: any;
};
}>, {}, {}, {
computedValue(): any;
}, {
onFilterChange(event: GroupChangeEvent): void;
onGroupRemove(event: GroupRemoveEvent): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
change: any;
changemodel: any;
'update:modelValue': any;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
fields: {
type: PropType<FieldSettings[]>;
required: true;
};
modelValue: {
type: PropType<any>;
default: any;
};
value: PropType<CompositeFilterDescriptor>;
defaultGroupFilter: PropType<CompositeFilterDescriptor>;
upperToolbarAriaLabel: {
type: PropType<string>;
default: any;
};
}>> & Readonly<{
onChange?: (...args: any[] | unknown[]) => any;
onChangemodel?: (...args: any[] | unknown[]) => any;
"onUpdate:modelValue"?: (...args: any[] | unknown[]) => any;
}>, {
modelValue: any;
upperToolbarAriaLabel: string;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.
 *
 * @param {T[]} data - The data that will be filtered.
 * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The filtered data.
 */
export declare function filterBy(data: any[], descriptors: FilterDescriptor[] | CompositeFilterDescriptor[], subItemsField: string): any[];

/**
 * @hidden
 */
export declare const FilterCell: DefineComponent<ExtractPropTypes<    {
id: PropType<string>;
grid: PropType<any>;
field: PropType<string>;
filterType: PropType<string>;
colSpan: PropType<number>;
title: PropType<string>;
value: PropType<any>;
operator: PropType<string>;
operators: PropType<FilterOperators_2[]>;
booleanValues: PropType<FilterOperator_3[]>;
onChange: PropType<(event: {
value: any;
operator: string | Function;
event: any;
}) => void>;
render: PropType<any>;
ariaLabel: PropType<string>;
size: PropType<string>;
}>, {
kendoIntlService: {};
kendoLocalizationService: {};
}, {}, {}, {
inputChange(value: any, e: any): void;
operatorChange(operatorValue: any, e: any): void;
boolDropdownChange(value: any, e: any): void;
clear(e: any): void;
triggerChange(filter: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
change: any;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
id: PropType<string>;
grid: PropType<any>;
field: PropType<string>;
filterType: PropType<string>;
colSpan: PropType<number>;
title: PropType<string>;
value: PropType<any>;
operator: PropType<string>;
operators: PropType<FilterOperators_2[]>;
booleanValues: PropType<FilterOperator_3[]>;
onChange: PropType<(event: {
value: any;
operator: string | Function;
event: any;
}) => void>;
render: PropType<any>;
ariaLabel: PropType<string>;
size: PropType<string>;
}>> & Readonly<{
onChange?: (...args: any[] | unknown[]) => any;
}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The props of the FilterCell component
 * ([more information and examples]({% slug filtering_grid %})).
 */
/**
 * @hidden
 */
export declare interface FilterCellProps {
    /**
     * @hidden
     */
    id: string;
    /**
     * The instance of the  component.
     */
    grid?: any;
    /**
     * The title of the filter editor.
     */
    title?: string;
    /**
     * The column span of the cell.
     */
    colSpan?: number;
    /**
     * The column field in which the cell is located.
     */
    field?: string;
    /**
     * The type of the filter. Determines which editor will be rendered for filtering.
     * The supported values are the following 0 'text' | 'numeric' | 'boolean' | 'date;
     */
    filterType: string;
    /**
     * The value of the cell.
     */
    value: any;
    /**
     * The operator that will be used for the cell filtering.
     */
    operator: string;
    /**
     * The list of the default operators for the current filter type.
     */
    operators?: FilterOperators[];
    /**
     * The list of values for the Boolean filter.
     */
    booleanValues: FilterOperator[];
    /**
     * The method that will be called if the cell needs to inform its parent  about a change.
     */
    onChange?: (event: {
        value: any;
        operator: string | Function;
        event: any;
    }) => void;
    /**
     * The method for rendering the filter cell.
     */
    render?: any;
    /**
     * The title of the clear button.
     */
    clearButtonTitle?: string;
    /**
     * The ariaLabel of the filter editor.
     */
    ariaLabel?: string;
    /**
     * Configures the `size` of the cell.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - null&mdash;Does not set a size `class`.
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large' | string;
}

/**
 * The FilterChangeEvent object.
 */
export declare interface FilterChangeEvent {
    target: any;
    event: any;
    /**
     * The changed composite filter descriptor.
     */
    filter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare const filterLogicList: {
    text: string;
    operator: string;
}[];

/**
 * A filter operator object.
 */
export declare interface FilterOperator {
    /**
     * The label of the operator.
     */
    text: string;
    /**
     * The operator value.
     */
    operator: any;
}

/**
 * The filter operators for the filters.
 *
 * @example
 * ```jsx-no-run
 * // Default filter operators:
 * const filterOperators: {
 *     'text': [
 *         { text: 'grid.filterContainsOperator', operator: 'contains' },
 *         { text: 'grid.filterNotContainsOperator', operator: 'doesnotcontain' },
 *         { text: 'grid.filterEqOperator', operator: 'eq' },
 *         { text: 'grid.filterNotEqOperator', operator: 'neq' },
 *         { text: 'grid.filterStartsWithOperator', operator: 'startswith' },
 *         { text: 'grid.filterEndsWithOperator', operator: 'endswith' },
 *         { text: 'grid.filterIsNullOperator', operator: 'isnull' },
 *         { text: 'grid.filterIsNotNullOperator', operator: 'isnotnull' },
 *         { text: 'grid.filterIsEmptyOperator', operator: 'isempty' },
 *         { text: 'grid.filterIsNotEmptyOperator', operator: 'isnotempty' }
 *     ],
 *     'numeric': [
 *         { text: 'grid.filterEqOperator', operator: 'eq' },
 *         { text: 'grid.filterNotEqOperator', operator: 'neq' },
 *         { text: 'grid.filterGteOperator', operator: 'gte' },
 *         { text: 'grid.filterGtOperator', operator: 'gt' },
 *         { text: 'grid.filterLteOperator', operator: 'lte' },
 *         { text: 'grid.filterLtOperator', operator: 'lt' },
 *         { text: 'grid.filterIsNullOperator', operator: 'isnull' },
 *         { text: 'grid.filterIsNotNullOperator', operator: 'isnotnull' }
 *     ],
 *     'date': [
 *         { text: 'grid.filterEqOperator', operator: 'eq' },
 *         { text: 'grid.filterNotEqOperator', operator: 'neq' },
 *         { text: 'grid.filterAfterOrEqualOperator', operator: 'gte' },
 *         { text: 'grid.filterAfterOperator', operator: 'gt' },
 *         { text: 'grid.filterBeforeOperator', operator: 'lt' },
 *         { text: 'grid.filterBeforeOrEqualOperator', operator: 'lte' },
 *         { text: 'grid.filterIsNullOperator', operator: 'isnull' },
 *         { text: 'grid.filterIsNotNullOperator', operator: 'isnotnull' }
 *     ],
 *     'boolean': [
 *         { text: 'grid.filterEqOperator', operator: 'eq' }
 *     ]
 * }
 * ```
 */
export declare interface FilterOperators {
    [type: string]: FilterOperator[];
}

/**
 * The props of the Filter component.
 */
export declare interface FilterProps {
    /**
     * The fields settings of the Filter.
     */
    fields: Array<FieldSettings>;
    /**
     * The composite filter descriptor value.
     */
    value: CompositeFilterDescriptor;
    /**
     * @hidden
     */
    modelValue?: any;
    /**
     * The Filter onChange event.
     */
    onChange?: (event: FilterChangeEvent) => void;
    /**
     * The initial composite filter descriptor which will be used when a new group is created.
     */
    defaultGroupFilter?: CompositeFilterDescriptor;
    /**
     * Defines the `aria-label` attribute of the upper-most Toolbar that is part of the Filter component .
     */
    upperToolbarAriaLabel?: string;
}

/**
 * @hidden
 */
export declare const FilterRow: DefineComponent<ExtractPropTypes<    {
grid: PropType<any>;
columns: PropType<ExtendedColumnProps[]>;
filter: PropType<any>;
filterOperators: PropType<FilterOperators>;
sort: PropType<SortDescriptor[]>;
cellRender: PropType<any>;
isRtl: PropType<boolean>;
ariaRowIndex: PropType<number>;
size: PropType<string>;
}>, {
kendoLocalizationService: {};
}, {}, {}, {
headerCellClassName(field?: string, locked?: boolean): string;
setFilter(value: string | number, operator: string | Function, field: string | undefined, e: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
grid: PropType<any>;
columns: PropType<ExtendedColumnProps[]>;
filter: PropType<any>;
filterOperators: PropType<FilterOperators>;
sort: PropType<SortDescriptor[]>;
cellRender: PropType<any>;
isRtl: PropType<boolean>;
ariaRowIndex: PropType<number>;
size: PropType<string>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare interface FilterRowProps {
    grid: any;
    columns: ExtendedColumnProps[];
    filter?: CompositeFilterDescriptor | any;
    filterOperators: FilterOperators;
    sort?: SortDescriptor[];
    cellRender?: any;
    isRtl?: boolean;
    ariaRowIndex?: number;
    size?: string;
}

/**
 * @hidden
 */
export declare const FOCUSABLE_ELEMENTS: string[];

/** @hidden */
export declare const getColumnIndex: (element: HTMLTableCellElement) => number;

/**
 * @hidden
 */
export declare const getDefaultOperator: (filterOperators: FilterOperators | FilterOperator[], filterType?: string) => any;

/**
 * @hidden
 */
export declare const getFilterType: (filterType: 'text' | 'numeric' | 'boolean' | 'date' | undefined) => "boolean" | "text" | "date" | "numeric";

/**
 * Get all group ids from the data.
 *
 * @param {{data: any[]}} options - The options to be processed.
 * @returns {string[]} - Collection of all group ids from the data.
 */
export declare const getGroupIds: (options: {
    data: any;
}) => string[];

/**
 * @hidden
 */
export declare function getIndex(event: any, parent: HTMLTableRowElement | HTMLDivElement | null): number;

/** @hidden */
export declare const getOffset: (offsetParent: any) => any;

/** @hidden */
export declare const getRowIndex: (element: HTMLTableRowElement) => number;

/**
 * Get selected state from the component selection event.
 *
 * @param {{event: TableSelectionChangeEvent, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string}} options
 * @returns {{[id: string]: boolean | number[]}} - The new selected state.
 */
export declare const getSelectedState: (options: {
    event: TableSelectionChangeEvent;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
}) => {
    [id: string]: boolean | number[];
};

/**
 * Get selected state from the component KeyDown event.
 *
 * @param {{event: TableKeyDownEvent, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string}} options
 * @returns {{[id: string]: boolean | number[]}} - The new selected state.
 */
export declare const getSelectedStateFromKeyDown: (options: {
    event: TableKeyDownEvent;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
}) => {
    [id: string]: boolean | number[];
};

/** @hidden */
export declare const getSelectionOptions: (selectable?: TableSelectableSettings) => {
    enabled: boolean;
    drag: boolean;
    mode: TableSelectableMode_2;
    cell: boolean;
};

/**
 * The pager settings of the Grid ([see example]({% slug paging_grid %})).
 *
 * @example
 * ```tsx-no-run
 *
 * <Grid :pageable="{buttonCount: 2,info: false}">
 * </Grid>
 * ```
 */
export declare interface GridPagerSettings {
    /**
     * Sets the selected value of the page size Dropdownlist. It is useful when the selected value could also be a string not only a number.
     */
    pageSizeValue?: string | number;
    /**
     * Sets the maximum numeric buttons count before the buttons are collapsed.
     */
    buttonCount?: number;
    /**
     * Toggles the information about the current page and the total number of records.
     */
    info?: boolean;
    /**
     * Defines the type of the Grid pager.
     */
    type?: string;
    /**
     * Shows a menu for selecting the page size.
     */
    pageSizes?: boolean | Array<number>;
    /**
     * Toggles the **Previous** and **Next** buttons.
     */
    previousNext?: boolean;
    /**
     * Defines if the pager will be responsive. Defaults to `true`.
     */
    responsive?: boolean;
}

/**
 * The type of the Grid pager.
 *
 * The available values are:
 * * `numeric`&mdash;Buttons with numbers.
 * * `input`&mdash;An input field for typing the page number.
 *
 * @example
 * ```tsx-no-run
 *
 *   <Grid
 *     :data-items="products"
 *     :columns="columns"
 *     :pageable="{ type: 'numeric'}">
 *   </Grid>
 * ```
 */
export declare type GridPagerType = 'numeric' | 'input';

/**
 * @hidden
 */
export declare interface GroupChangeEvent {
    target: any;
    event: any;
    prevFilter: CompositeFilterDescriptor;
    nextFilter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare const GroupFilter: DefineComponent<ExtractPropTypes<    {
filter: {
type: PropType<CompositeFilterDescriptor>;
required: true;
};
fields: {
type: PropType<FieldSettings[]>;
required: true;
};
defaultGroupFilter: {
type: PropType<CompositeFilterDescriptor>;
required: true;
};
}>, {}, {}, {}, {
replaceFilter(prevFilter: FilterDescriptor | CompositeFilterDescriptor, nextFilter: FilterDescriptor | CompositeFilterDescriptor): CompositeFilterDescriptor;
onChange(event: ExpressionChangeEvent | GroupChangeEvent): void;
onRemove(event: ExpressionRemoveEvent | GroupRemoveEvent): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
change: any;
remove: any;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
filter: {
type: PropType<CompositeFilterDescriptor>;
required: true;
};
fields: {
type: PropType<FieldSettings[]>;
required: true;
};
defaultGroupFilter: {
type: PropType<CompositeFilterDescriptor>;
required: true;
};
}>> & Readonly<{
onChange?: (...args: any[] | unknown[]) => any;
onRemove?: (...args: any[] | unknown[]) => any;
}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare interface GroupProps {
    filter: CompositeFilterDescriptor;
    fields: Array<FieldSettings>;
    defaultGroupFilter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare interface GroupRemoveEvent {
    target: any;
    event: any;
    filter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
declare type handler = (prevIndex: number, nextIndex: number, event: any) => void;

/**
 * @hidden
 */
export declare const Header: DefineComponent<ExtractPropTypes<    {
staticHeaders: PropType<boolean>;
headerRow: PropType<any>;
columnResize: PropType<{
colGroupHeader: any | null;
setIsRtl: (isRtl: boolean) => void;
}>;
cols: PropType<Element[]>;
draggable: PropType<boolean>;
size: PropType<string>;
}>, {
headerWrapRef: Ref<any, any>;
tableRef: Ref<any, any>;
colGroupHeaderRef: Ref<any, any>;
}, {
divStyle: {};
element: any;
headerWrap: any;
table: any;
}, {
wrapperClass(): {
'k-grid-header': boolean;
'k-grid-draggable-header': any;
};
tableClass(): {
[x: string]: any;
'k-table': boolean;
'k-grid-header-table': boolean;
};
}, {
setScrollLeft(scrollLeft: number): void;
setWidth(width: number): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
staticHeaders: PropType<boolean>;
headerRow: PropType<any>;
columnResize: PropType<{
colGroupHeader: any | null;
setIsRtl: (isRtl: boolean) => void;
}>;
cols: PropType<Element[]>;
draggable: PropType<boolean>;
size: PropType<string>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const HeaderCell: DefineComponent<ExtractPropTypes<    {
field: PropType<string>;
title: PropType<string>;
sortable: PropType<SortSettings_2>;
render: PropType<any>;
onHeadercellclick: PropType<any>;
selectionValue: PropType<any>;
}>, {}, {}, {
linkClass(): {
'k-link': boolean;
'!k-cursor-default': boolean;
};
}, {
clickHandler(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
field: PropType<string>;
title: PropType<string>;
sortable: PropType<SortSettings_2>;
render: PropType<any>;
onHeadercellclick: PropType<any>;
selectionValue: PropType<any>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The props of the HeaderCellProps component.
 */
/**
 * @hidden
 */
export declare interface HeaderCellProps {
    /**
     * The key in which the cell is located.
     */
    key?: any;
    /**
     * The column field in which the cell is located.
     */
    field?: string;
    /**
     * The title of the column in which the cell is located.
     */
    title?: string;
    /**
     * The `click` event handler of the cell.
     */
    onClick?: any;
    /**
     * @hidden
     */
    selectionValue?: any;
    /**
     * The method for rendering the header cell.
     */
    sortable?: SortSettings;
    /**
     * The method for rendering the cell.
     */
    render?: any;
    /**
     * The event that is fired when the header cell is clicked.
     */
    onHeadercellclick?: any;
}

/**
 * @hidden
 */
export declare interface HeaderProps {
    ref?: string;
    staticHeaders: boolean;
    headerRow: any;
    columnResize: {
        colGroupHeader: any | null;
        setIsRtl: (isRtl: boolean) => void;
    };
    cols: Element[];
    draggable: boolean;
    size?: string;
}

/**
 * @hidden
 */
export declare const HeaderRow: DefineComponent<ExtractPropTypes<    {
grid: PropType<any>;
cellRender: PropType<string | ((h: any, defaultRendering: any | null, props: HeaderCellProps) => any)>;
groupable: PropType<any>;
reorderable: PropType<boolean>;
sortable: PropType<SortSettings>;
sort: {
type: PropType<any>;
};
selectedField: PropType<string>;
filter: PropType<CompositeFilterDescriptor>;
filterable: PropType<boolean>;
filterOperators: PropType<FilterOperators>;
onFilterChange: PropType<Function>;
filterRow: PropType<any>;
columns: PropType<ExtendedColumnProps[]>;
columnsMap: PropType<number[][]>;
columnResize: PropType<any>;
columnMenu: PropType<any>;
columnMenuAnimate: {
type: PropType<boolean | PopupAnimation>;
default: () => true;
};
size: PropType<string>;
isRtl: PropType<boolean>;
onSortChange: PropType<(descriptors: SortDescriptor[], e: any) => void>;
onSelectionchange: PropType<any>;
onPressHandler: PropType<(draggableEvent: any, element: HTMLElement) => void>;
onDragHandler: PropType<(draggableEvent: any, element: HTMLElement) => void>;
onReleaseHandler: PropType<(draggableEvent: any) => void>;
}>, {}, {
columnMenuOpened: {};
}, {
element(): any;
theadClasses(): any;
}, {
pressHandler(event: any, element: HTMLElement): void;
dragHandler(event: any, element: HTMLElement): void;
releaseHandler(event: any): void;
selectionChangeHandler(options: any): void;
cellClick(e: any, column: ColumnBaseProps): void;
sortChangeHandler(newDescriptor: SortDescriptor[], e: any): void;
filterChangeHandler(newDescriptor: CompositeFilterDescriptor | null, e: any): void;
cellClass(field: string | undefined, headerClassName: string | undefined, locked?: boolean): string;
cellKeyDown(event: any, column: ColumnBaseProps): void;
getTemplate(template: any): any;
columnMenuClose(): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
grid: PropType<any>;
cellRender: PropType<string | ((h: any, defaultRendering: any | null, props: HeaderCellProps) => any)>;
groupable: PropType<any>;
reorderable: PropType<boolean>;
sortable: PropType<SortSettings>;
sort: {
type: PropType<any>;
};
selectedField: PropType<string>;
filter: PropType<CompositeFilterDescriptor>;
filterable: PropType<boolean>;
filterOperators: PropType<FilterOperators>;
onFilterChange: PropType<Function>;
filterRow: PropType<any>;
columns: PropType<ExtendedColumnProps[]>;
columnsMap: PropType<number[][]>;
columnResize: PropType<any>;
columnMenu: PropType<any>;
columnMenuAnimate: {
type: PropType<boolean | PopupAnimation>;
default: () => true;
};
size: PropType<string>;
isRtl: PropType<boolean>;
onSortChange: PropType<(descriptors: SortDescriptor[], e: any) => void>;
onSelectionchange: PropType<any>;
onPressHandler: PropType<(draggableEvent: any, element: HTMLElement) => void>;
onDragHandler: PropType<(draggableEvent: any, element: HTMLElement) => void>;
onReleaseHandler: PropType<(draggableEvent: any) => void>;
}>> & Readonly<{}>, {
columnMenuAnimate: true;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare interface HeaderRowProps extends ColumnDraggableProps {
    grid: any;
    sortable?: SortSettings;
    groupable?: any;
    reorderable?: boolean;
    onSortChange?: (descriptors: SortDescriptor[], e: any) => void;
    sort?: any;
    selectedField?: string;
    filter?: CompositeFilterDescriptor;
    filterOperators: FilterOperators;
    filterable?: boolean | undefined;
    filterRow?: any;
    columns: ExtendedColumnProps[];
    columnResize?: any;
    columnsMap: number[][];
    onSelectionchange?: any;
    cellRender?: ((h: any, defaultRendering: any | null, props: HeaderCellProps) => any) | string | null;
    columnMenu?: any;
    columnMenuAnimate?: boolean | PopupAnimation;
    onFilterChange?: Function;
    isRtl?: boolean;
    size: string;
}

/**
 * @hidden
 */
export declare const HeaderSelectionCell: DefineComponent<ExtractPropTypes<    {
field: PropType<string>;
title: PropType<string>;
sortable: PropType<SortSettings_2>;
selectionValue: PropType<any>;
render: PropType<any>;
}>, {}, {}, {}, {
changeHandle(e: any): void;
clickHandler(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
selectionchange: any;
headercellclick: any;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
field: PropType<string>;
title: PropType<string>;
sortable: PropType<SortSettings_2>;
selectionValue: PropType<any>;
render: PropType<any>;
}>> & Readonly<{
onSelectionchange?: (...args: any[] | unknown[]) => any;
onHeadercellclick?: (...args: any[] | unknown[]) => any;
}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const HeaderTdElement: DefineComponent<ExtractPropTypes<    {
ariaColumnIndex: PropType<number>;
role: PropType<string>;
columnId: PropType<string>;
navigatable: PropType<boolean>;
}>, {
kendoIntlService: {};
kendoLocalizationService: {};
}, {}, {
tdClass(): {
[x: number]: any;
'k-table-td': boolean;
};
}, {
onKeyDown(e: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
keydown: any;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
ariaColumnIndex: PropType<number>;
role: PropType<string>;
columnId: PropType<string>;
navigatable: PropType<boolean>;
}>> & Readonly<{
onKeydown?: (...args: any[] | unknown[]) => any;
}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

export declare interface HeaderTdElementProps {
    ariaColumnIndex?: number;
    colSpan?: number;
    rowSpan?: number;
    role?: string;
    columnId: string;
    navigatable?: boolean;
}

/**
 * @hidden
 */
export declare const HeaderThElement: DefineComponent<ExtractPropTypes<    {
ariaSort: {
type: StringConstructor;
validator: (value: string) => any;
};
ariaLabel: PropType<string>;
ariaColumnIndex: PropType<number>;
ariaSelected: PropType<boolean>;
ariaHaspopup: PropType<string>;
colSpan: PropType<number>;
rowSpan: PropType<number>;
role: PropType<string>;
columnId: PropType<string>;
navigatable: PropType<boolean>;
}>, {
kendoIntlService: {};
kendoLocalizationService: {};
}, {}, {
thClass(): {
[x: number]: any;
'k-table-th': boolean;
};
}, {
onKeyDown(e: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {
keydown: any;
}, string, PublicProps, Readonly<ExtractPropTypes<    {
ariaSort: {
type: StringConstructor;
validator: (value: string) => any;
};
ariaLabel: PropType<string>;
ariaColumnIndex: PropType<number>;
ariaSelected: PropType<boolean>;
ariaHaspopup: PropType<string>;
colSpan: PropType<number>;
rowSpan: PropType<number>;
role: PropType<string>;
columnId: PropType<string>;
navigatable: PropType<boolean>;
}>> & Readonly<{
onKeydown?: (...args: any[] | unknown[]) => any;
}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

export declare interface HeaderThElementProps {
    ariaSort?: string;
    ariaLabel?: string;
    ariaColumnIndex?: number;
    ariaSelected?: boolean;
    ariaHaspopup?: string;
    colSpan?: number;
    rowSpan?: number;
    role?: string;
    columnId: string;
    navigatable?: boolean;
}

/**
 * @hidden
 */
export declare function isRtl(element: HTMLElement | null): boolean;

/**
 * @hidden
 */
export declare const IsUnaryFilter: (operator: string | Function) => boolean;

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_BODY = "data-keyboardnavbody";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_HEADER = "data-keyboardnavheader";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_ID = "data-keyboardnavid";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_LEVEL = "data-keyboardnavlevel";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_SCOPE = "data-keyboardnavscope";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_ZONE = "data-keyboardnavzone";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_FILTER_COL_SUFFIX = "_filter";

/**
 * @hidden
 */
export declare function mapColumns(columns: Array<{
    parentIndex: number;
    colSpan: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    children: any[];
    width?: string | number;
    locked?: boolean;
    index: number;
    left: number;
    right: number;
    rightBorder: boolean;
    ariaColumnIndex: number;
}>): number[][];

/**
 * @hidden
 */
export declare const normalize: (settings: any) => any;

/**
 * @hidden
 */
export declare const NumericFilter: DefineComponent<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
onFilterchange: PropType<(event: {
nextFilter: FilterOperator_2;
}) => void>;
}>, {}, {}, {}, {
onChange(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
onFilterchange: PropType<(event: {
nextFilter: FilterOperator_2;
}) => void>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The props of the NumericFilter component.
 */
export declare interface NumericFilterProps extends TextFilterProps {
}

/**
 * @hidden
 */
export declare const operatorMap: (iterable: Array<any>, service: any) => {
    text: any;
    operator: any;
}[];

/**
 * Represents the operators for the TextFilter, NumericFilter, DateFilter and BooleanFilter components.
 *
 * The text field of each operator object will be resolved according to the
 * [localization messages]({% slug globalization_datatools %}#toc-messages).
 */
export declare class Operators {
    /**
     * An array containing the operators for the TextFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.containsOperator', operator: 'contains' }
     * - { text: 'filter.notContainsOperator', operator: 'doesnotcontain' }
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.startsWithOperator', operator: 'startswith' }
     * - { text: 'filter.endsWithOperator', operator: 'endswith' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     * - { text: 'filter.isEmptyOperator', operator: 'isempty' }
     * - { text: 'filter.isNotEmptyOperator', operator: 'isnotempty' }
     */
    static get text(): FilterOperator[];
    /**
     * An array containing the operators for the NumericFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.gteOperator', operator: 'gte' }
     * - { text: 'filter.gtOperator', operator: 'gt' }
     * - { text: 'filter.lteOperator', operator: 'lte' }
     * - { text: 'filter.ltOperator', operator: 'lt' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     */
    static get numeric(): FilterOperator[];
    /**
     * An array containing the operators for the DateFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.afterOrEqualOperator', operator: 'gte' }
     * - { text: 'filter.afterOperator', operator: 'gt' }
     * - { text: 'filter.beforeOperator', operator: 'lt' }
     * - { text: 'filter.beforeOrEqualOperator', operator: 'lte' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     */
    static get date(): FilterOperator[];
    /**
     * An array containing the operators for the BooleanFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     */
    static get boolean(): FilterOperator[];
}

/**
 * @hidden
 */
export declare const operators: FilterOperators;

/**
 * Orders the specified tree according to the provided sort descriptors.
 *
 * @param {T[]} data - The data that will be sorted.
 * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The sorted data.
 */
export declare function orderBy(data: any[], descriptors: SortDescriptor[], subItemsField: string): any[];

/**
 * The `skip` and `take` configurations which are wrapped in the `page` object.
 */
export declare interface Page {
    /**
     * The number of records that will be skipped.
     */
    skip: number;
    /**
     * The number of records that will be taken.
     */
    take: number;
}

/**
 * Represents the object of the `onPageChange` event.
 */
export declare interface PageChangeEvent {
    /**
     * An event target.
     */
    target: any;
    /**
     * A native DOM event.
     */
    event: any;
    /**
     * The number of records that will be skipped.
     */
    skip: number;
    /**
     * The number of records that will be taken.
     */
    take: number;
}

/**
 * @hidden
 */
export declare const Pager: DefineComponent<ExtractPropTypes<    {
pageSizeValue: PropType<string | number>;
total: PropType<number>;
skip: PropType<number>;
take: PropType<number>;
pageSize: PropType<number>;
settings: PropType<boolean | GridPagerSettings>;
buttonCount: {
type: PropType<number>;
default: number;
};
info: {
type: PropType<boolean>;
default: boolean;
};
type: {
type: PropType<string>;
default: string;
validator: (value: string) => any;
};
pageSizes: {
type: PropType<boolean | number[]>;
};
previousNext: PropType<boolean>;
messagesMap: PropType<(messageKey: string) => ({
messageKey: string;
defaultMessage: string;
})>;
responsive: {
type: PropType<boolean>;
default: boolean;
};
size: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
pagerRender: PropType<any>;
width: PropType<string | number>;
ariaControls: {
type: PropType<string>;
default: any;
};
onPagesizechange: PropType<(event: any) => any>;
onPagechange: PropType<(event: any) => any>;
}>, {
kendoIntlService: {};
kendoLocalizationService: {};
}, {
currentRtl: boolean;
itemsToFit: any;
itemsWidths: any;
}, {
wrapperClass(): object;
totalPages(): number;
currentPage(): number;
currentTake(): number;
showPageSizes(): any;
showInfo(): any;
}, {
changePage(page: number, e: any): void;
triggerPageChange(state: any, event: any): void;
onWindowResize(): void;
transformDimension(initialValue: string | number | undefined): string;
collectPagerChildrenWidths(): (0 | {
class: string;
width: number;
})[];
fitChildrenInParent(parent: HTMLElement, childrenWidths: {
class: string;
width: number;
}[]): string[];
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
pageSizeValue: PropType<string | number>;
total: PropType<number>;
skip: PropType<number>;
take: PropType<number>;
pageSize: PropType<number>;
settings: PropType<boolean | GridPagerSettings>;
buttonCount: {
type: PropType<number>;
default: number;
};
info: {
type: PropType<boolean>;
default: boolean;
};
type: {
type: PropType<string>;
default: string;
validator: (value: string) => any;
};
pageSizes: {
type: PropType<boolean | number[]>;
};
previousNext: PropType<boolean>;
messagesMap: PropType<(messageKey: string) => ({
messageKey: string;
defaultMessage: string;
})>;
responsive: {
type: PropType<boolean>;
default: boolean;
};
size: {
type: PropType<string>;
default: string;
validator: (value: any) => any;
};
pagerRender: PropType<any>;
width: PropType<string | number>;
ariaControls: {
type: PropType<string>;
default: any;
};
onPagesizechange: PropType<(event: any) => any>;
onPagechange: PropType<(event: any) => any>;
}>> & Readonly<{}>, {
type: string;
info: boolean;
size: string;
ariaControls: string;
buttonCount: number;
responsive: boolean;
}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const PagerInfo: DefineComponent<ExtractPropTypes<    {
totalPages: PropType<number>;
currentPage: PropType<number>;
skip: PropType<number>;
messagesMap: PropType<(messageKey: string) => ({
messageKey: string;
defaultMessage: string;
})>;
}>, {
kendoIntlService: {};
kendoLocalizationService: {};
}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
totalPages: PropType<number>;
currentPage: PropType<number>;
skip: PropType<number>;
messagesMap: PropType<(messageKey: string) => ({
messageKey: string;
defaultMessage: string;
})>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const PagerInput: DefineComponent<ExtractPropTypes<    {
totalPages: PropType<number>;
currentPage: PropType<number>;
messagesMap: PropType<(messageKey: string) => ({
messageKey: string;
defaultMessage: string;
})>;
size: PropType<string>;
onPagechange: PropType<(page: number, event: any) => void>;
}>, {
kendoIntlService: {};
kendoLocalizationService: {};
}, {
currentText: any;
}, {
computedValue(): any;
}, {
changeHangler(e: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
totalPages: PropType<number>;
currentPage: PropType<number>;
messagesMap: PropType<(messageKey: string) => ({
messageKey: string;
defaultMessage: string;
})>;
size: PropType<string>;
onPagechange: PropType<(page: number, event: any) => void>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const PagerNavigationButton: DefineComponent<ExtractPropTypes<    {
title: PropType<string>;
disabled: PropType<boolean>;
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
page: PropType<number>;
size: PropType<string>;
onPagechange: PropType<(page: number, event: any) => void>;
}>, {}, {}, {}, {
changePage(e: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
title: PropType<string>;
disabled: PropType<boolean>;
icon: PropType<string>;
svgIcon: PropType<SVGIcon>;
page: PropType<number>;
size: PropType<string>;
onPagechange: PropType<(page: number, event: any) => void>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const PagerNumericButtons: DefineComponent<ExtractPropTypes<    {
buttonCount: PropType<number>;
totalPages: PropType<number>;
currentPage: PropType<number>;
size: PropType<string>;
responsiveSize: PropType<string>;
onPagechange: PropType<(page: number, event: any) => void>;
}>, {}, {}, {
start(): number;
end(): number;
dropdownClass(): {
[x: string]: any;
'k-picker': boolean;
'k-dropdown-list': boolean;
'k-dropdown': boolean;
'k-rounded-md': boolean;
'k-picker-solid': boolean;
};
}, {
click(e: any, page: number): void;
ddlChange(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
buttonCount: PropType<number>;
totalPages: PropType<number>;
currentPage: PropType<number>;
size: PropType<string>;
responsiveSize: PropType<string>;
onPagechange: PropType<(page: number, event: any) => void>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * @hidden
 */
export declare const PagerPageSizes: DefineComponent<ExtractPropTypes<    {
value: PropType<string | number>;
pageSize: PropType<number>;
pageSizes: PropType<boolean | number[]>;
size: PropType<string>;
messagesMap: PropType<(messageKey: string) => ({
messageKey: string;
defaultMessage: string;
})>;
onPagechange: PropType<(event: {
skip: number;
take: number;
}, e: any) => void>;
}>, {
kendoLocalizationService: {};
}, {}, {}, {
pageSizeChange(e: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
value: PropType<string | number>;
pageSize: PropType<number>;
pageSizes: PropType<boolean | number[]>;
size: PropType<string>;
messagesMap: PropType<(messageKey: string) => ({
messageKey: string;
defaultMessage: string;
})>;
onPagechange: PropType<(event: {
skip: number;
take: number;
}, e: any) => void>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

export declare interface PagerProps extends GridPagerSettings {
    total: number;
    skip: number;
    take: number;
    pageSize: number;
    settings?: GridPagerSettings | boolean;
    responsive?: boolean;
    pagerRender?: any;
    width?: number | string;
    /**
     * Configures the `size` of the Pager.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - null&mdash;Does not set a size `class`.
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large' | string;
    /**
     * A map with the messages.
     */
    messagesMap?: (messageKey: string) => ({
        messageKey: string;
        defaultMessage: string;
    });
    /**
     * The event that is emited when the page size is changed.
     */
    onPagesizechange?: (event: any) => any;
    /**
     * The event that is emited when the page is changed.
     */
    onPagechange?: (event: any) => any;
    /**
     * Defines the `id` of the element that is being controlled by the pager - for example a Grid.
     */
    ariaControls?: string;
}

/**
 * @hidden
 */
export declare function readColumns(elements: TreeColumnBaseProps[], idInfo: {
    prevId: number;
    idPrefix: string;
}, depth?: number): ExtendedColumnProps[];

/** @hidden */
export declare const relativeContextElement: (element: any) => any;

/**
 * Apply the `expanded` prop to the group items in data based on the provided collection of group ids.
 *
 * @param {{data: any[], collapsedIds: string[]}} options - The options to be processed.
 * @returns {string[]} - Collection of all group ids from the data.
 */
export declare const setExpandedState: (options: {
    data: any;
    collapsedIds: string[];
}) => any[];

/**
 * Add unique ids to the group items inside data.
 *
 * @param {{data: any[], group: GroupDescriptor[]}} options - The options to be processed.
 */
export declare const setGroupIds: (options: {
    data: any;
    group?: Array<GroupDescriptor>;
}) => void;

/**
 * @hidden
 *
 * Apply the selected field to the data items based on the selected state.
 *
 * @param {{data: any, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string; selectedField: string; subItemsField?: string; }} options
 * @returns {any[]}
 */
export declare const setSelectedState: (options: {
    data: any;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
    selectedField: string;
    subItemsField?: string;
}) => any[];

/**
 * The settings for sorting the component data.
 */
export declare type SortSettings = boolean | ColumnSortSettings & {
    /**
     * The sort mode of the component.
     *
     * The available modes are:
     * - `single`
     * - `multiple`
     */
    mode?: 'single' | 'multiple';
};

/**
 * @hidden
 */
export declare const stringOperator: (operator: any) => boolean;

/**
 * @hidden
 */
export declare const TABBABLE_ELEMENTS: string[];

/** @hidden */
export declare const TABLE_COL_INDEX_ATTRIBUTE = "data-grid-col-index";

/** @hidden */
export declare const TABLE_PREVENT_SELECTION_ELEMENT = "data-prevent-selection";

/** @hidden */
export declare const TABLE_ROW_INDEX_ATTRIBUTE = "data-grid-row-index";

/**
 * @hidden
 */
export declare function tableColumnsVirtualization(args: {
    enabled?: boolean;
    columns: {
        width?: string | number;
        locked?: boolean;
    }[];
    tableViewPortWidth: number;
    scrollLeft: number;
}): {
    colSpans: number[];
    hiddenColumns: boolean[];
};

/** @hidden */
export declare interface TableDragSelectionReleaseEvent {
    /**
     * Selection start row index.
     */
    startRowIndex: number;
    /**
     * Selection start column index.
     */
    startColIndex: number;
    /**
     * Selection end row index.
     */
    endRowIndex: number;
    /**
     * Selection end column index.
     */
    endColIndex: number;
    /**
     * A native DOM event.
     */
    Ðµvent: any;
    /**
     * Is ctrl key modifier pressed.
     */
    ctrlKey: boolean;
    /**
     * Is alt key modifier pressed.
     */
    altKey: boolean;
    /**
     * Is meta key modifier pressed.
     */
    metaKey: boolean;
    /**
     * Is shift key modifier pressed.
     */
    shiftKey: boolean;
    /**
     * Selection mode.
     */
    mode: 'single' | 'multiple';
    /**
     * Indicates if cell selection mode is enabled.
     */
    cell: boolean;
    /**
     * Indicates if current event is created from drag.
     */
    isDrag: boolean;
}

/**
 * @hidden
 */
export declare const tableKeyboardNavigationBodyAttributes: {
    "data-keyboardnavbody": boolean;
};

/**
 * @hidden
 */
export declare interface TableKeyboardNavigationContextType {
    activeId: string | undefined;
    level: number;
}

/**
 * @hidden
 */
export declare const tableKeyboardNavigationHeaderAttributes: {
    "data-keyboardnavheader": boolean;
};

/**
 * @hidden
 */
export declare const TableKeyboardNavigationProvider: DefineComponent<ExtractPropTypes<    {
navigatable: {
type: BooleanConstructor;
default: boolean;
};
id: StringConstructor;
}>, {}, {
scope: any;
kbContext: any;
navigation: any;
}, {}, {
getKeyboardNavigationAttributes(elementId: string): {
tabIndex?: undefined;
"data-keyboardnavlevel"?: undefined;
"data-keyboardnavid"?: undefined;
} | {
tabIndex: number;
"data-keyboardnavlevel": any;
"data-keyboardnavid": string;
};
onComponentDidMount(options: {
scope?: HTMLElement;
}): void;
onGetSnapshotBeforeUpdate(options: {
document: Document;
kbContext: TableKeyboardNavigationContextType;
navigation: TableKeyboardNavigationStateType;
}): void;
onComponentDidUpdate(options: {
scope?: HTMLElement;
kbContext: TableKeyboardNavigationContextType;
navigation: TableKeyboardNavigationStateType;
}): void;
onFocus(event: any): void;
onKeyDown(event: any, options: {
kbContext: TableKeyboardNavigationContextType;
navigation: TableKeyboardNavigationStateType;
onNavigationAction?: (options: {
event: any;
focusElement: any;
}) => void;
}): void;
generateMatrix(options: {
scope?: HTMLElement;
navigation: TableKeyboardNavigationStateType;
}): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
navigatable: {
type: BooleanConstructor;
default: boolean;
};
id: StringConstructor;
}>> & Readonly<{}>, {
navigatable: boolean;
}, {}, {}, {}, string, () => {
getKeyboardNavigationAttributes: any;
onNavMount: any;
onGetSnapshotBeforeUpdate: any;
onComponentDidUpdate: any;
onNavFocus: any;
onNavKeyDown: any;
generateMatrix: any;
kbContext: any;
navigation: any;
}, true, {}, any>;

/**
 * @hidden
 */
export declare const tableKeyboardNavigationScopeAttributes: {
    "data-keyboardnavscope": boolean;
};

/**
 * @hidden
 */
export declare interface TableKeyboardNavigationStateType {
    activeElementIsFocused: boolean;
    prevNavigationIndexes?: [number, number];
    idPrefix: string;
    navigationMatrix: string[][];
    lastHeaderIndex: number;
}

/**
 * @hidden
 */
export declare const tableKeyboardNavigationTools: {
    generateNavigatableId: (navigationId: string, idPrefix: string, type?: 'column' | 'cell') => string;
    getNavigatableId: (element: Element | null) => string;
    getNavigatableLevel: (element: Element | null) => number;
    getNavigatableElement: (scope: HTMLElement, options?: {
        level: number;
    }) => HTMLElement;
    getClosestNavigatableElement: (target: HTMLElement) => Element;
    getActiveElement: (scope: HTMLElement, activeId?: string) => HTMLElement;
    getClosestScope: (target: HTMLElement) => Element;
    getHeaderElement: (scope: HTMLElement) => Element;
    getBodyElement: (scope: HTMLElement) => Element;
    getFocusableElements: (scope: HTMLElement, options?: {
        focusable: boolean;
    }) => Element[];
    getNavigatableElements: (scope: HTMLElement | null, options?: {
        level: number;
    }) => any[];
    filterNavigatableElements: (options?: {
        level: number;
    }) => (element: HTMLElement) => boolean;
    focusElement: (options: {
        elementForFocus: HTMLElement;
        prevElement?: HTMLElement;
        kbContext?: TableKeyboardNavigationContextType;
        event: any;
    }) => void;
    getIdPrefix: (navigation?: TableKeyboardNavigationStateType) => string;
    isNavigatable: (element: Element | null) => boolean;
    findNextIdByRowIndex: (initialRowIndex: number, cellIndex: number, elementId: string | undefined, matrix: string[][], isReverse: boolean) => [
    string,
    [
    number,
    number
    ]
    ] | [
    ];
    findNextIdByCellIndex: (rowIndex: number, initialCellIndex: number, elementId: string | undefined, matrix: string[][], isReverse: boolean) => [
    string,
    [
    number,
    number
    ]
    ] | [
    ];
    findId: (navigationMatrix: string[][], cellId?: string) => number[] | undefined;
    getNextNavigationIndex: (navigation?: TableKeyboardNavigationStateType) => number;
    getFilterColumnId: (columnId: string) => string;
};

/** @hidden */
export declare interface TableKeyDownEvent {
    /**
     * The current leaf data items.
     */
    dataItems: any[];
    /**
     * Selection mode
     */
    mode: 'single' | 'multiple';
    /**
     * Indicates if cell selection mode is enabled.
     */
    cell: boolean;
    /**
     * The `selectedField` prop of the component.
     */
    selectedField: string;
    /**
     * The component unique identifier.
     */
    componentId: string;
    /**
     * The component event.
     */
    event: any;
}

/** @hidden */
export declare type TableSelectableMode = 'single' | 'multiple';

/** @hidden */
export declare interface TableSelectableSettings {
    /**
     * Determines if selection is allowed.
     *
     * @default true
     */
    enabled?: boolean;
    /**
     * The available values are:
     * * `single`
     * * `multiple`
     *
     * @default "multiple"
     */
    mode?: TableSelectableMode;
    /**
     * Determines if cell selection is allowed.
     *
     * @default false
     */
    cell?: boolean;
    /**
     * Determines if drag selection is allowed.
     *
     * @default false
     */
    drag?: boolean;
}

/** @hidden */
export declare interface TableSelectionChangeEvent extends TableDragSelectionReleaseEvent {
    /**
     * The data item which was selected or deselected when the checkbox selection column is used. It will be `null` when the row or cell selection is used.
     */
    dataItem: any;
    /**
     * The `selectedField` prop of the component.
     */
    selectedField: string;
    /**
     * The component unique identifier.
     */
    componentId: string;
    /**
     * The current component leaf data items.
     */
    dataItems: any[];
    /**
     * The component event.
     */
    event: any;
}

/**
 * @hidden
 */
export declare const TextFilter: DefineComponent<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
ariaLabel: PropType<string>;
onFilterchange: PropType<(event: {
nextFilter: FilterOperator;
}) => void>;
}>, {}, {}, {}, {
onChange(event: any): void;
}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, PublicProps, Readonly<ExtractPropTypes<    {
filter: {
type: PropType<FilterDescriptor>;
required: true;
};
ariaLabel: PropType<string>;
onFilterchange: PropType<(event: {
nextFilter: FilterOperator;
}) => void>;
}>> & Readonly<{}>, {}, {}, {}, {}, string, ComponentProvideOptions, true, {}, any>;

/**
 * The props of the TextFilter component.
 */
export declare interface TextFilterProps {
    /**
     * The FilterDescriptor object which will be edited.
     */
    filter: FilterDescriptor;
    /**
     * The FilterChange event, triggered while editing the FilterOperator.
     */
    onFilterchange?: (event: {
        nextFilter: FilterOperator;
    }) => void;
    /**
     * The accessible label of the component.
     */
    ariaLabel?: string;
}

/**
 * @hidden
 */
export declare interface TreeColumnBaseProps extends ColumnBaseProps {
    /**
     * A collection of child columns.
     */
    children?: TreeColumnBaseProps[];
    /**
     * The column menu component. If set to `true`, the column menu will be rendered.
     */
    columnMenu?: any;
    /**
     * If set to `true`, the column will render the icons that are used for expanding and collapsing child rows.
     */
    expandable?: boolean;
    /**
     * Defines the component that will be rendered as an edit cell.
     */
    editCell?: any;
    /**
     * Defines the component that will be rendered as a header cell.
     * If not set, a `HeaderCell` will be rendered by default.
     */
    headerCell?: any;
    /**
     * **Deprecated**. Use `filterCell` prop instead.
     */
    filter?: any;
    /**
     * Defines the component that will be rendered as a filter cell.
     */
    filterCell?: any;
}

/**
 * @hidden
 */
export declare const unaryOperator: (operator: any) => boolean;

export { }
