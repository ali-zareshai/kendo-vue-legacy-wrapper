/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { mapTree as _, extendDataItem as L, Keys as B, hasRelativeStackingContext as N } from "@progress/kendo-vue-common";
import { TABLE_ROW_INDEX_ATTRIBUTE as O, TABLE_COL_INDEX_ATTRIBUTE as F } from "./constants.mjs";
const M = "items", m = {}, U = (e, t) => !e || Array.isArray(e) && e.length === 0 ? [t] : e.findIndex((o) => o === t) > -1 ? e.filter((o) => o === t) : [...e, t], h = (e, t) => {
  let n = e;
  for (; n; ) {
    if (n.tagName === t)
      return n;
    if (n.tagName === "TABLE")
      return null;
    n = n.parentElement;
  }
  return null;
}, X = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(O);
  return t ? parseInt(t, 10) : void 0;
}, k = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(F);
  return t ? parseInt(t, 10) : void 0;
}, j = (e) => {
  const t = e.subItemsField || M;
  return _(
    e.data,
    t,
    (n) => L(n, t, {
      [e.selectedField]: e.selectedState[n[e.dataItemKey]]
    })
  );
}, q = (e) => {
  const { dataItemKey: t, selectedState: n } = e, { event: o, dataItems: l, componentId: s, mode: u, cell: a, selectedField: g } = e.event, { target: I, ctrlKey: w, metaKey: S, altKey: D, shiftKey: C } = o;
  if (o.isDefaultPrevented() || o.keyCode !== B.enter)
    return n;
  const c = h(I, "TD"), p = h(I, "TR"), E = k(c), r = X(p);
  let x = {};
  return c && p && r !== void 0 && E !== void 0 && (x = G({
    selectedState: n,
    dataItemKey: t,
    event: {
      ctrlKey: w,
      metaKey: S,
      altKey: D,
      shiftKey: C,
      dataItems: l,
      cell: a,
      mode: u,
      selectedField: g,
      componentId: s,
      startColIndex: E,
      endColIndex: E,
      startRowIndex: r,
      endRowIndex: r,
      isDrag: !1,
      event: o,
      target: o.target,
      dataItem: null
    }
  })), x;
}, G = (e) => {
  const { event: t, dataItemKey: n, selectedState: o } = e, {
    dataItems: l,
    startRowIndex: s,
    endRowIndex: u,
    startColIndex: a,
    endColIndex: g,
    cell: I,
    isDrag: w,
    ctrlKey: S,
    shiftKey: D,
    metaKey: C,
    componentId: c,
    mode: p,
    dataItem: E
  } = t;
  let r = {};
  const x = E !== null;
  if (p === "single") {
    const f = l.slice(s, s + 1)[0][n];
    m[c] = {
      rowIndex: s,
      colIndex: a
    }, r[f] = I ? [a] : !0;
  } else if (w || !D && !S && !C && !x) {
    w || (m[c] = {
      rowIndex: s,
      colIndex: a
    });
    const i = [];
    for (let d = a; d <= g; d++)
      i.push(d);
    l.slice(s, u + 1).forEach((d) => {
      const y = d[n];
      r[y] = I ? [...i] : !0;
    });
  } else if (S || C || x) {
    m[c] = {
      rowIndex: s,
      colIndex: a
    };
    const d = l.slice(s, u + 1)[0][n];
    r = { ...o }, r[d] = I && !x ? U(r[d], a) : !r[d];
  } else if (D) {
    const i = m[c] && m[c].rowIndex || 0, f = m[c] && m[c].colIndex || 0, d = Math.min(i, s, u), y = Math.max(i, s, u), A = Math.min(f, a, g), v = Math.max(f, a, g), R = [];
    for (let T = A; T <= v; T++)
      R.push(T);
    l.slice(d, y + 1).forEach((T) => {
      const K = T[n];
      r[K] = I ? [...R] : !0;
    });
  }
  return r;
}, H = N(), z = (e) => {
  if (!e || !H)
    return null;
  let t = e.parentElement;
  for (; t; ) {
    if (window.getComputedStyle(t).transform !== "none")
      return t;
    t = t.parentElement;
  }
}, J = (e) => {
  if (e && e.ownerDocument && e !== e.ownerDocument.body) {
    const t = e.getBoundingClientRect();
    return {
      left: t.left - e.scrollLeft,
      top: t.top - e.scrollTop
    };
  }
  return { left: 0, top: 0 };
}, Q = (e) => {
  const t = e ? typeof e.enabled == "boolean" ? e.enabled : !0 : !1, n = e ? !!e.drag : !1, o = e && e.mode ? e.mode : "multiple", l = !!(e && e.cell);
  return { enabled: t, drag: n, mode: o, cell: l };
};
export {
  h as closestTagName,
  k as getColumnIndex,
  J as getOffset,
  X as getRowIndex,
  G as getSelectedState,
  q as getSelectedStateFromKeyDown,
  Q as getSelectionOptions,
  z as relativeContextElement,
  j as setSelectedState
};
